Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     class_decl -> CLASS IDENT { class_body } ;
Rule 8     class_body -> class_member_list
Rule 9     class_member_list -> class_member
Rule 10    class_member_list -> class_member_list class_member
Rule 11    class_member -> type_spec IDENT ( params ) compound_stmt
Rule 12    var_decl -> type_spec IDENT [ ] ;
Rule 13    var_decl -> type_spec IDENT ;
Rule 14    type_spec -> FLOAT
Rule 15    type_spec -> INT
Rule 16    type_spec -> BOOL
Rule 17    type_spec -> VOID
Rule 18    func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt
Rule 19    _1_params_optional -> params
Rule 20    _1_params_optional -> <empty>
Rule 21    params -> VOID
Rule 22    params -> param_list
Rule 23    param_list -> param
Rule 24    param_list -> param_list , param
Rule 25    param -> type_spec IDENT [ ]
Rule 26    param -> type_spec IDENT
Rule 27    compound_stmt -> { local_decls stmt_list }
Rule 28    local_decls -> empty
Rule 29    local_decls -> local_decl_list
Rule 30    local_decl_list -> local_decl
Rule 31    local_decl_list -> local_decl_list local_decl
Rule 32    local_decl -> type_spec IDENT [ ] ;
Rule 33    local_decl -> type_spec IDENT ;
Rule 34    stmt_list -> stmt
Rule 35    stmt_list -> stmt_list stmt
Rule 36    stmt -> sprintf_stmt
Rule 37    stmt -> scanf_stmt
Rule 38    stmt -> printf_stmt
Rule 39    stmt -> for_stmt
Rule 40    stmt -> break_stmt
Rule 41    stmt -> return_stmt
Rule 42    stmt -> while_stmt
Rule 43    stmt -> if_stmt
Rule 44    stmt -> compound_stmt
Rule 45    stmt -> expr_stmt
Rule 46    expr_stmt -> ;
Rule 47    expr_stmt -> expr ;
Rule 48    while_stmt -> WHILE ( expr ) stmt
Rule 49    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 50    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=3]
Rule 51    if_stmt -> IF ( expr ) stmt  [precedence=left, level=2]
Rule 52    return_stmt -> RETURN expr ;
Rule 53    return_stmt -> RETURN ;
Rule 54    break_stmt -> CONTINUE ;
Rule 55    break_stmt -> BREAK ;
Rule 56    expr -> expr DIVEQ expr ;
Rule 57    expr -> expr MULEQ expr ;
Rule 58    expr -> expr MINUSEQ expr ;
Rule 59    expr -> expr PLUSEQ expr ;
Rule 60    expr -> MINUSMINUS expr ;
Rule 61    expr -> PLUSPLUS expr ;
Rule 62    expr -> expr MINUSMINUS ;
Rule 63    expr -> expr PLUSPLUS ;
Rule 64    expr -> NEW type_spec [ expr ]
Rule 65    expr -> STRING
Rule 66    expr -> FLOAT_LIT
Rule 67    expr -> INT_LIT
Rule 68    expr -> BOOL_LIT
Rule 69    expr -> IDENT . SIZE ;
Rule 70    expr -> IDENT ( args )
Rule 71    expr -> IDENT [ expr ]
Rule 72    expr -> IDENT
Rule 73    expr -> ( expr )
Rule 74    expr -> + expr  [precedence=right, level=11]
Rule 75    expr -> - expr  [precedence=right, level=11]
Rule 76    expr -> ! expr  [precedence=right, level=11]
Rule 77    expr -> expr AND expr  [precedence=left, level=6]
Rule 78    expr -> expr OR expr  [precedence=left, level=5]
Rule 79    expr -> expr % expr  [precedence=left, level=10]
Rule 80    expr -> expr / expr  [precedence=left, level=10]
Rule 81    expr -> expr * expr  [precedence=left, level=10]
Rule 82    expr -> expr - expr  [precedence=left, level=9]
Rule 83    expr -> expr + expr  [precedence=left, level=9]
Rule 84    expr -> expr > expr  [precedence=left, level=8]
Rule 85    expr -> expr GE expr  [precedence=left, level=8]
Rule 86    expr -> expr < expr  [precedence=left, level=8]
Rule 87    expr -> expr LE expr  [precedence=left, level=8]
Rule 88    expr -> expr NE expr  [precedence=left, level=7]
Rule 89    expr -> expr EQ expr  [precedence=left, level=7]
Rule 90    expr -> expr POINT IDENT = expr ;
Rule 91    expr -> expr POINT IDENT ;
Rule 92    expr -> SUPER POINT IDENT ;
Rule 93    expr -> THIS
Rule 94    expr -> IDENT [ expr ] = expr  [precedence=right, level=4]
Rule 95    expr -> IDENT = expr  [precedence=right, level=4]
Rule 96    args -> empty
Rule 97    args -> arg_list
Rule 98    arg_list -> expr
Rule 99    arg_list -> arg_list , expr
Rule 100   printf_stmt -> PRINTF ( STRING , arg_list ) ;
Rule 101   printf_stmt -> PRINTF ( STRING ) ;
Rule 102   scanf_stmt -> SCANF ( STRING , arg_list ) ;
Rule 103   sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ;
Rule 104   empty -> <empty>

Terminals, with rules where they appear:

!                    : 76
%                    : 79
(                    : 11 18 48 49 50 51 70 73 100 101 102 103
)                    : 11 18 48 49 50 51 70 73 100 101 102 103
*                    : 81
+                    : 74 83
,                    : 24 99 100 102 103 103
-                    : 75 82
.                    : 69
/                    : 80
;                    : 7 12 13 32 33 46 47 49 49 52 53 54 55 56 57 58 59 60 61 62 63 69 90 91 92 100 101 102 103
<                    : 86
=                    : 90 94 95
>                    : 84
AND                  : 77
BOOL                 : 16
BOOL_LIT             : 68
BREAK                : 55
CLASS                : 7
CONTINUE             : 54
DIVEQ                : 56
ELSE                 : 50
EQ                   : 89
FLOAT                : 14
FLOAT_LIT            : 66
FOR                  : 49
GE                   : 85
IDENT                : 7 11 12 13 18 25 26 32 33 69 70 71 72 90 91 92 94 95 103
IF                   : 50 51
INT                  : 15
INT_LIT              : 67
LE                   : 87
MINUSEQ              : 58
MINUSMINUS           : 60 62
MULEQ                : 57
NE                   : 88
NEW                  : 64
OR                   : 78
PLUSEQ               : 59
PLUSPLUS             : 61 63
POINT                : 90 91 92
PRINTF               : 100 101
RETURN               : 52 53
SCANF                : 102
SIZE                 : 69
SPRINTF              : 103
STRING               : 65 100 101 102 103
SUPER                : 92
THIS                 : 93
VOID                 : 17 21
WHILE                : 48
[                    : 12 25 32 64 71 94
]                    : 12 25 32 64 71 94
error                : 
{                    : 7 27
}                    : 7 27

Nonterminals, with rules where they appear:

_1_params_optional   : 18
arg_list             : 97 99 100 102 103
args                 : 70
break_stmt           : 40
class_body           : 7
class_decl           : 4
class_member         : 9 10
class_member_list    : 8 10
compound_stmt        : 11 18 44
decl                 : 2 3
decl_list            : 1 3
empty                : 28 96
expr                 : 47 48 49 49 49 50 51 52 56 56 57 57 58 58 59 59 60 61 62 63 64 71 73 74 75 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 94 94 95 98 99
expr_stmt            : 45
for_stmt             : 39
func_decl            : 5
if_stmt              : 43
local_decl           : 30 31
local_decl_list      : 29 31
local_decls          : 27
param                : 23 24
param_list           : 22 24
params               : 11 19
printf_stmt          : 38
program              : 0
return_stmt          : 41
scanf_stmt           : 37
sprintf_stmt         : 36
stmt                 : 34 35 48 49 50 50 51
stmt_list            : 27 35
type_spec            : 11 12 13 18 25 26 32 33 64
var_decl             : 6
while_stmt           : 42


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (18) func_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (12) var_decl -> . type_spec IDENT [ ] ;
    (13) var_decl -> . type_spec IDENT ;
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (18) func_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (12) var_decl -> . type_spec IDENT [ ] ;
    (13) var_decl -> . type_spec IDENT ;
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) class_decl -> CLASS . IDENT { class_body } ;
    IDENT           shift and go to state 14


state 8

    (18) func_decl -> type_spec . IDENT ( _1_params_optional ) compound_stmt
    (12) var_decl -> type_spec . IDENT [ ] ;
    (13) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 15


state 9

    (14) type_spec -> FLOAT .
    IDENT           reduce using rule 14 (type_spec -> FLOAT .)
    [               reduce using rule 14 (type_spec -> FLOAT .)


state 10

    (15) type_spec -> INT .
    IDENT           reduce using rule 15 (type_spec -> INT .)
    [               reduce using rule 15 (type_spec -> INT .)


state 11

    (16) type_spec -> BOOL .
    IDENT           reduce using rule 16 (type_spec -> BOOL .)
    [               reduce using rule 16 (type_spec -> BOOL .)


state 12

    (17) type_spec -> VOID .
    IDENT           reduce using rule 17 (type_spec -> VOID .)
    [               reduce using rule 17 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (7) class_decl -> CLASS IDENT . { class_body } ;
    {               shift and go to state 16


state 15

    (18) func_decl -> type_spec IDENT . ( _1_params_optional ) compound_stmt
    (12) var_decl -> type_spec IDENT . [ ] ;
    (13) var_decl -> type_spec IDENT . ;
    (               shift and go to state 17
    [               shift and go to state 18
    ;               shift and go to state 19


state 16

    (7) class_decl -> CLASS IDENT { . class_body } ;
    (8) class_body -> . class_member_list
    (9) class_member_list -> . class_member
    (10) class_member_list -> . class_member_list class_member
    (11) class_member -> . type_spec IDENT ( params ) compound_stmt
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_body                     shift and go to state 20
    class_member_list              shift and go to state 21
    class_member                   shift and go to state 22
    type_spec                      shift and go to state 23

state 17

    (18) func_decl -> type_spec IDENT ( . _1_params_optional ) compound_stmt
    (19) _1_params_optional -> . params
    (20) _1_params_optional -> .
    (21) params -> . VOID
    (22) params -> . param_list
    (23) param_list -> . param
    (24) param_list -> . param_list , param
    (25) param -> . type_spec IDENT [ ]
    (26) param -> . type_spec IDENT
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    )               reduce using rule 20 (_1_params_optional -> .)
    VOID            shift and go to state 27
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 24
    _1_params_optional             shift and go to state 25
    params                         shift and go to state 26
    param_list                     shift and go to state 28
    param                          shift and go to state 29

state 18

    (12) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 30


state 19

    (13) var_decl -> type_spec IDENT ; .
    CLASS           reduce using rule 13 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 13 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 13 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 13 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 13 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 13 (var_decl -> type_spec IDENT ; .)


state 20

    (7) class_decl -> CLASS IDENT { class_body . } ;
    }               shift and go to state 31


state 21

    (8) class_body -> class_member_list .
    (10) class_member_list -> class_member_list . class_member
    (11) class_member -> . type_spec IDENT ( params ) compound_stmt
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    }               reduce using rule 8 (class_body -> class_member_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_member                   shift and go to state 32
    type_spec                      shift and go to state 23

state 22

    (9) class_member_list -> class_member .
    FLOAT           reduce using rule 9 (class_member_list -> class_member .)
    INT             reduce using rule 9 (class_member_list -> class_member .)
    BOOL            reduce using rule 9 (class_member_list -> class_member .)
    VOID            reduce using rule 9 (class_member_list -> class_member .)
    }               reduce using rule 9 (class_member_list -> class_member .)


state 23

    (11) class_member -> type_spec . IDENT ( params ) compound_stmt
    IDENT           shift and go to state 33


state 24

    (25) param -> type_spec . IDENT [ ]
    (26) param -> type_spec . IDENT
    IDENT           shift and go to state 34


state 25

    (18) func_decl -> type_spec IDENT ( _1_params_optional . ) compound_stmt
    )               shift and go to state 35


state 26

    (19) _1_params_optional -> params .
    )               reduce using rule 19 (_1_params_optional -> params .)


state 27

    (21) params -> VOID .
    (17) type_spec -> VOID .
    )               reduce using rule 21 (params -> VOID .)
    IDENT           reduce using rule 17 (type_spec -> VOID .)


state 28

    (22) params -> param_list .
    (24) param_list -> param_list . , param
    )               reduce using rule 22 (params -> param_list .)
    ,               shift and go to state 36


state 29

    (23) param_list -> param .
    ,               reduce using rule 23 (param_list -> param .)
    )               reduce using rule 23 (param_list -> param .)


state 30

    (12) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 37


state 31

    (7) class_decl -> CLASS IDENT { class_body } . ;
    ;               shift and go to state 38


state 32

    (10) class_member_list -> class_member_list class_member .
    FLOAT           reduce using rule 10 (class_member_list -> class_member_list class_member .)
    INT             reduce using rule 10 (class_member_list -> class_member_list class_member .)
    BOOL            reduce using rule 10 (class_member_list -> class_member_list class_member .)
    VOID            reduce using rule 10 (class_member_list -> class_member_list class_member .)
    }               reduce using rule 10 (class_member_list -> class_member_list class_member .)


state 33

    (11) class_member -> type_spec IDENT . ( params ) compound_stmt
    (               shift and go to state 39


state 34

    (25) param -> type_spec IDENT . [ ]
    (26) param -> type_spec IDENT .
    [               shift and go to state 40
    ,               reduce using rule 26 (param -> type_spec IDENT .)
    )               reduce using rule 26 (param -> type_spec IDENT .)


state 35

    (18) func_decl -> type_spec IDENT ( _1_params_optional ) . compound_stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 42

    compound_stmt                  shift and go to state 41

state 36

    (24) param_list -> param_list , . param
    (25) param -> . type_spec IDENT [ ]
    (26) param -> . type_spec IDENT
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 43
    type_spec                      shift and go to state 24

state 37

    (12) var_decl -> type_spec IDENT [ ] ; .
    CLASS           reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 12 (var_decl -> type_spec IDENT [ ] ; .)


state 38

    (7) class_decl -> CLASS IDENT { class_body } ; .
    CLASS           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    FLOAT           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    INT             reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    BOOL            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    VOID            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    $end            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)


state 39

    (11) class_member -> type_spec IDENT ( . params ) compound_stmt
    (21) params -> . VOID
    (22) params -> . param_list
    (23) param_list -> . param
    (24) param_list -> . param_list , param
    (25) param -> . type_spec IDENT [ ]
    (26) param -> . type_spec IDENT
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    VOID            shift and go to state 27
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 24
    params                         shift and go to state 44
    param_list                     shift and go to state 28
    param                          shift and go to state 29

state 40

    (25) param -> type_spec IDENT [ . ]
    ]               shift and go to state 45


state 41

    (18) func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .
    CLASS           reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    FLOAT           reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    INT             reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    BOOL            reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    VOID            reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    $end            reduce using rule 18 (func_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)


state 42

    (27) compound_stmt -> { . local_decls stmt_list }
    (28) local_decls -> . empty
    (29) local_decls -> . local_decl_list
    (104) empty -> .
    (30) local_decl_list -> . local_decl
    (31) local_decl_list -> . local_decl_list local_decl
    (32) local_decl -> . type_spec IDENT [ ] ;
    (33) local_decl -> . type_spec IDENT ;
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    SPRINTF         reduce using rule 104 (empty -> .)
    SCANF           reduce using rule 104 (empty -> .)
    PRINTF          reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    CONTINUE        reduce using rule 104 (empty -> .)
    BREAK           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    {               reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    MINUSMINUS      reduce using rule 104 (empty -> .)
    PLUSPLUS        reduce using rule 104 (empty -> .)
    NEW             reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    FLOAT_LIT       reduce using rule 104 (empty -> .)
    INT_LIT         reduce using rule 104 (empty -> .)
    BOOL_LIT        reduce using rule 104 (empty -> .)
    IDENT           reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    !               reduce using rule 104 (empty -> .)
    SUPER           reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 46
    empty                          shift and go to state 47
    local_decl_list                shift and go to state 48
    local_decl                     shift and go to state 49
    type_spec                      shift and go to state 50

state 43

    (24) param_list -> param_list , param .
    ,               reduce using rule 24 (param_list -> param_list , param .)
    )               reduce using rule 24 (param_list -> param_list , param .)


state 44

    (11) class_member -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 51


state 45

    (25) param -> type_spec IDENT [ ] .
    ,               reduce using rule 25 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 25 (param -> type_spec IDENT [ ] .)


state 46

    (27) compound_stmt -> { local_decls . stmt_list }
    (34) stmt_list -> . stmt
    (35) stmt_list -> . stmt_list stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    stmt_list                      shift and go to state 52
    stmt                           shift and go to state 53
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63
    expr                           shift and go to state 72

state 47

    (28) local_decls -> empty .
    SPRINTF         reduce using rule 28 (local_decls -> empty .)
    SCANF           reduce using rule 28 (local_decls -> empty .)
    PRINTF          reduce using rule 28 (local_decls -> empty .)
    FOR             reduce using rule 28 (local_decls -> empty .)
    CONTINUE        reduce using rule 28 (local_decls -> empty .)
    BREAK           reduce using rule 28 (local_decls -> empty .)
    RETURN          reduce using rule 28 (local_decls -> empty .)
    WHILE           reduce using rule 28 (local_decls -> empty .)
    IF              reduce using rule 28 (local_decls -> empty .)
    {               reduce using rule 28 (local_decls -> empty .)
    ;               reduce using rule 28 (local_decls -> empty .)
    MINUSMINUS      reduce using rule 28 (local_decls -> empty .)
    PLUSPLUS        reduce using rule 28 (local_decls -> empty .)
    NEW             reduce using rule 28 (local_decls -> empty .)
    STRING          reduce using rule 28 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 28 (local_decls -> empty .)
    INT_LIT         reduce using rule 28 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 28 (local_decls -> empty .)
    IDENT           reduce using rule 28 (local_decls -> empty .)
    (               reduce using rule 28 (local_decls -> empty .)
    +               reduce using rule 28 (local_decls -> empty .)
    -               reduce using rule 28 (local_decls -> empty .)
    !               reduce using rule 28 (local_decls -> empty .)
    SUPER           reduce using rule 28 (local_decls -> empty .)
    THIS            reduce using rule 28 (local_decls -> empty .)


state 48

    (29) local_decls -> local_decl_list .
    (31) local_decl_list -> local_decl_list . local_decl
    (32) local_decl -> . type_spec IDENT [ ] ;
    (33) local_decl -> . type_spec IDENT ;
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    SPRINTF         reduce using rule 29 (local_decls -> local_decl_list .)
    SCANF           reduce using rule 29 (local_decls -> local_decl_list .)
    PRINTF          reduce using rule 29 (local_decls -> local_decl_list .)
    FOR             reduce using rule 29 (local_decls -> local_decl_list .)
    CONTINUE        reduce using rule 29 (local_decls -> local_decl_list .)
    BREAK           reduce using rule 29 (local_decls -> local_decl_list .)
    RETURN          reduce using rule 29 (local_decls -> local_decl_list .)
    WHILE           reduce using rule 29 (local_decls -> local_decl_list .)
    IF              reduce using rule 29 (local_decls -> local_decl_list .)
    {               reduce using rule 29 (local_decls -> local_decl_list .)
    ;               reduce using rule 29 (local_decls -> local_decl_list .)
    MINUSMINUS      reduce using rule 29 (local_decls -> local_decl_list .)
    PLUSPLUS        reduce using rule 29 (local_decls -> local_decl_list .)
    NEW             reduce using rule 29 (local_decls -> local_decl_list .)
    STRING          reduce using rule 29 (local_decls -> local_decl_list .)
    FLOAT_LIT       reduce using rule 29 (local_decls -> local_decl_list .)
    INT_LIT         reduce using rule 29 (local_decls -> local_decl_list .)
    BOOL_LIT        reduce using rule 29 (local_decls -> local_decl_list .)
    IDENT           reduce using rule 29 (local_decls -> local_decl_list .)
    (               reduce using rule 29 (local_decls -> local_decl_list .)
    +               reduce using rule 29 (local_decls -> local_decl_list .)
    -               reduce using rule 29 (local_decls -> local_decl_list .)
    !               reduce using rule 29 (local_decls -> local_decl_list .)
    SUPER           reduce using rule 29 (local_decls -> local_decl_list .)
    THIS            reduce using rule 29 (local_decls -> local_decl_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 89
    type_spec                      shift and go to state 50

state 49

    (30) local_decl_list -> local_decl .
    FLOAT           reduce using rule 30 (local_decl_list -> local_decl .)
    INT             reduce using rule 30 (local_decl_list -> local_decl .)
    BOOL            reduce using rule 30 (local_decl_list -> local_decl .)
    VOID            reduce using rule 30 (local_decl_list -> local_decl .)
    SPRINTF         reduce using rule 30 (local_decl_list -> local_decl .)
    SCANF           reduce using rule 30 (local_decl_list -> local_decl .)
    PRINTF          reduce using rule 30 (local_decl_list -> local_decl .)
    FOR             reduce using rule 30 (local_decl_list -> local_decl .)
    CONTINUE        reduce using rule 30 (local_decl_list -> local_decl .)
    BREAK           reduce using rule 30 (local_decl_list -> local_decl .)
    RETURN          reduce using rule 30 (local_decl_list -> local_decl .)
    WHILE           reduce using rule 30 (local_decl_list -> local_decl .)
    IF              reduce using rule 30 (local_decl_list -> local_decl .)
    {               reduce using rule 30 (local_decl_list -> local_decl .)
    ;               reduce using rule 30 (local_decl_list -> local_decl .)
    MINUSMINUS      reduce using rule 30 (local_decl_list -> local_decl .)
    PLUSPLUS        reduce using rule 30 (local_decl_list -> local_decl .)
    NEW             reduce using rule 30 (local_decl_list -> local_decl .)
    STRING          reduce using rule 30 (local_decl_list -> local_decl .)
    FLOAT_LIT       reduce using rule 30 (local_decl_list -> local_decl .)
    INT_LIT         reduce using rule 30 (local_decl_list -> local_decl .)
    BOOL_LIT        reduce using rule 30 (local_decl_list -> local_decl .)
    IDENT           reduce using rule 30 (local_decl_list -> local_decl .)
    (               reduce using rule 30 (local_decl_list -> local_decl .)
    +               reduce using rule 30 (local_decl_list -> local_decl .)
    -               reduce using rule 30 (local_decl_list -> local_decl .)
    !               reduce using rule 30 (local_decl_list -> local_decl .)
    SUPER           reduce using rule 30 (local_decl_list -> local_decl .)
    THIS            reduce using rule 30 (local_decl_list -> local_decl .)


state 50

    (32) local_decl -> type_spec . IDENT [ ] ;
    (33) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 90


state 51

    (11) class_member -> type_spec IDENT ( params ) . compound_stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 42

    compound_stmt                  shift and go to state 91

state 52

    (27) compound_stmt -> { local_decls stmt_list . }
    (35) stmt_list -> stmt_list . stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    }               shift and go to state 92
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    stmt                           shift and go to state 93
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63
    expr                           shift and go to state 72

state 53

    (34) stmt_list -> stmt .
    }               reduce using rule 34 (stmt_list -> stmt .)
    SPRINTF         reduce using rule 34 (stmt_list -> stmt .)
    SCANF           reduce using rule 34 (stmt_list -> stmt .)
    PRINTF          reduce using rule 34 (stmt_list -> stmt .)
    FOR             reduce using rule 34 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 34 (stmt_list -> stmt .)
    BREAK           reduce using rule 34 (stmt_list -> stmt .)
    RETURN          reduce using rule 34 (stmt_list -> stmt .)
    WHILE           reduce using rule 34 (stmt_list -> stmt .)
    IF              reduce using rule 34 (stmt_list -> stmt .)
    {               reduce using rule 34 (stmt_list -> stmt .)
    ;               reduce using rule 34 (stmt_list -> stmt .)
    MINUSMINUS      reduce using rule 34 (stmt_list -> stmt .)
    PLUSPLUS        reduce using rule 34 (stmt_list -> stmt .)
    NEW             reduce using rule 34 (stmt_list -> stmt .)
    STRING          reduce using rule 34 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 34 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 34 (stmt_list -> stmt .)
    IDENT           reduce using rule 34 (stmt_list -> stmt .)
    (               reduce using rule 34 (stmt_list -> stmt .)
    +               reduce using rule 34 (stmt_list -> stmt .)
    -               reduce using rule 34 (stmt_list -> stmt .)
    !               reduce using rule 34 (stmt_list -> stmt .)
    SUPER           reduce using rule 34 (stmt_list -> stmt .)
    THIS            reduce using rule 34 (stmt_list -> stmt .)


state 54

    (36) stmt -> sprintf_stmt .
    }               reduce using rule 36 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 36 (stmt -> sprintf_stmt .)
    SCANF           reduce using rule 36 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 36 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 36 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 36 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 36 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 36 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 36 (stmt -> sprintf_stmt .)
    IF              reduce using rule 36 (stmt -> sprintf_stmt .)
    {               reduce using rule 36 (stmt -> sprintf_stmt .)
    ;               reduce using rule 36 (stmt -> sprintf_stmt .)
    MINUSMINUS      reduce using rule 36 (stmt -> sprintf_stmt .)
    PLUSPLUS        reduce using rule 36 (stmt -> sprintf_stmt .)
    NEW             reduce using rule 36 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 36 (stmt -> sprintf_stmt .)
    FLOAT_LIT       reduce using rule 36 (stmt -> sprintf_stmt .)
    INT_LIT         reduce using rule 36 (stmt -> sprintf_stmt .)
    BOOL_LIT        reduce using rule 36 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 36 (stmt -> sprintf_stmt .)
    (               reduce using rule 36 (stmt -> sprintf_stmt .)
    +               reduce using rule 36 (stmt -> sprintf_stmt .)
    -               reduce using rule 36 (stmt -> sprintf_stmt .)
    !               reduce using rule 36 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 36 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 36 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 36 (stmt -> sprintf_stmt .)


state 55

    (37) stmt -> scanf_stmt .
    }               reduce using rule 37 (stmt -> scanf_stmt .)
    SPRINTF         reduce using rule 37 (stmt -> scanf_stmt .)
    SCANF           reduce using rule 37 (stmt -> scanf_stmt .)
    PRINTF          reduce using rule 37 (stmt -> scanf_stmt .)
    FOR             reduce using rule 37 (stmt -> scanf_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> scanf_stmt .)
    BREAK           reduce using rule 37 (stmt -> scanf_stmt .)
    RETURN          reduce using rule 37 (stmt -> scanf_stmt .)
    WHILE           reduce using rule 37 (stmt -> scanf_stmt .)
    IF              reduce using rule 37 (stmt -> scanf_stmt .)
    {               reduce using rule 37 (stmt -> scanf_stmt .)
    ;               reduce using rule 37 (stmt -> scanf_stmt .)
    MINUSMINUS      reduce using rule 37 (stmt -> scanf_stmt .)
    PLUSPLUS        reduce using rule 37 (stmt -> scanf_stmt .)
    NEW             reduce using rule 37 (stmt -> scanf_stmt .)
    STRING          reduce using rule 37 (stmt -> scanf_stmt .)
    FLOAT_LIT       reduce using rule 37 (stmt -> scanf_stmt .)
    INT_LIT         reduce using rule 37 (stmt -> scanf_stmt .)
    BOOL_LIT        reduce using rule 37 (stmt -> scanf_stmt .)
    IDENT           reduce using rule 37 (stmt -> scanf_stmt .)
    (               reduce using rule 37 (stmt -> scanf_stmt .)
    +               reduce using rule 37 (stmt -> scanf_stmt .)
    -               reduce using rule 37 (stmt -> scanf_stmt .)
    !               reduce using rule 37 (stmt -> scanf_stmt .)
    SUPER           reduce using rule 37 (stmt -> scanf_stmt .)
    THIS            reduce using rule 37 (stmt -> scanf_stmt .)
    ELSE            reduce using rule 37 (stmt -> scanf_stmt .)


state 56

    (38) stmt -> printf_stmt .
    }               reduce using rule 38 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 38 (stmt -> printf_stmt .)
    SCANF           reduce using rule 38 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 38 (stmt -> printf_stmt .)
    FOR             reduce using rule 38 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 38 (stmt -> printf_stmt .)
    BREAK           reduce using rule 38 (stmt -> printf_stmt .)
    RETURN          reduce using rule 38 (stmt -> printf_stmt .)
    WHILE           reduce using rule 38 (stmt -> printf_stmt .)
    IF              reduce using rule 38 (stmt -> printf_stmt .)
    {               reduce using rule 38 (stmt -> printf_stmt .)
    ;               reduce using rule 38 (stmt -> printf_stmt .)
    MINUSMINUS      reduce using rule 38 (stmt -> printf_stmt .)
    PLUSPLUS        reduce using rule 38 (stmt -> printf_stmt .)
    NEW             reduce using rule 38 (stmt -> printf_stmt .)
    STRING          reduce using rule 38 (stmt -> printf_stmt .)
    FLOAT_LIT       reduce using rule 38 (stmt -> printf_stmt .)
    INT_LIT         reduce using rule 38 (stmt -> printf_stmt .)
    BOOL_LIT        reduce using rule 38 (stmt -> printf_stmt .)
    IDENT           reduce using rule 38 (stmt -> printf_stmt .)
    (               reduce using rule 38 (stmt -> printf_stmt .)
    +               reduce using rule 38 (stmt -> printf_stmt .)
    -               reduce using rule 38 (stmt -> printf_stmt .)
    !               reduce using rule 38 (stmt -> printf_stmt .)
    SUPER           reduce using rule 38 (stmt -> printf_stmt .)
    THIS            reduce using rule 38 (stmt -> printf_stmt .)
    ELSE            reduce using rule 38 (stmt -> printf_stmt .)


state 57

    (39) stmt -> for_stmt .
    }               reduce using rule 39 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 39 (stmt -> for_stmt .)
    SCANF           reduce using rule 39 (stmt -> for_stmt .)
    PRINTF          reduce using rule 39 (stmt -> for_stmt .)
    FOR             reduce using rule 39 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> for_stmt .)
    BREAK           reduce using rule 39 (stmt -> for_stmt .)
    RETURN          reduce using rule 39 (stmt -> for_stmt .)
    WHILE           reduce using rule 39 (stmt -> for_stmt .)
    IF              reduce using rule 39 (stmt -> for_stmt .)
    {               reduce using rule 39 (stmt -> for_stmt .)
    ;               reduce using rule 39 (stmt -> for_stmt .)
    MINUSMINUS      reduce using rule 39 (stmt -> for_stmt .)
    PLUSPLUS        reduce using rule 39 (stmt -> for_stmt .)
    NEW             reduce using rule 39 (stmt -> for_stmt .)
    STRING          reduce using rule 39 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 39 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 39 (stmt -> for_stmt .)
    IDENT           reduce using rule 39 (stmt -> for_stmt .)
    (               reduce using rule 39 (stmt -> for_stmt .)
    +               reduce using rule 39 (stmt -> for_stmt .)
    -               reduce using rule 39 (stmt -> for_stmt .)
    !               reduce using rule 39 (stmt -> for_stmt .)
    SUPER           reduce using rule 39 (stmt -> for_stmt .)
    THIS            reduce using rule 39 (stmt -> for_stmt .)
    ELSE            reduce using rule 39 (stmt -> for_stmt .)


state 58

    (40) stmt -> break_stmt .
    }               reduce using rule 40 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 40 (stmt -> break_stmt .)
    SCANF           reduce using rule 40 (stmt -> break_stmt .)
    PRINTF          reduce using rule 40 (stmt -> break_stmt .)
    FOR             reduce using rule 40 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> break_stmt .)
    BREAK           reduce using rule 40 (stmt -> break_stmt .)
    RETURN          reduce using rule 40 (stmt -> break_stmt .)
    WHILE           reduce using rule 40 (stmt -> break_stmt .)
    IF              reduce using rule 40 (stmt -> break_stmt .)
    {               reduce using rule 40 (stmt -> break_stmt .)
    ;               reduce using rule 40 (stmt -> break_stmt .)
    MINUSMINUS      reduce using rule 40 (stmt -> break_stmt .)
    PLUSPLUS        reduce using rule 40 (stmt -> break_stmt .)
    NEW             reduce using rule 40 (stmt -> break_stmt .)
    STRING          reduce using rule 40 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 40 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 40 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 40 (stmt -> break_stmt .)
    IDENT           reduce using rule 40 (stmt -> break_stmt .)
    (               reduce using rule 40 (stmt -> break_stmt .)
    +               reduce using rule 40 (stmt -> break_stmt .)
    -               reduce using rule 40 (stmt -> break_stmt .)
    !               reduce using rule 40 (stmt -> break_stmt .)
    SUPER           reduce using rule 40 (stmt -> break_stmt .)
    THIS            reduce using rule 40 (stmt -> break_stmt .)
    ELSE            reduce using rule 40 (stmt -> break_stmt .)


state 59

    (41) stmt -> return_stmt .
    }               reduce using rule 41 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 41 (stmt -> return_stmt .)
    SCANF           reduce using rule 41 (stmt -> return_stmt .)
    PRINTF          reduce using rule 41 (stmt -> return_stmt .)
    FOR             reduce using rule 41 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> return_stmt .)
    BREAK           reduce using rule 41 (stmt -> return_stmt .)
    RETURN          reduce using rule 41 (stmt -> return_stmt .)
    WHILE           reduce using rule 41 (stmt -> return_stmt .)
    IF              reduce using rule 41 (stmt -> return_stmt .)
    {               reduce using rule 41 (stmt -> return_stmt .)
    ;               reduce using rule 41 (stmt -> return_stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> return_stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> return_stmt .)
    NEW             reduce using rule 41 (stmt -> return_stmt .)
    STRING          reduce using rule 41 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 41 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 41 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 41 (stmt -> return_stmt .)
    IDENT           reduce using rule 41 (stmt -> return_stmt .)
    (               reduce using rule 41 (stmt -> return_stmt .)
    +               reduce using rule 41 (stmt -> return_stmt .)
    -               reduce using rule 41 (stmt -> return_stmt .)
    !               reduce using rule 41 (stmt -> return_stmt .)
    SUPER           reduce using rule 41 (stmt -> return_stmt .)
    THIS            reduce using rule 41 (stmt -> return_stmt .)
    ELSE            reduce using rule 41 (stmt -> return_stmt .)


state 60

    (42) stmt -> while_stmt .
    }               reduce using rule 42 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 42 (stmt -> while_stmt .)
    SCANF           reduce using rule 42 (stmt -> while_stmt .)
    PRINTF          reduce using rule 42 (stmt -> while_stmt .)
    FOR             reduce using rule 42 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> while_stmt .)
    BREAK           reduce using rule 42 (stmt -> while_stmt .)
    RETURN          reduce using rule 42 (stmt -> while_stmt .)
    WHILE           reduce using rule 42 (stmt -> while_stmt .)
    IF              reduce using rule 42 (stmt -> while_stmt .)
    {               reduce using rule 42 (stmt -> while_stmt .)
    ;               reduce using rule 42 (stmt -> while_stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> while_stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> while_stmt .)
    NEW             reduce using rule 42 (stmt -> while_stmt .)
    STRING          reduce using rule 42 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 42 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 42 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 42 (stmt -> while_stmt .)
    IDENT           reduce using rule 42 (stmt -> while_stmt .)
    (               reduce using rule 42 (stmt -> while_stmt .)
    +               reduce using rule 42 (stmt -> while_stmt .)
    -               reduce using rule 42 (stmt -> while_stmt .)
    !               reduce using rule 42 (stmt -> while_stmt .)
    SUPER           reduce using rule 42 (stmt -> while_stmt .)
    THIS            reduce using rule 42 (stmt -> while_stmt .)
    ELSE            reduce using rule 42 (stmt -> while_stmt .)


state 61

    (43) stmt -> if_stmt .
    }               reduce using rule 43 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 43 (stmt -> if_stmt .)
    SCANF           reduce using rule 43 (stmt -> if_stmt .)
    PRINTF          reduce using rule 43 (stmt -> if_stmt .)
    FOR             reduce using rule 43 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> if_stmt .)
    BREAK           reduce using rule 43 (stmt -> if_stmt .)
    RETURN          reduce using rule 43 (stmt -> if_stmt .)
    WHILE           reduce using rule 43 (stmt -> if_stmt .)
    IF              reduce using rule 43 (stmt -> if_stmt .)
    {               reduce using rule 43 (stmt -> if_stmt .)
    ;               reduce using rule 43 (stmt -> if_stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> if_stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> if_stmt .)
    NEW             reduce using rule 43 (stmt -> if_stmt .)
    STRING          reduce using rule 43 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 43 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 43 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 43 (stmt -> if_stmt .)
    IDENT           reduce using rule 43 (stmt -> if_stmt .)
    (               reduce using rule 43 (stmt -> if_stmt .)
    +               reduce using rule 43 (stmt -> if_stmt .)
    -               reduce using rule 43 (stmt -> if_stmt .)
    !               reduce using rule 43 (stmt -> if_stmt .)
    SUPER           reduce using rule 43 (stmt -> if_stmt .)
    THIS            reduce using rule 43 (stmt -> if_stmt .)
    ELSE            reduce using rule 43 (stmt -> if_stmt .)


state 62

    (44) stmt -> compound_stmt .
    }               reduce using rule 44 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 44 (stmt -> compound_stmt .)
    SCANF           reduce using rule 44 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 44 (stmt -> compound_stmt .)
    FOR             reduce using rule 44 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 44 (stmt -> compound_stmt .)
    BREAK           reduce using rule 44 (stmt -> compound_stmt .)
    RETURN          reduce using rule 44 (stmt -> compound_stmt .)
    WHILE           reduce using rule 44 (stmt -> compound_stmt .)
    IF              reduce using rule 44 (stmt -> compound_stmt .)
    {               reduce using rule 44 (stmt -> compound_stmt .)
    ;               reduce using rule 44 (stmt -> compound_stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> compound_stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> compound_stmt .)
    NEW             reduce using rule 44 (stmt -> compound_stmt .)
    STRING          reduce using rule 44 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 44 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 44 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 44 (stmt -> compound_stmt .)
    IDENT           reduce using rule 44 (stmt -> compound_stmt .)
    (               reduce using rule 44 (stmt -> compound_stmt .)
    +               reduce using rule 44 (stmt -> compound_stmt .)
    -               reduce using rule 44 (stmt -> compound_stmt .)
    !               reduce using rule 44 (stmt -> compound_stmt .)
    SUPER           reduce using rule 44 (stmt -> compound_stmt .)
    THIS            reduce using rule 44 (stmt -> compound_stmt .)
    ELSE            reduce using rule 44 (stmt -> compound_stmt .)


state 63

    (45) stmt -> expr_stmt .
    }               reduce using rule 45 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 45 (stmt -> expr_stmt .)
    SCANF           reduce using rule 45 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 45 (stmt -> expr_stmt .)
    FOR             reduce using rule 45 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> expr_stmt .)
    BREAK           reduce using rule 45 (stmt -> expr_stmt .)
    RETURN          reduce using rule 45 (stmt -> expr_stmt .)
    WHILE           reduce using rule 45 (stmt -> expr_stmt .)
    IF              reduce using rule 45 (stmt -> expr_stmt .)
    {               reduce using rule 45 (stmt -> expr_stmt .)
    ;               reduce using rule 45 (stmt -> expr_stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> expr_stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> expr_stmt .)
    NEW             reduce using rule 45 (stmt -> expr_stmt .)
    STRING          reduce using rule 45 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 45 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 45 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 45 (stmt -> expr_stmt .)
    IDENT           reduce using rule 45 (stmt -> expr_stmt .)
    (               reduce using rule 45 (stmt -> expr_stmt .)
    +               reduce using rule 45 (stmt -> expr_stmt .)
    -               reduce using rule 45 (stmt -> expr_stmt .)
    !               reduce using rule 45 (stmt -> expr_stmt .)
    SUPER           reduce using rule 45 (stmt -> expr_stmt .)
    THIS            reduce using rule 45 (stmt -> expr_stmt .)
    ELSE            reduce using rule 45 (stmt -> expr_stmt .)


state 64

    (103) sprintf_stmt -> SPRINTF . ( IDENT , STRING , arg_list ) ;
    (               shift and go to state 94


state 65

    (73) expr -> ( . expr )
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 95

state 66

    (69) expr -> IDENT . . SIZE ;
    (70) expr -> IDENT . ( args )
    (71) expr -> IDENT . [ expr ]
    (72) expr -> IDENT .
    (94) expr -> IDENT . [ expr ] = expr
    (95) expr -> IDENT . = expr
    .               shift and go to state 96
    (               shift and go to state 97
    [               shift and go to state 98
    ;               reduce using rule 72 (expr -> IDENT .)
    DIVEQ           reduce using rule 72 (expr -> IDENT .)
    MULEQ           reduce using rule 72 (expr -> IDENT .)
    MINUSEQ         reduce using rule 72 (expr -> IDENT .)
    PLUSEQ          reduce using rule 72 (expr -> IDENT .)
    MINUSMINUS      reduce using rule 72 (expr -> IDENT .)
    PLUSPLUS        reduce using rule 72 (expr -> IDENT .)
    AND             reduce using rule 72 (expr -> IDENT .)
    OR              reduce using rule 72 (expr -> IDENT .)
    %               reduce using rule 72 (expr -> IDENT .)
    /               reduce using rule 72 (expr -> IDENT .)
    *               reduce using rule 72 (expr -> IDENT .)
    -               reduce using rule 72 (expr -> IDENT .)
    +               reduce using rule 72 (expr -> IDENT .)
    >               reduce using rule 72 (expr -> IDENT .)
    GE              reduce using rule 72 (expr -> IDENT .)
    <               reduce using rule 72 (expr -> IDENT .)
    LE              reduce using rule 72 (expr -> IDENT .)
    NE              reduce using rule 72 (expr -> IDENT .)
    EQ              reduce using rule 72 (expr -> IDENT .)
    POINT           reduce using rule 72 (expr -> IDENT .)
    )               reduce using rule 72 (expr -> IDENT .)
    ,               reduce using rule 72 (expr -> IDENT .)
    ]               reduce using rule 72 (expr -> IDENT .)
    =               shift and go to state 99


state 67

    (65) expr -> STRING .
    ;               reduce using rule 65 (expr -> STRING .)
    DIVEQ           reduce using rule 65 (expr -> STRING .)
    MULEQ           reduce using rule 65 (expr -> STRING .)
    MINUSEQ         reduce using rule 65 (expr -> STRING .)
    PLUSEQ          reduce using rule 65 (expr -> STRING .)
    MINUSMINUS      reduce using rule 65 (expr -> STRING .)
    PLUSPLUS        reduce using rule 65 (expr -> STRING .)
    AND             reduce using rule 65 (expr -> STRING .)
    OR              reduce using rule 65 (expr -> STRING .)
    %               reduce using rule 65 (expr -> STRING .)
    /               reduce using rule 65 (expr -> STRING .)
    *               reduce using rule 65 (expr -> STRING .)
    -               reduce using rule 65 (expr -> STRING .)
    +               reduce using rule 65 (expr -> STRING .)
    >               reduce using rule 65 (expr -> STRING .)
    GE              reduce using rule 65 (expr -> STRING .)
    <               reduce using rule 65 (expr -> STRING .)
    LE              reduce using rule 65 (expr -> STRING .)
    NE              reduce using rule 65 (expr -> STRING .)
    EQ              reduce using rule 65 (expr -> STRING .)
    POINT           reduce using rule 65 (expr -> STRING .)
    )               reduce using rule 65 (expr -> STRING .)
    ,               reduce using rule 65 (expr -> STRING .)
    ]               reduce using rule 65 (expr -> STRING .)


state 68

    (46) expr_stmt -> ; .
    }               reduce using rule 46 (expr_stmt -> ; .)
    SPRINTF         reduce using rule 46 (expr_stmt -> ; .)
    SCANF           reduce using rule 46 (expr_stmt -> ; .)
    PRINTF          reduce using rule 46 (expr_stmt -> ; .)
    FOR             reduce using rule 46 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 46 (expr_stmt -> ; .)
    BREAK           reduce using rule 46 (expr_stmt -> ; .)
    RETURN          reduce using rule 46 (expr_stmt -> ; .)
    WHILE           reduce using rule 46 (expr_stmt -> ; .)
    IF              reduce using rule 46 (expr_stmt -> ; .)
    {               reduce using rule 46 (expr_stmt -> ; .)
    ;               reduce using rule 46 (expr_stmt -> ; .)
    MINUSMINUS      reduce using rule 46 (expr_stmt -> ; .)
    PLUSPLUS        reduce using rule 46 (expr_stmt -> ; .)
    NEW             reduce using rule 46 (expr_stmt -> ; .)
    STRING          reduce using rule 46 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 46 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 46 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 46 (expr_stmt -> ; .)
    IDENT           reduce using rule 46 (expr_stmt -> ; .)
    (               reduce using rule 46 (expr_stmt -> ; .)
    +               reduce using rule 46 (expr_stmt -> ; .)
    -               reduce using rule 46 (expr_stmt -> ; .)
    !               reduce using rule 46 (expr_stmt -> ; .)
    SUPER           reduce using rule 46 (expr_stmt -> ; .)
    THIS            reduce using rule 46 (expr_stmt -> ; .)
    ELSE            reduce using rule 46 (expr_stmt -> ; .)


state 69

    (102) scanf_stmt -> SCANF . ( STRING , arg_list ) ;
    (               shift and go to state 100


state 70

    (100) printf_stmt -> PRINTF . ( STRING , arg_list ) ;
    (101) printf_stmt -> PRINTF . ( STRING ) ;
    (               shift and go to state 101


state 71

    (49) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 102


state 72

    (47) expr_stmt -> expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 103
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 73

    (54) break_stmt -> CONTINUE . ;
    ;               shift and go to state 124


state 74

    (55) break_stmt -> BREAK . ;
    ;               shift and go to state 125


state 75

    (52) return_stmt -> RETURN . expr ;
    (53) return_stmt -> RETURN . ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    ;               shift and go to state 127
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 126

state 76

    (48) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 128


state 77

    (50) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (51) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 129


state 78

    (60) expr -> MINUSMINUS . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 130

state 79

    (61) expr -> PLUSPLUS . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 131

state 80

    (64) expr -> NEW . type_spec [ expr ]
    (14) type_spec -> . FLOAT
    (15) type_spec -> . INT
    (16) type_spec -> . BOOL
    (17) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 132

state 81

    (66) expr -> FLOAT_LIT .
    ;               reduce using rule 66 (expr -> FLOAT_LIT .)
    DIVEQ           reduce using rule 66 (expr -> FLOAT_LIT .)
    MULEQ           reduce using rule 66 (expr -> FLOAT_LIT .)
    MINUSEQ         reduce using rule 66 (expr -> FLOAT_LIT .)
    PLUSEQ          reduce using rule 66 (expr -> FLOAT_LIT .)
    MINUSMINUS      reduce using rule 66 (expr -> FLOAT_LIT .)
    PLUSPLUS        reduce using rule 66 (expr -> FLOAT_LIT .)
    AND             reduce using rule 66 (expr -> FLOAT_LIT .)
    OR              reduce using rule 66 (expr -> FLOAT_LIT .)
    %               reduce using rule 66 (expr -> FLOAT_LIT .)
    /               reduce using rule 66 (expr -> FLOAT_LIT .)
    *               reduce using rule 66 (expr -> FLOAT_LIT .)
    -               reduce using rule 66 (expr -> FLOAT_LIT .)
    +               reduce using rule 66 (expr -> FLOAT_LIT .)
    >               reduce using rule 66 (expr -> FLOAT_LIT .)
    GE              reduce using rule 66 (expr -> FLOAT_LIT .)
    <               reduce using rule 66 (expr -> FLOAT_LIT .)
    LE              reduce using rule 66 (expr -> FLOAT_LIT .)
    NE              reduce using rule 66 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 66 (expr -> FLOAT_LIT .)
    POINT           reduce using rule 66 (expr -> FLOAT_LIT .)
    )               reduce using rule 66 (expr -> FLOAT_LIT .)
    ,               reduce using rule 66 (expr -> FLOAT_LIT .)
    ]               reduce using rule 66 (expr -> FLOAT_LIT .)


state 82

    (67) expr -> INT_LIT .
    ;               reduce using rule 67 (expr -> INT_LIT .)
    DIVEQ           reduce using rule 67 (expr -> INT_LIT .)
    MULEQ           reduce using rule 67 (expr -> INT_LIT .)
    MINUSEQ         reduce using rule 67 (expr -> INT_LIT .)
    PLUSEQ          reduce using rule 67 (expr -> INT_LIT .)
    MINUSMINUS      reduce using rule 67 (expr -> INT_LIT .)
    PLUSPLUS        reduce using rule 67 (expr -> INT_LIT .)
    AND             reduce using rule 67 (expr -> INT_LIT .)
    OR              reduce using rule 67 (expr -> INT_LIT .)
    %               reduce using rule 67 (expr -> INT_LIT .)
    /               reduce using rule 67 (expr -> INT_LIT .)
    *               reduce using rule 67 (expr -> INT_LIT .)
    -               reduce using rule 67 (expr -> INT_LIT .)
    +               reduce using rule 67 (expr -> INT_LIT .)
    >               reduce using rule 67 (expr -> INT_LIT .)
    GE              reduce using rule 67 (expr -> INT_LIT .)
    <               reduce using rule 67 (expr -> INT_LIT .)
    LE              reduce using rule 67 (expr -> INT_LIT .)
    NE              reduce using rule 67 (expr -> INT_LIT .)
    EQ              reduce using rule 67 (expr -> INT_LIT .)
    POINT           reduce using rule 67 (expr -> INT_LIT .)
    )               reduce using rule 67 (expr -> INT_LIT .)
    ,               reduce using rule 67 (expr -> INT_LIT .)
    ]               reduce using rule 67 (expr -> INT_LIT .)


state 83

    (68) expr -> BOOL_LIT .
    ;               reduce using rule 68 (expr -> BOOL_LIT .)
    DIVEQ           reduce using rule 68 (expr -> BOOL_LIT .)
    MULEQ           reduce using rule 68 (expr -> BOOL_LIT .)
    MINUSEQ         reduce using rule 68 (expr -> BOOL_LIT .)
    PLUSEQ          reduce using rule 68 (expr -> BOOL_LIT .)
    MINUSMINUS      reduce using rule 68 (expr -> BOOL_LIT .)
    PLUSPLUS        reduce using rule 68 (expr -> BOOL_LIT .)
    AND             reduce using rule 68 (expr -> BOOL_LIT .)
    OR              reduce using rule 68 (expr -> BOOL_LIT .)
    %               reduce using rule 68 (expr -> BOOL_LIT .)
    /               reduce using rule 68 (expr -> BOOL_LIT .)
    *               reduce using rule 68 (expr -> BOOL_LIT .)
    -               reduce using rule 68 (expr -> BOOL_LIT .)
    +               reduce using rule 68 (expr -> BOOL_LIT .)
    >               reduce using rule 68 (expr -> BOOL_LIT .)
    GE              reduce using rule 68 (expr -> BOOL_LIT .)
    <               reduce using rule 68 (expr -> BOOL_LIT .)
    LE              reduce using rule 68 (expr -> BOOL_LIT .)
    NE              reduce using rule 68 (expr -> BOOL_LIT .)
    EQ              reduce using rule 68 (expr -> BOOL_LIT .)
    POINT           reduce using rule 68 (expr -> BOOL_LIT .)
    )               reduce using rule 68 (expr -> BOOL_LIT .)
    ,               reduce using rule 68 (expr -> BOOL_LIT .)
    ]               reduce using rule 68 (expr -> BOOL_LIT .)


state 84

    (74) expr -> + . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 133

state 85

    (75) expr -> - . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 134

state 86

    (76) expr -> ! . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 135

state 87

    (92) expr -> SUPER . POINT IDENT ;
    POINT           shift and go to state 136


state 88

    (93) expr -> THIS .
    ;               reduce using rule 93 (expr -> THIS .)
    DIVEQ           reduce using rule 93 (expr -> THIS .)
    MULEQ           reduce using rule 93 (expr -> THIS .)
    MINUSEQ         reduce using rule 93 (expr -> THIS .)
    PLUSEQ          reduce using rule 93 (expr -> THIS .)
    MINUSMINUS      reduce using rule 93 (expr -> THIS .)
    PLUSPLUS        reduce using rule 93 (expr -> THIS .)
    AND             reduce using rule 93 (expr -> THIS .)
    OR              reduce using rule 93 (expr -> THIS .)
    %               reduce using rule 93 (expr -> THIS .)
    /               reduce using rule 93 (expr -> THIS .)
    *               reduce using rule 93 (expr -> THIS .)
    -               reduce using rule 93 (expr -> THIS .)
    +               reduce using rule 93 (expr -> THIS .)
    >               reduce using rule 93 (expr -> THIS .)
    GE              reduce using rule 93 (expr -> THIS .)
    <               reduce using rule 93 (expr -> THIS .)
    LE              reduce using rule 93 (expr -> THIS .)
    NE              reduce using rule 93 (expr -> THIS .)
    EQ              reduce using rule 93 (expr -> THIS .)
    POINT           reduce using rule 93 (expr -> THIS .)
    )               reduce using rule 93 (expr -> THIS .)
    ,               reduce using rule 93 (expr -> THIS .)
    ]               reduce using rule 93 (expr -> THIS .)


state 89

    (31) local_decl_list -> local_decl_list local_decl .
    FLOAT           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    INT             reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    BOOL            reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    VOID            reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    SPRINTF         reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    SCANF           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    PRINTF          reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    FOR             reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    CONTINUE        reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    BREAK           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    RETURN          reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    WHILE           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    IF              reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    {               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    ;               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    MINUSMINUS      reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    PLUSPLUS        reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    NEW             reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    STRING          reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    FLOAT_LIT       reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    INT_LIT         reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    BOOL_LIT        reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    IDENT           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    (               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    +               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    -               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    !               reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    SUPER           reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)
    THIS            reduce using rule 31 (local_decl_list -> local_decl_list local_decl .)


state 90

    (32) local_decl -> type_spec IDENT . [ ] ;
    (33) local_decl -> type_spec IDENT . ;
    [               shift and go to state 137
    ;               shift and go to state 138


state 91

    (11) class_member -> type_spec IDENT ( params ) compound_stmt .
    FLOAT           reduce using rule 11 (class_member -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 11 (class_member -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 11 (class_member -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 11 (class_member -> type_spec IDENT ( params ) compound_stmt .)
    }               reduce using rule 11 (class_member -> type_spec IDENT ( params ) compound_stmt .)


state 92

    (27) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    MINUSMINUS      reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    PLUSPLUS        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 27 (compound_stmt -> { local_decls stmt_list } .)


state 93

    (35) stmt_list -> stmt_list stmt .
    }               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    SPRINTF         reduce using rule 35 (stmt_list -> stmt_list stmt .)
    SCANF           reduce using rule 35 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 35 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 35 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 35 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 35 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 35 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 35 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 35 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    MINUSMINUS      reduce using rule 35 (stmt_list -> stmt_list stmt .)
    PLUSPLUS        reduce using rule 35 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 35 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 35 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 35 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 35 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 35 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 35 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 35 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 35 (stmt_list -> stmt_list stmt .)


state 94

    (103) sprintf_stmt -> SPRINTF ( . IDENT , STRING , arg_list ) ;
    IDENT           shift and go to state 139


state 95

    (73) expr -> ( expr . )
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    )               shift and go to state 140
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 96

    (69) expr -> IDENT . . SIZE ;
    SIZE            shift and go to state 141


state 97

    (70) expr -> IDENT ( . args )
    (96) args -> . empty
    (97) args -> . arg_list
    (104) empty -> .
    (98) arg_list -> . expr
    (99) arg_list -> . arg_list , expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    )               reduce using rule 104 (empty -> .)
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    args                           shift and go to state 142
    empty                          shift and go to state 143
    arg_list                       shift and go to state 144
    expr                           shift and go to state 145

state 98

    (71) expr -> IDENT [ . expr ]
    (94) expr -> IDENT [ . expr ] = expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 146

state 99

    (95) expr -> IDENT = . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 147

state 100

    (102) scanf_stmt -> SCANF ( . STRING , arg_list ) ;
    STRING          shift and go to state 148


state 101

    (100) printf_stmt -> PRINTF ( . STRING , arg_list ) ;
    (101) printf_stmt -> PRINTF ( . STRING ) ;
    STRING          shift and go to state 149


state 102

    (49) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 150

state 103

    (47) expr_stmt -> expr ; .
    }               reduce using rule 47 (expr_stmt -> expr ; .)
    SPRINTF         reduce using rule 47 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 47 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 47 (expr_stmt -> expr ; .)
    FOR             reduce using rule 47 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 47 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 47 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 47 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 47 (expr_stmt -> expr ; .)
    IF              reduce using rule 47 (expr_stmt -> expr ; .)
    {               reduce using rule 47 (expr_stmt -> expr ; .)
    ;               reduce using rule 47 (expr_stmt -> expr ; .)
    MINUSMINUS      reduce using rule 47 (expr_stmt -> expr ; .)
    PLUSPLUS        reduce using rule 47 (expr_stmt -> expr ; .)
    NEW             reduce using rule 47 (expr_stmt -> expr ; .)
    STRING          reduce using rule 47 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 47 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 47 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 47 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 47 (expr_stmt -> expr ; .)
    (               reduce using rule 47 (expr_stmt -> expr ; .)
    +               reduce using rule 47 (expr_stmt -> expr ; .)
    -               reduce using rule 47 (expr_stmt -> expr ; .)
    !               reduce using rule 47 (expr_stmt -> expr ; .)
    SUPER           reduce using rule 47 (expr_stmt -> expr ; .)
    THIS            reduce using rule 47 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 47 (expr_stmt -> expr ; .)


state 104

    (56) expr -> expr DIVEQ . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 151

state 105

    (57) expr -> expr MULEQ . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 152

state 106

    (58) expr -> expr MINUSEQ . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 153

state 107

    (59) expr -> expr PLUSEQ . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 154

state 108

    (62) expr -> expr MINUSMINUS . ;
    ;               shift and go to state 155


state 109

    (63) expr -> expr PLUSPLUS . ;
    ;               shift and go to state 156


state 110

    (77) expr -> expr AND . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 157

state 111

    (78) expr -> expr OR . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 158

state 112

    (79) expr -> expr % . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 159

state 113

    (80) expr -> expr / . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 160

state 114

    (81) expr -> expr * . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 161

state 115

    (82) expr -> expr - . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 162

state 116

    (83) expr -> expr + . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 163

state 117

    (84) expr -> expr > . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 164

state 118

    (85) expr -> expr GE . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 165

state 119

    (86) expr -> expr < . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 166

state 120

    (87) expr -> expr LE . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 167

state 121

    (88) expr -> expr NE . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 168

state 122

    (89) expr -> expr EQ . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 169

state 123

    (90) expr -> expr POINT . IDENT = expr ;
    (91) expr -> expr POINT . IDENT ;
    IDENT           shift and go to state 170


state 124

    (54) break_stmt -> CONTINUE ; .
    }               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 54 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 54 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 54 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 54 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 54 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 54 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 54 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 54 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 54 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    MINUSMINUS      reduce using rule 54 (break_stmt -> CONTINUE ; .)
    PLUSPLUS        reduce using rule 54 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 54 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 54 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 54 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 54 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 54 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 54 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 54 (break_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 54 (break_stmt -> CONTINUE ; .)
    THIS            reduce using rule 54 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 54 (break_stmt -> CONTINUE ; .)


state 125

    (55) break_stmt -> BREAK ; .
    }               reduce using rule 55 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 55 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 55 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 55 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 55 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 55 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 55 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 55 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 55 (break_stmt -> BREAK ; .)
    IF              reduce using rule 55 (break_stmt -> BREAK ; .)
    {               reduce using rule 55 (break_stmt -> BREAK ; .)
    ;               reduce using rule 55 (break_stmt -> BREAK ; .)
    MINUSMINUS      reduce using rule 55 (break_stmt -> BREAK ; .)
    PLUSPLUS        reduce using rule 55 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 55 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 55 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 55 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 55 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 55 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 55 (break_stmt -> BREAK ; .)
    (               reduce using rule 55 (break_stmt -> BREAK ; .)
    +               reduce using rule 55 (break_stmt -> BREAK ; .)
    -               reduce using rule 55 (break_stmt -> BREAK ; .)
    !               reduce using rule 55 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 55 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 55 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 55 (break_stmt -> BREAK ; .)


state 126

    (52) return_stmt -> RETURN expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 171
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 127

    (53) return_stmt -> RETURN ; .
    }               reduce using rule 53 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 53 (return_stmt -> RETURN ; .)
    SCANF           reduce using rule 53 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 53 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 53 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 53 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 53 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 53 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 53 (return_stmt -> RETURN ; .)
    IF              reduce using rule 53 (return_stmt -> RETURN ; .)
    {               reduce using rule 53 (return_stmt -> RETURN ; .)
    ;               reduce using rule 53 (return_stmt -> RETURN ; .)
    MINUSMINUS      reduce using rule 53 (return_stmt -> RETURN ; .)
    PLUSPLUS        reduce using rule 53 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 53 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 53 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 53 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 53 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 53 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 53 (return_stmt -> RETURN ; .)
    (               reduce using rule 53 (return_stmt -> RETURN ; .)
    +               reduce using rule 53 (return_stmt -> RETURN ; .)
    -               reduce using rule 53 (return_stmt -> RETURN ; .)
    !               reduce using rule 53 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 53 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 53 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 53 (return_stmt -> RETURN ; .)


state 128

    (48) while_stmt -> WHILE ( . expr ) stmt
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 172

state 129

    (50) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (51) if_stmt -> IF ( . expr ) stmt
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 173

state 130

    (60) expr -> MINUSMINUS expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 174
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 131

    (61) expr -> PLUSPLUS expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 175
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 132

    (64) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 176


state 133

    (74) expr -> + expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 74 (expr -> + expr .)
    DIVEQ           reduce using rule 74 (expr -> + expr .)
    MULEQ           reduce using rule 74 (expr -> + expr .)
    MINUSEQ         reduce using rule 74 (expr -> + expr .)
    PLUSEQ          reduce using rule 74 (expr -> + expr .)
    MINUSMINUS      reduce using rule 74 (expr -> + expr .)
    PLUSPLUS        reduce using rule 74 (expr -> + expr .)
    AND             reduce using rule 74 (expr -> + expr .)
    OR              reduce using rule 74 (expr -> + expr .)
    %               reduce using rule 74 (expr -> + expr .)
    /               reduce using rule 74 (expr -> + expr .)
    *               reduce using rule 74 (expr -> + expr .)
    -               reduce using rule 74 (expr -> + expr .)
    +               reduce using rule 74 (expr -> + expr .)
    >               reduce using rule 74 (expr -> + expr .)
    GE              reduce using rule 74 (expr -> + expr .)
    <               reduce using rule 74 (expr -> + expr .)
    LE              reduce using rule 74 (expr -> + expr .)
    NE              reduce using rule 74 (expr -> + expr .)
    EQ              reduce using rule 74 (expr -> + expr .)
    POINT           reduce using rule 74 (expr -> + expr .)
    )               reduce using rule 74 (expr -> + expr .)
    ,               reduce using rule 74 (expr -> + expr .)
    ]               reduce using rule 74 (expr -> + expr .)


state 134

    (75) expr -> - expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 75 (expr -> - expr .)
    DIVEQ           reduce using rule 75 (expr -> - expr .)
    MULEQ           reduce using rule 75 (expr -> - expr .)
    MINUSEQ         reduce using rule 75 (expr -> - expr .)
    PLUSEQ          reduce using rule 75 (expr -> - expr .)
    MINUSMINUS      reduce using rule 75 (expr -> - expr .)
    PLUSPLUS        reduce using rule 75 (expr -> - expr .)
    AND             reduce using rule 75 (expr -> - expr .)
    OR              reduce using rule 75 (expr -> - expr .)
    %               reduce using rule 75 (expr -> - expr .)
    /               reduce using rule 75 (expr -> - expr .)
    *               reduce using rule 75 (expr -> - expr .)
    -               reduce using rule 75 (expr -> - expr .)
    +               reduce using rule 75 (expr -> - expr .)
    >               reduce using rule 75 (expr -> - expr .)
    GE              reduce using rule 75 (expr -> - expr .)
    <               reduce using rule 75 (expr -> - expr .)
    LE              reduce using rule 75 (expr -> - expr .)
    NE              reduce using rule 75 (expr -> - expr .)
    EQ              reduce using rule 75 (expr -> - expr .)
    POINT           reduce using rule 75 (expr -> - expr .)
    )               reduce using rule 75 (expr -> - expr .)
    ,               reduce using rule 75 (expr -> - expr .)
    ]               reduce using rule 75 (expr -> - expr .)


state 135

    (76) expr -> ! expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 76 (expr -> ! expr .)
    DIVEQ           reduce using rule 76 (expr -> ! expr .)
    MULEQ           reduce using rule 76 (expr -> ! expr .)
    MINUSEQ         reduce using rule 76 (expr -> ! expr .)
    PLUSEQ          reduce using rule 76 (expr -> ! expr .)
    MINUSMINUS      reduce using rule 76 (expr -> ! expr .)
    PLUSPLUS        reduce using rule 76 (expr -> ! expr .)
    AND             reduce using rule 76 (expr -> ! expr .)
    OR              reduce using rule 76 (expr -> ! expr .)
    %               reduce using rule 76 (expr -> ! expr .)
    /               reduce using rule 76 (expr -> ! expr .)
    *               reduce using rule 76 (expr -> ! expr .)
    -               reduce using rule 76 (expr -> ! expr .)
    +               reduce using rule 76 (expr -> ! expr .)
    >               reduce using rule 76 (expr -> ! expr .)
    GE              reduce using rule 76 (expr -> ! expr .)
    <               reduce using rule 76 (expr -> ! expr .)
    LE              reduce using rule 76 (expr -> ! expr .)
    NE              reduce using rule 76 (expr -> ! expr .)
    EQ              reduce using rule 76 (expr -> ! expr .)
    POINT           reduce using rule 76 (expr -> ! expr .)
    )               reduce using rule 76 (expr -> ! expr .)
    ,               reduce using rule 76 (expr -> ! expr .)
    ]               reduce using rule 76 (expr -> ! expr .)


state 136

    (92) expr -> SUPER POINT . IDENT ;
    IDENT           shift and go to state 177


state 137

    (32) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 178


state 138

    (33) local_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    SCANF           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    MINUSMINUS      reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    PLUSPLUS        reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 33 (local_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 33 (local_decl -> type_spec IDENT ; .)


state 139

    (103) sprintf_stmt -> SPRINTF ( IDENT . , STRING , arg_list ) ;
    ,               shift and go to state 179


state 140

    (73) expr -> ( expr ) .
    ;               reduce using rule 73 (expr -> ( expr ) .)
    DIVEQ           reduce using rule 73 (expr -> ( expr ) .)
    MULEQ           reduce using rule 73 (expr -> ( expr ) .)
    MINUSEQ         reduce using rule 73 (expr -> ( expr ) .)
    PLUSEQ          reduce using rule 73 (expr -> ( expr ) .)
    MINUSMINUS      reduce using rule 73 (expr -> ( expr ) .)
    PLUSPLUS        reduce using rule 73 (expr -> ( expr ) .)
    AND             reduce using rule 73 (expr -> ( expr ) .)
    OR              reduce using rule 73 (expr -> ( expr ) .)
    %               reduce using rule 73 (expr -> ( expr ) .)
    /               reduce using rule 73 (expr -> ( expr ) .)
    *               reduce using rule 73 (expr -> ( expr ) .)
    -               reduce using rule 73 (expr -> ( expr ) .)
    +               reduce using rule 73 (expr -> ( expr ) .)
    >               reduce using rule 73 (expr -> ( expr ) .)
    GE              reduce using rule 73 (expr -> ( expr ) .)
    <               reduce using rule 73 (expr -> ( expr ) .)
    LE              reduce using rule 73 (expr -> ( expr ) .)
    NE              reduce using rule 73 (expr -> ( expr ) .)
    EQ              reduce using rule 73 (expr -> ( expr ) .)
    POINT           reduce using rule 73 (expr -> ( expr ) .)
    )               reduce using rule 73 (expr -> ( expr ) .)
    ,               reduce using rule 73 (expr -> ( expr ) .)
    ]               reduce using rule 73 (expr -> ( expr ) .)


state 141

    (69) expr -> IDENT . SIZE . ;
    ;               shift and go to state 180


state 142

    (70) expr -> IDENT ( args . )
    )               shift and go to state 181


state 143

    (96) args -> empty .
    )               reduce using rule 96 (args -> empty .)


state 144

    (97) args -> arg_list .
    (99) arg_list -> arg_list . , expr
    )               reduce using rule 97 (args -> arg_list .)
    ,               shift and go to state 182


state 145

    (98) arg_list -> expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ,               reduce using rule 98 (arg_list -> expr .)
    )               reduce using rule 98 (arg_list -> expr .)
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 146

    (71) expr -> IDENT [ expr . ]
    (94) expr -> IDENT [ expr . ] = expr
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ]               shift and go to state 183
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 147

    (95) expr -> IDENT = expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 95 (expr -> IDENT = expr .)
    DIVEQ           reduce using rule 95 (expr -> IDENT = expr .)
    MULEQ           reduce using rule 95 (expr -> IDENT = expr .)
    MINUSEQ         reduce using rule 95 (expr -> IDENT = expr .)
    PLUSEQ          reduce using rule 95 (expr -> IDENT = expr .)
    MINUSMINUS      reduce using rule 95 (expr -> IDENT = expr .)
    PLUSPLUS        reduce using rule 95 (expr -> IDENT = expr .)
    POINT           reduce using rule 95 (expr -> IDENT = expr .)
    )               reduce using rule 95 (expr -> IDENT = expr .)
    ,               reduce using rule 95 (expr -> IDENT = expr .)
    ]               reduce using rule 95 (expr -> IDENT = expr .)
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122


state 148

    (102) scanf_stmt -> SCANF ( STRING . , arg_list ) ;
    ,               shift and go to state 184


state 149

    (100) printf_stmt -> PRINTF ( STRING . , arg_list ) ;
    (101) printf_stmt -> PRINTF ( STRING . ) ;
    ,               shift and go to state 185
    )               shift and go to state 186


state 150

    (49) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 187
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 151

    (56) expr -> expr DIVEQ expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 188
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 152

    (57) expr -> expr MULEQ expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 189
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 153

    (58) expr -> expr MINUSEQ expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 190
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 154

    (59) expr -> expr PLUSEQ expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 191
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 155

    (62) expr -> expr MINUSMINUS ; .
    ;               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    DIVEQ           reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    MULEQ           reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    MINUSEQ         reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    PLUSEQ          reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    MINUSMINUS      reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    PLUSPLUS        reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    AND             reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    OR              reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    %               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    /               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    *               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    -               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    +               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    >               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    GE              reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    <               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    LE              reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    NE              reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    EQ              reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    POINT           reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    )               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    ,               reduce using rule 62 (expr -> expr MINUSMINUS ; .)
    ]               reduce using rule 62 (expr -> expr MINUSMINUS ; .)


state 156

    (63) expr -> expr PLUSPLUS ; .
    ;               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    DIVEQ           reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    MULEQ           reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    MINUSEQ         reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    PLUSEQ          reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    MINUSMINUS      reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    PLUSPLUS        reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    AND             reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    OR              reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    %               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    /               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    *               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    -               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    +               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    >               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    GE              reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    <               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    LE              reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    NE              reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    EQ              reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    POINT           reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    )               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    ,               reduce using rule 63 (expr -> expr PLUSPLUS ; .)
    ]               reduce using rule 63 (expr -> expr PLUSPLUS ; .)


state 157

    (77) expr -> expr AND expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 77 (expr -> expr AND expr .)
    DIVEQ           reduce using rule 77 (expr -> expr AND expr .)
    MULEQ           reduce using rule 77 (expr -> expr AND expr .)
    MINUSEQ         reduce using rule 77 (expr -> expr AND expr .)
    PLUSEQ          reduce using rule 77 (expr -> expr AND expr .)
    MINUSMINUS      reduce using rule 77 (expr -> expr AND expr .)
    PLUSPLUS        reduce using rule 77 (expr -> expr AND expr .)
    AND             reduce using rule 77 (expr -> expr AND expr .)
    OR              reduce using rule 77 (expr -> expr AND expr .)
    POINT           reduce using rule 77 (expr -> expr AND expr .)
    )               reduce using rule 77 (expr -> expr AND expr .)
    ,               reduce using rule 77 (expr -> expr AND expr .)
    ]               reduce using rule 77 (expr -> expr AND expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122


state 158

    (78) expr -> expr OR expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 78 (expr -> expr OR expr .)
    DIVEQ           reduce using rule 78 (expr -> expr OR expr .)
    MULEQ           reduce using rule 78 (expr -> expr OR expr .)
    MINUSEQ         reduce using rule 78 (expr -> expr OR expr .)
    PLUSEQ          reduce using rule 78 (expr -> expr OR expr .)
    MINUSMINUS      reduce using rule 78 (expr -> expr OR expr .)
    PLUSPLUS        reduce using rule 78 (expr -> expr OR expr .)
    OR              reduce using rule 78 (expr -> expr OR expr .)
    POINT           reduce using rule 78 (expr -> expr OR expr .)
    )               reduce using rule 78 (expr -> expr OR expr .)
    ,               reduce using rule 78 (expr -> expr OR expr .)
    ]               reduce using rule 78 (expr -> expr OR expr .)
    AND             shift and go to state 110
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122


state 159

    (79) expr -> expr % expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 79 (expr -> expr % expr .)
    DIVEQ           reduce using rule 79 (expr -> expr % expr .)
    MULEQ           reduce using rule 79 (expr -> expr % expr .)
    MINUSEQ         reduce using rule 79 (expr -> expr % expr .)
    PLUSEQ          reduce using rule 79 (expr -> expr % expr .)
    MINUSMINUS      reduce using rule 79 (expr -> expr % expr .)
    PLUSPLUS        reduce using rule 79 (expr -> expr % expr .)
    AND             reduce using rule 79 (expr -> expr % expr .)
    OR              reduce using rule 79 (expr -> expr % expr .)
    %               reduce using rule 79 (expr -> expr % expr .)
    /               reduce using rule 79 (expr -> expr % expr .)
    *               reduce using rule 79 (expr -> expr % expr .)
    -               reduce using rule 79 (expr -> expr % expr .)
    +               reduce using rule 79 (expr -> expr % expr .)
    >               reduce using rule 79 (expr -> expr % expr .)
    GE              reduce using rule 79 (expr -> expr % expr .)
    <               reduce using rule 79 (expr -> expr % expr .)
    LE              reduce using rule 79 (expr -> expr % expr .)
    NE              reduce using rule 79 (expr -> expr % expr .)
    EQ              reduce using rule 79 (expr -> expr % expr .)
    POINT           reduce using rule 79 (expr -> expr % expr .)
    )               reduce using rule 79 (expr -> expr % expr .)
    ,               reduce using rule 79 (expr -> expr % expr .)
    ]               reduce using rule 79 (expr -> expr % expr .)


state 160

    (80) expr -> expr / expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 80 (expr -> expr / expr .)
    DIVEQ           reduce using rule 80 (expr -> expr / expr .)
    MULEQ           reduce using rule 80 (expr -> expr / expr .)
    MINUSEQ         reduce using rule 80 (expr -> expr / expr .)
    PLUSEQ          reduce using rule 80 (expr -> expr / expr .)
    MINUSMINUS      reduce using rule 80 (expr -> expr / expr .)
    PLUSPLUS        reduce using rule 80 (expr -> expr / expr .)
    AND             reduce using rule 80 (expr -> expr / expr .)
    OR              reduce using rule 80 (expr -> expr / expr .)
    %               reduce using rule 80 (expr -> expr / expr .)
    /               reduce using rule 80 (expr -> expr / expr .)
    *               reduce using rule 80 (expr -> expr / expr .)
    -               reduce using rule 80 (expr -> expr / expr .)
    +               reduce using rule 80 (expr -> expr / expr .)
    >               reduce using rule 80 (expr -> expr / expr .)
    GE              reduce using rule 80 (expr -> expr / expr .)
    <               reduce using rule 80 (expr -> expr / expr .)
    LE              reduce using rule 80 (expr -> expr / expr .)
    NE              reduce using rule 80 (expr -> expr / expr .)
    EQ              reduce using rule 80 (expr -> expr / expr .)
    POINT           reduce using rule 80 (expr -> expr / expr .)
    )               reduce using rule 80 (expr -> expr / expr .)
    ,               reduce using rule 80 (expr -> expr / expr .)
    ]               reduce using rule 80 (expr -> expr / expr .)


state 161

    (81) expr -> expr * expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 81 (expr -> expr * expr .)
    DIVEQ           reduce using rule 81 (expr -> expr * expr .)
    MULEQ           reduce using rule 81 (expr -> expr * expr .)
    MINUSEQ         reduce using rule 81 (expr -> expr * expr .)
    PLUSEQ          reduce using rule 81 (expr -> expr * expr .)
    MINUSMINUS      reduce using rule 81 (expr -> expr * expr .)
    PLUSPLUS        reduce using rule 81 (expr -> expr * expr .)
    AND             reduce using rule 81 (expr -> expr * expr .)
    OR              reduce using rule 81 (expr -> expr * expr .)
    %               reduce using rule 81 (expr -> expr * expr .)
    /               reduce using rule 81 (expr -> expr * expr .)
    *               reduce using rule 81 (expr -> expr * expr .)
    -               reduce using rule 81 (expr -> expr * expr .)
    +               reduce using rule 81 (expr -> expr * expr .)
    >               reduce using rule 81 (expr -> expr * expr .)
    GE              reduce using rule 81 (expr -> expr * expr .)
    <               reduce using rule 81 (expr -> expr * expr .)
    LE              reduce using rule 81 (expr -> expr * expr .)
    NE              reduce using rule 81 (expr -> expr * expr .)
    EQ              reduce using rule 81 (expr -> expr * expr .)
    POINT           reduce using rule 81 (expr -> expr * expr .)
    )               reduce using rule 81 (expr -> expr * expr .)
    ,               reduce using rule 81 (expr -> expr * expr .)
    ]               reduce using rule 81 (expr -> expr * expr .)


state 162

    (82) expr -> expr - expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 82 (expr -> expr - expr .)
    DIVEQ           reduce using rule 82 (expr -> expr - expr .)
    MULEQ           reduce using rule 82 (expr -> expr - expr .)
    MINUSEQ         reduce using rule 82 (expr -> expr - expr .)
    PLUSEQ          reduce using rule 82 (expr -> expr - expr .)
    MINUSMINUS      reduce using rule 82 (expr -> expr - expr .)
    PLUSPLUS        reduce using rule 82 (expr -> expr - expr .)
    AND             reduce using rule 82 (expr -> expr - expr .)
    OR              reduce using rule 82 (expr -> expr - expr .)
    -               reduce using rule 82 (expr -> expr - expr .)
    +               reduce using rule 82 (expr -> expr - expr .)
    >               reduce using rule 82 (expr -> expr - expr .)
    GE              reduce using rule 82 (expr -> expr - expr .)
    <               reduce using rule 82 (expr -> expr - expr .)
    LE              reduce using rule 82 (expr -> expr - expr .)
    NE              reduce using rule 82 (expr -> expr - expr .)
    EQ              reduce using rule 82 (expr -> expr - expr .)
    POINT           reduce using rule 82 (expr -> expr - expr .)
    )               reduce using rule 82 (expr -> expr - expr .)
    ,               reduce using rule 82 (expr -> expr - expr .)
    ]               reduce using rule 82 (expr -> expr - expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114


state 163

    (83) expr -> expr + expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 83 (expr -> expr + expr .)
    DIVEQ           reduce using rule 83 (expr -> expr + expr .)
    MULEQ           reduce using rule 83 (expr -> expr + expr .)
    MINUSEQ         reduce using rule 83 (expr -> expr + expr .)
    PLUSEQ          reduce using rule 83 (expr -> expr + expr .)
    MINUSMINUS      reduce using rule 83 (expr -> expr + expr .)
    PLUSPLUS        reduce using rule 83 (expr -> expr + expr .)
    AND             reduce using rule 83 (expr -> expr + expr .)
    OR              reduce using rule 83 (expr -> expr + expr .)
    -               reduce using rule 83 (expr -> expr + expr .)
    +               reduce using rule 83 (expr -> expr + expr .)
    >               reduce using rule 83 (expr -> expr + expr .)
    GE              reduce using rule 83 (expr -> expr + expr .)
    <               reduce using rule 83 (expr -> expr + expr .)
    LE              reduce using rule 83 (expr -> expr + expr .)
    NE              reduce using rule 83 (expr -> expr + expr .)
    EQ              reduce using rule 83 (expr -> expr + expr .)
    POINT           reduce using rule 83 (expr -> expr + expr .)
    )               reduce using rule 83 (expr -> expr + expr .)
    ,               reduce using rule 83 (expr -> expr + expr .)
    ]               reduce using rule 83 (expr -> expr + expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114


state 164

    (84) expr -> expr > expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 84 (expr -> expr > expr .)
    DIVEQ           reduce using rule 84 (expr -> expr > expr .)
    MULEQ           reduce using rule 84 (expr -> expr > expr .)
    MINUSEQ         reduce using rule 84 (expr -> expr > expr .)
    PLUSEQ          reduce using rule 84 (expr -> expr > expr .)
    MINUSMINUS      reduce using rule 84 (expr -> expr > expr .)
    PLUSPLUS        reduce using rule 84 (expr -> expr > expr .)
    AND             reduce using rule 84 (expr -> expr > expr .)
    OR              reduce using rule 84 (expr -> expr > expr .)
    >               reduce using rule 84 (expr -> expr > expr .)
    GE              reduce using rule 84 (expr -> expr > expr .)
    <               reduce using rule 84 (expr -> expr > expr .)
    LE              reduce using rule 84 (expr -> expr > expr .)
    NE              reduce using rule 84 (expr -> expr > expr .)
    EQ              reduce using rule 84 (expr -> expr > expr .)
    POINT           reduce using rule 84 (expr -> expr > expr .)
    )               reduce using rule 84 (expr -> expr > expr .)
    ,               reduce using rule 84 (expr -> expr > expr .)
    ]               reduce using rule 84 (expr -> expr > expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116


state 165

    (85) expr -> expr GE expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 85 (expr -> expr GE expr .)
    DIVEQ           reduce using rule 85 (expr -> expr GE expr .)
    MULEQ           reduce using rule 85 (expr -> expr GE expr .)
    MINUSEQ         reduce using rule 85 (expr -> expr GE expr .)
    PLUSEQ          reduce using rule 85 (expr -> expr GE expr .)
    MINUSMINUS      reduce using rule 85 (expr -> expr GE expr .)
    PLUSPLUS        reduce using rule 85 (expr -> expr GE expr .)
    AND             reduce using rule 85 (expr -> expr GE expr .)
    OR              reduce using rule 85 (expr -> expr GE expr .)
    >               reduce using rule 85 (expr -> expr GE expr .)
    GE              reduce using rule 85 (expr -> expr GE expr .)
    <               reduce using rule 85 (expr -> expr GE expr .)
    LE              reduce using rule 85 (expr -> expr GE expr .)
    NE              reduce using rule 85 (expr -> expr GE expr .)
    EQ              reduce using rule 85 (expr -> expr GE expr .)
    POINT           reduce using rule 85 (expr -> expr GE expr .)
    )               reduce using rule 85 (expr -> expr GE expr .)
    ,               reduce using rule 85 (expr -> expr GE expr .)
    ]               reduce using rule 85 (expr -> expr GE expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116


state 166

    (86) expr -> expr < expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 86 (expr -> expr < expr .)
    DIVEQ           reduce using rule 86 (expr -> expr < expr .)
    MULEQ           reduce using rule 86 (expr -> expr < expr .)
    MINUSEQ         reduce using rule 86 (expr -> expr < expr .)
    PLUSEQ          reduce using rule 86 (expr -> expr < expr .)
    MINUSMINUS      reduce using rule 86 (expr -> expr < expr .)
    PLUSPLUS        reduce using rule 86 (expr -> expr < expr .)
    AND             reduce using rule 86 (expr -> expr < expr .)
    OR              reduce using rule 86 (expr -> expr < expr .)
    >               reduce using rule 86 (expr -> expr < expr .)
    GE              reduce using rule 86 (expr -> expr < expr .)
    <               reduce using rule 86 (expr -> expr < expr .)
    LE              reduce using rule 86 (expr -> expr < expr .)
    NE              reduce using rule 86 (expr -> expr < expr .)
    EQ              reduce using rule 86 (expr -> expr < expr .)
    POINT           reduce using rule 86 (expr -> expr < expr .)
    )               reduce using rule 86 (expr -> expr < expr .)
    ,               reduce using rule 86 (expr -> expr < expr .)
    ]               reduce using rule 86 (expr -> expr < expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116


state 167

    (87) expr -> expr LE expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 87 (expr -> expr LE expr .)
    DIVEQ           reduce using rule 87 (expr -> expr LE expr .)
    MULEQ           reduce using rule 87 (expr -> expr LE expr .)
    MINUSEQ         reduce using rule 87 (expr -> expr LE expr .)
    PLUSEQ          reduce using rule 87 (expr -> expr LE expr .)
    MINUSMINUS      reduce using rule 87 (expr -> expr LE expr .)
    PLUSPLUS        reduce using rule 87 (expr -> expr LE expr .)
    AND             reduce using rule 87 (expr -> expr LE expr .)
    OR              reduce using rule 87 (expr -> expr LE expr .)
    >               reduce using rule 87 (expr -> expr LE expr .)
    GE              reduce using rule 87 (expr -> expr LE expr .)
    <               reduce using rule 87 (expr -> expr LE expr .)
    LE              reduce using rule 87 (expr -> expr LE expr .)
    NE              reduce using rule 87 (expr -> expr LE expr .)
    EQ              reduce using rule 87 (expr -> expr LE expr .)
    POINT           reduce using rule 87 (expr -> expr LE expr .)
    )               reduce using rule 87 (expr -> expr LE expr .)
    ,               reduce using rule 87 (expr -> expr LE expr .)
    ]               reduce using rule 87 (expr -> expr LE expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116


state 168

    (88) expr -> expr NE expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 88 (expr -> expr NE expr .)
    DIVEQ           reduce using rule 88 (expr -> expr NE expr .)
    MULEQ           reduce using rule 88 (expr -> expr NE expr .)
    MINUSEQ         reduce using rule 88 (expr -> expr NE expr .)
    PLUSEQ          reduce using rule 88 (expr -> expr NE expr .)
    MINUSMINUS      reduce using rule 88 (expr -> expr NE expr .)
    PLUSPLUS        reduce using rule 88 (expr -> expr NE expr .)
    AND             reduce using rule 88 (expr -> expr NE expr .)
    OR              reduce using rule 88 (expr -> expr NE expr .)
    NE              reduce using rule 88 (expr -> expr NE expr .)
    EQ              reduce using rule 88 (expr -> expr NE expr .)
    POINT           reduce using rule 88 (expr -> expr NE expr .)
    )               reduce using rule 88 (expr -> expr NE expr .)
    ,               reduce using rule 88 (expr -> expr NE expr .)
    ]               reduce using rule 88 (expr -> expr NE expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120


state 169

    (89) expr -> expr EQ expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 89 (expr -> expr EQ expr .)
    DIVEQ           reduce using rule 89 (expr -> expr EQ expr .)
    MULEQ           reduce using rule 89 (expr -> expr EQ expr .)
    MINUSEQ         reduce using rule 89 (expr -> expr EQ expr .)
    PLUSEQ          reduce using rule 89 (expr -> expr EQ expr .)
    MINUSMINUS      reduce using rule 89 (expr -> expr EQ expr .)
    PLUSPLUS        reduce using rule 89 (expr -> expr EQ expr .)
    AND             reduce using rule 89 (expr -> expr EQ expr .)
    OR              reduce using rule 89 (expr -> expr EQ expr .)
    NE              reduce using rule 89 (expr -> expr EQ expr .)
    EQ              reduce using rule 89 (expr -> expr EQ expr .)
    POINT           reduce using rule 89 (expr -> expr EQ expr .)
    )               reduce using rule 89 (expr -> expr EQ expr .)
    ,               reduce using rule 89 (expr -> expr EQ expr .)
    ]               reduce using rule 89 (expr -> expr EQ expr .)
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120


state 170

    (90) expr -> expr POINT IDENT . = expr ;
    (91) expr -> expr POINT IDENT . ;
    =               shift and go to state 192
    ;               shift and go to state 193


state 171

    (52) return_stmt -> RETURN expr ; .
    }               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 52 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 52 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 52 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 52 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 52 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    MINUSMINUS      reduce using rule 52 (return_stmt -> RETURN expr ; .)
    PLUSPLUS        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 52 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 52 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 52 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 52 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 52 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 52 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 52 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 52 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 52 (return_stmt -> RETURN expr ; .)


state 172

    (48) while_stmt -> WHILE ( expr . ) stmt
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    )               shift and go to state 194
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 173

    (50) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (51) if_stmt -> IF ( expr . ) stmt
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    )               shift and go to state 195
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 174

    (60) expr -> MINUSMINUS expr ; .
    ;               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    DIVEQ           reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    MULEQ           reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    MINUSEQ         reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    PLUSEQ          reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    MINUSMINUS      reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    PLUSPLUS        reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    AND             reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    OR              reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    %               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    /               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    *               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    -               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    +               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    >               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    GE              reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    <               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    LE              reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    NE              reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    EQ              reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    POINT           reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    )               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    ,               reduce using rule 60 (expr -> MINUSMINUS expr ; .)
    ]               reduce using rule 60 (expr -> MINUSMINUS expr ; .)


state 175

    (61) expr -> PLUSPLUS expr ; .
    ;               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    DIVEQ           reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    MULEQ           reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    MINUSEQ         reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    PLUSEQ          reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    MINUSMINUS      reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    PLUSPLUS        reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    AND             reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    OR              reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    %               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    /               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    *               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    -               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    +               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    >               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    GE              reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    <               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    LE              reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    NE              reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    EQ              reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    POINT           reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    )               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    ,               reduce using rule 61 (expr -> PLUSPLUS expr ; .)
    ]               reduce using rule 61 (expr -> PLUSPLUS expr ; .)


state 176

    (64) expr -> NEW type_spec [ . expr ]
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 196

state 177

    (92) expr -> SUPER POINT IDENT . ;
    ;               shift and go to state 197


state 178

    (32) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 198


state 179

    (103) sprintf_stmt -> SPRINTF ( IDENT , . STRING , arg_list ) ;
    STRING          shift and go to state 199


state 180

    (69) expr -> IDENT . SIZE ; .
    ;               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    DIVEQ           reduce using rule 69 (expr -> IDENT . SIZE ; .)
    MULEQ           reduce using rule 69 (expr -> IDENT . SIZE ; .)
    MINUSEQ         reduce using rule 69 (expr -> IDENT . SIZE ; .)
    PLUSEQ          reduce using rule 69 (expr -> IDENT . SIZE ; .)
    MINUSMINUS      reduce using rule 69 (expr -> IDENT . SIZE ; .)
    PLUSPLUS        reduce using rule 69 (expr -> IDENT . SIZE ; .)
    AND             reduce using rule 69 (expr -> IDENT . SIZE ; .)
    OR              reduce using rule 69 (expr -> IDENT . SIZE ; .)
    %               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    /               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    *               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    -               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    +               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    >               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    GE              reduce using rule 69 (expr -> IDENT . SIZE ; .)
    <               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    LE              reduce using rule 69 (expr -> IDENT . SIZE ; .)
    NE              reduce using rule 69 (expr -> IDENT . SIZE ; .)
    EQ              reduce using rule 69 (expr -> IDENT . SIZE ; .)
    POINT           reduce using rule 69 (expr -> IDENT . SIZE ; .)
    )               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    ,               reduce using rule 69 (expr -> IDENT . SIZE ; .)
    ]               reduce using rule 69 (expr -> IDENT . SIZE ; .)


state 181

    (70) expr -> IDENT ( args ) .
    ;               reduce using rule 70 (expr -> IDENT ( args ) .)
    DIVEQ           reduce using rule 70 (expr -> IDENT ( args ) .)
    MULEQ           reduce using rule 70 (expr -> IDENT ( args ) .)
    MINUSEQ         reduce using rule 70 (expr -> IDENT ( args ) .)
    PLUSEQ          reduce using rule 70 (expr -> IDENT ( args ) .)
    MINUSMINUS      reduce using rule 70 (expr -> IDENT ( args ) .)
    PLUSPLUS        reduce using rule 70 (expr -> IDENT ( args ) .)
    AND             reduce using rule 70 (expr -> IDENT ( args ) .)
    OR              reduce using rule 70 (expr -> IDENT ( args ) .)
    %               reduce using rule 70 (expr -> IDENT ( args ) .)
    /               reduce using rule 70 (expr -> IDENT ( args ) .)
    *               reduce using rule 70 (expr -> IDENT ( args ) .)
    -               reduce using rule 70 (expr -> IDENT ( args ) .)
    +               reduce using rule 70 (expr -> IDENT ( args ) .)
    >               reduce using rule 70 (expr -> IDENT ( args ) .)
    GE              reduce using rule 70 (expr -> IDENT ( args ) .)
    <               reduce using rule 70 (expr -> IDENT ( args ) .)
    LE              reduce using rule 70 (expr -> IDENT ( args ) .)
    NE              reduce using rule 70 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 70 (expr -> IDENT ( args ) .)
    POINT           reduce using rule 70 (expr -> IDENT ( args ) .)
    )               reduce using rule 70 (expr -> IDENT ( args ) .)
    ,               reduce using rule 70 (expr -> IDENT ( args ) .)
    ]               reduce using rule 70 (expr -> IDENT ( args ) .)


state 182

    (99) arg_list -> arg_list , . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 200

state 183

    (71) expr -> IDENT [ expr ] .
    (94) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 71 (expr -> IDENT [ expr ] .)
    DIVEQ           reduce using rule 71 (expr -> IDENT [ expr ] .)
    MULEQ           reduce using rule 71 (expr -> IDENT [ expr ] .)
    MINUSEQ         reduce using rule 71 (expr -> IDENT [ expr ] .)
    PLUSEQ          reduce using rule 71 (expr -> IDENT [ expr ] .)
    MINUSMINUS      reduce using rule 71 (expr -> IDENT [ expr ] .)
    PLUSPLUS        reduce using rule 71 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 71 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 71 (expr -> IDENT [ expr ] .)
    %               reduce using rule 71 (expr -> IDENT [ expr ] .)
    /               reduce using rule 71 (expr -> IDENT [ expr ] .)
    *               reduce using rule 71 (expr -> IDENT [ expr ] .)
    -               reduce using rule 71 (expr -> IDENT [ expr ] .)
    +               reduce using rule 71 (expr -> IDENT [ expr ] .)
    >               reduce using rule 71 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 71 (expr -> IDENT [ expr ] .)
    <               reduce using rule 71 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 71 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 71 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 71 (expr -> IDENT [ expr ] .)
    POINT           reduce using rule 71 (expr -> IDENT [ expr ] .)
    )               reduce using rule 71 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 71 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 71 (expr -> IDENT [ expr ] .)
    =               shift and go to state 201


state 184

    (102) scanf_stmt -> SCANF ( STRING , . arg_list ) ;
    (98) arg_list -> . expr
    (99) arg_list -> . arg_list , expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    arg_list                       shift and go to state 202
    expr                           shift and go to state 145

state 185

    (100) printf_stmt -> PRINTF ( STRING , . arg_list ) ;
    (98) arg_list -> . expr
    (99) arg_list -> . arg_list , expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    arg_list                       shift and go to state 203
    expr                           shift and go to state 145

state 186

    (101) printf_stmt -> PRINTF ( STRING ) . ;
    ;               shift and go to state 204


state 187

    (49) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 205

state 188

    (56) expr -> expr DIVEQ expr ; .
    ;               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    DIVEQ           reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    MULEQ           reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    MINUSEQ         reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    PLUSEQ          reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    MINUSMINUS      reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    PLUSPLUS        reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    AND             reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    OR              reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    %               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    /               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    *               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    -               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    +               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    >               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    GE              reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    <               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    LE              reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    NE              reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    EQ              reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    POINT           reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    )               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    ,               reduce using rule 56 (expr -> expr DIVEQ expr ; .)
    ]               reduce using rule 56 (expr -> expr DIVEQ expr ; .)


state 189

    (57) expr -> expr MULEQ expr ; .
    ;               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    DIVEQ           reduce using rule 57 (expr -> expr MULEQ expr ; .)
    MULEQ           reduce using rule 57 (expr -> expr MULEQ expr ; .)
    MINUSEQ         reduce using rule 57 (expr -> expr MULEQ expr ; .)
    PLUSEQ          reduce using rule 57 (expr -> expr MULEQ expr ; .)
    MINUSMINUS      reduce using rule 57 (expr -> expr MULEQ expr ; .)
    PLUSPLUS        reduce using rule 57 (expr -> expr MULEQ expr ; .)
    AND             reduce using rule 57 (expr -> expr MULEQ expr ; .)
    OR              reduce using rule 57 (expr -> expr MULEQ expr ; .)
    %               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    /               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    *               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    -               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    +               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    >               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    GE              reduce using rule 57 (expr -> expr MULEQ expr ; .)
    <               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    LE              reduce using rule 57 (expr -> expr MULEQ expr ; .)
    NE              reduce using rule 57 (expr -> expr MULEQ expr ; .)
    EQ              reduce using rule 57 (expr -> expr MULEQ expr ; .)
    POINT           reduce using rule 57 (expr -> expr MULEQ expr ; .)
    )               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    ,               reduce using rule 57 (expr -> expr MULEQ expr ; .)
    ]               reduce using rule 57 (expr -> expr MULEQ expr ; .)


state 190

    (58) expr -> expr MINUSEQ expr ; .
    ;               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    DIVEQ           reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    MULEQ           reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    MINUSEQ         reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    PLUSEQ          reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    MINUSMINUS      reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    PLUSPLUS        reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    AND             reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    OR              reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    %               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    /               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    *               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    -               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    +               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    >               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    GE              reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    <               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    LE              reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    NE              reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    EQ              reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    POINT           reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    )               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    ,               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)
    ]               reduce using rule 58 (expr -> expr MINUSEQ expr ; .)


state 191

    (59) expr -> expr PLUSEQ expr ; .
    ;               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    DIVEQ           reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    MULEQ           reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    MINUSEQ         reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    PLUSEQ          reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    MINUSMINUS      reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    PLUSPLUS        reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    AND             reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    OR              reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    %               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    /               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    *               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    -               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    +               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    >               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    GE              reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    <               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    LE              reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    NE              reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    EQ              reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    POINT           reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    )               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    ,               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)
    ]               reduce using rule 59 (expr -> expr PLUSEQ expr ; .)


state 192

    (90) expr -> expr POINT IDENT = . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 206

state 193

    (91) expr -> expr POINT IDENT ; .
    ;               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    DIVEQ           reduce using rule 91 (expr -> expr POINT IDENT ; .)
    MULEQ           reduce using rule 91 (expr -> expr POINT IDENT ; .)
    MINUSEQ         reduce using rule 91 (expr -> expr POINT IDENT ; .)
    PLUSEQ          reduce using rule 91 (expr -> expr POINT IDENT ; .)
    MINUSMINUS      reduce using rule 91 (expr -> expr POINT IDENT ; .)
    PLUSPLUS        reduce using rule 91 (expr -> expr POINT IDENT ; .)
    AND             reduce using rule 91 (expr -> expr POINT IDENT ; .)
    OR              reduce using rule 91 (expr -> expr POINT IDENT ; .)
    %               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    /               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    *               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    -               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    +               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    >               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    GE              reduce using rule 91 (expr -> expr POINT IDENT ; .)
    <               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    LE              reduce using rule 91 (expr -> expr POINT IDENT ; .)
    NE              reduce using rule 91 (expr -> expr POINT IDENT ; .)
    EQ              reduce using rule 91 (expr -> expr POINT IDENT ; .)
    POINT           reduce using rule 91 (expr -> expr POINT IDENT ; .)
    )               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    ,               reduce using rule 91 (expr -> expr POINT IDENT ; .)
    ]               reduce using rule 91 (expr -> expr POINT IDENT ; .)


state 194

    (48) while_stmt -> WHILE ( expr ) . stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 72
    stmt                           shift and go to state 207
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63

state 195

    (50) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (51) if_stmt -> IF ( expr ) . stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 72
    stmt                           shift and go to state 208
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63

state 196

    (64) expr -> NEW type_spec [ expr . ]
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ]               shift and go to state 209
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 197

    (92) expr -> SUPER POINT IDENT ; .
    ;               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    DIVEQ           reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    MULEQ           reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    MINUSEQ         reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    PLUSEQ          reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    MINUSMINUS      reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    PLUSPLUS        reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    AND             reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    OR              reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    %               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    /               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    *               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    -               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    +               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    >               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    GE              reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    <               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    LE              reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    NE              reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    EQ              reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    POINT           reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    )               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    ,               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)
    ]               reduce using rule 92 (expr -> SUPER POINT IDENT ; .)


state 198

    (32) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    SPRINTF         reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    SCANF           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    PRINTF          reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    MINUSMINUS      reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    PLUSPLUS        reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    SUPER           reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)
    THIS            reduce using rule 32 (local_decl -> type_spec IDENT [ ] ; .)


state 199

    (103) sprintf_stmt -> SPRINTF ( IDENT , STRING . , arg_list ) ;
    ,               shift and go to state 210


state 200

    (99) arg_list -> arg_list , expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ,               reduce using rule 99 (arg_list -> arg_list , expr .)
    )               reduce using rule 99 (arg_list -> arg_list , expr .)
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 201

    (94) expr -> IDENT [ expr ] = . expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 211

state 202

    (102) scanf_stmt -> SCANF ( STRING , arg_list . ) ;
    (99) arg_list -> arg_list . , expr
    )               shift and go to state 212
    ,               shift and go to state 182


state 203

    (100) printf_stmt -> PRINTF ( STRING , arg_list . ) ;
    (99) arg_list -> arg_list . , expr
    )               shift and go to state 213
    ,               shift and go to state 182


state 204

    (101) printf_stmt -> PRINTF ( STRING ) ; .
    }               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    SPRINTF         reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    SCANF           reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    CONTINUE        reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    BREAK           reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    WHILE           reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    {               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    ;               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    MINUSMINUS      reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    PLUSPLUS        reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    NEW             reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    STRING          reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    FLOAT_LIT       reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    INT_LIT         reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    BOOL_LIT        reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    IDENT           reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    (               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    +               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    -               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    !               reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    SUPER           reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    THIS            reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)
    ELSE            reduce using rule 101 (printf_stmt -> PRINTF ( STRING ) ; .)


state 205

    (49) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 214
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 206

    (90) expr -> expr POINT IDENT = expr . ;
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               shift and go to state 215
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 207

    (48) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    MINUSMINUS      reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    PLUSPLUS        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 48 (while_stmt -> WHILE ( expr ) stmt .)


state 208

    (50) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (51) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 216
    }               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    MINUSMINUS      reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    PLUSPLUS        reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 51 (if_stmt -> IF ( expr ) stmt .)


state 209

    (64) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    DIVEQ           reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    MULEQ           reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    MINUSEQ         reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    PLUSEQ          reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    MINUSMINUS      reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    PLUSPLUS        reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    POINT           reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 64 (expr -> NEW type_spec [ expr ] .)


state 210

    (103) sprintf_stmt -> SPRINTF ( IDENT , STRING , . arg_list ) ;
    (98) arg_list -> . expr
    (99) arg_list -> . arg_list , expr
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    arg_list                       shift and go to state 217
    expr                           shift and go to state 145

state 211

    (94) expr -> IDENT [ expr ] = expr .
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    ;               reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    DIVEQ           reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    MULEQ           reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    MINUSEQ         reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    PLUSEQ          reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    MINUSMINUS      reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    PLUSPLUS        reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    POINT           reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 94 (expr -> IDENT [ expr ] = expr .)
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122


state 212

    (102) scanf_stmt -> SCANF ( STRING , arg_list ) . ;
    ;               shift and go to state 218


state 213

    (100) printf_stmt -> PRINTF ( STRING , arg_list ) . ;
    ;               shift and go to state 219


state 214

    (49) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 220

state 215

    (90) expr -> expr POINT IDENT = expr ; .
    ;               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    DIVEQ           reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    MULEQ           reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    MINUSEQ         reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    PLUSEQ          reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    MINUSMINUS      reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    PLUSPLUS        reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    AND             reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    OR              reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    %               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    /               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    *               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    -               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    +               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    >               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    GE              reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    <               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    LE              reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    NE              reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    EQ              reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    POINT           reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    )               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    ,               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)
    ]               reduce using rule 90 (expr -> expr POINT IDENT = expr ; .)


state 216

    (50) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 72
    stmt                           shift and go to state 221
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63

state 217

    (103) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list . ) ;
    (99) arg_list -> arg_list . , expr
    )               shift and go to state 222
    ,               shift and go to state 182


state 218

    (102) scanf_stmt -> SCANF ( STRING , arg_list ) ; .
    }               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IF              reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    {               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ;               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    (               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    +               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    -               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    !               reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 102 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)


state 219

    (100) printf_stmt -> PRINTF ( STRING , arg_list ) ; .
    }               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IF              reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    {               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ;               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    (               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    +               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    -               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    !               reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 100 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)


state 220

    (49) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (56) expr -> expr . DIVEQ expr ;
    (57) expr -> expr . MULEQ expr ;
    (58) expr -> expr . MINUSEQ expr ;
    (59) expr -> expr . PLUSEQ expr ;
    (62) expr -> expr . MINUSMINUS ;
    (63) expr -> expr . PLUSPLUS ;
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    (79) expr -> expr . % expr
    (80) expr -> expr . / expr
    (81) expr -> expr . * expr
    (82) expr -> expr . - expr
    (83) expr -> expr . + expr
    (84) expr -> expr . > expr
    (85) expr -> expr . GE expr
    (86) expr -> expr . < expr
    (87) expr -> expr . LE expr
    (88) expr -> expr . NE expr
    (89) expr -> expr . EQ expr
    (90) expr -> expr . POINT IDENT = expr ;
    (91) expr -> expr . POINT IDENT ;
    )               shift and go to state 223
    DIVEQ           shift and go to state 104
    MULEQ           shift and go to state 105
    MINUSEQ         shift and go to state 106
    PLUSEQ          shift and go to state 107
    MINUSMINUS      shift and go to state 108
    PLUSPLUS        shift and go to state 109
    AND             shift and go to state 110
    OR              shift and go to state 111
    %               shift and go to state 112
    /               shift and go to state 113
    *               shift and go to state 114
    -               shift and go to state 115
    +               shift and go to state 116
    >               shift and go to state 117
    GE              shift and go to state 118
    <               shift and go to state 119
    LE              shift and go to state 120
    NE              shift and go to state 121
    EQ              shift and go to state 122
    POINT           shift and go to state 123


state 221

    (50) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 50 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 222

    (103) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) . ;
    ;               shift and go to state 224


state 223

    (49) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (36) stmt -> . sprintf_stmt
    (37) stmt -> . scanf_stmt
    (38) stmt -> . printf_stmt
    (39) stmt -> . for_stmt
    (40) stmt -> . break_stmt
    (41) stmt -> . return_stmt
    (42) stmt -> . while_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . compound_stmt
    (45) stmt -> . expr_stmt
    (103) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (102) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (100) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (101) printf_stmt -> . PRINTF ( STRING ) ;
    (49) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (54) break_stmt -> . CONTINUE ;
    (55) break_stmt -> . BREAK ;
    (52) return_stmt -> . RETURN expr ;
    (53) return_stmt -> . RETURN ;
    (48) while_stmt -> . WHILE ( expr ) stmt
    (50) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (51) if_stmt -> . IF ( expr ) stmt
    (27) compound_stmt -> . { local_decls stmt_list }
    (46) expr_stmt -> . ;
    (47) expr_stmt -> . expr ;
    (56) expr -> . expr DIVEQ expr ;
    (57) expr -> . expr MULEQ expr ;
    (58) expr -> . expr MINUSEQ expr ;
    (59) expr -> . expr PLUSEQ expr ;
    (60) expr -> . MINUSMINUS expr ;
    (61) expr -> . PLUSPLUS expr ;
    (62) expr -> . expr MINUSMINUS ;
    (63) expr -> . expr PLUSPLUS ;
    (64) expr -> . NEW type_spec [ expr ]
    (65) expr -> . STRING
    (66) expr -> . FLOAT_LIT
    (67) expr -> . INT_LIT
    (68) expr -> . BOOL_LIT
    (69) expr -> . IDENT . SIZE ;
    (70) expr -> . IDENT ( args )
    (71) expr -> . IDENT [ expr ]
    (72) expr -> . IDENT
    (73) expr -> . ( expr )
    (74) expr -> . + expr
    (75) expr -> . - expr
    (76) expr -> . ! expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . expr % expr
    (80) expr -> . expr / expr
    (81) expr -> . expr * expr
    (82) expr -> . expr - expr
    (83) expr -> . expr + expr
    (84) expr -> . expr > expr
    (85) expr -> . expr GE expr
    (86) expr -> . expr < expr
    (87) expr -> . expr LE expr
    (88) expr -> . expr NE expr
    (89) expr -> . expr EQ expr
    (90) expr -> . expr POINT IDENT = expr ;
    (91) expr -> . expr POINT IDENT ;
    (92) expr -> . SUPER POINT IDENT ;
    (93) expr -> . THIS
    (94) expr -> . IDENT [ expr ] = expr
    (95) expr -> . IDENT = expr
    SPRINTF         shift and go to state 64
    SCANF           shift and go to state 69
    PRINTF          shift and go to state 70
    FOR             shift and go to state 71
    CONTINUE        shift and go to state 73
    BREAK           shift and go to state 74
    RETURN          shift and go to state 75
    WHILE           shift and go to state 76
    IF              shift and go to state 77
    {               shift and go to state 42
    ;               shift and go to state 68
    MINUSMINUS      shift and go to state 78
    PLUSPLUS        shift and go to state 79
    NEW             shift and go to state 80
    STRING          shift and go to state 67
    FLOAT_LIT       shift and go to state 81
    INT_LIT         shift and go to state 82
    BOOL_LIT        shift and go to state 83
    IDENT           shift and go to state 66
    (               shift and go to state 65
    +               shift and go to state 84
    -               shift and go to state 85
    !               shift and go to state 86
    SUPER           shift and go to state 87
    THIS            shift and go to state 88

    expr                           shift and go to state 72
    stmt                           shift and go to state 225
    sprintf_stmt                   shift and go to state 54
    scanf_stmt                     shift and go to state 55
    printf_stmt                    shift and go to state 56
    for_stmt                       shift and go to state 57
    break_stmt                     shift and go to state 58
    return_stmt                    shift and go to state 59
    while_stmt                     shift and go to state 60
    if_stmt                        shift and go to state 61
    compound_stmt                  shift and go to state 62
    expr_stmt                      shift and go to state 63

state 224

    (103) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .
    }               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SCANF           reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PRINTF          reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FOR             reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BREAK           reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    RETURN          reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    WHILE           reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IF              reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    {               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ;               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    NEW             reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    STRING          reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IDENT           reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    (               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    +               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    -               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    !               reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SUPER           reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    THIS            reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ELSE            reduce using rule 103 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)


state 225

    (49) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    }               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SPRINTF         reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CONTINUE        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING          reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SUPER           reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    THIS            reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 49 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
