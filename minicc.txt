Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     class_decl -> CLASS IDENT sclass_opt { class_body } ;
Rule 8     sclass_opt -> : IDENT
Rule 9     sclass_opt -> empty
Rule 10    class_body -> class_member_list
Rule 11    class_member_list -> class_member
Rule 12    class_member_list -> class_member_list class_member
Rule 13    class_member -> method_decl
Rule 14    method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt
Rule 15    _1_params_optional -> params
Rule 16    _1_params_optional -> <empty>
Rule 17    var_decl -> type_spec IDENT [ ] ;
Rule 18    var_decl -> type_spec IDENT _2_0x3d_expr_optional ;
Rule 19    _2_0x3d_expr_optional -> = expr  [precedence=right, level=10]
Rule 20    _2_0x3d_expr_optional -> <empty>
Rule 21    type_spec -> FLOAT
Rule 22    type_spec -> INT
Rule 23    type_spec -> BOOL
Rule 24    type_spec -> VOID
Rule 25    func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt
Rule 26    _3_params_optional -> params
Rule 27    _3_params_optional -> <empty>
Rule 28    params -> VOID
Rule 29    params -> param_list
Rule 30    param_list -> param
Rule 31    param_list -> param_list , param
Rule 32    param -> type_spec IDENT [ ]
Rule 33    param -> type_spec IDENT
Rule 34    compound_stmt -> { local_decls stmt_list }
Rule 35    local_decls -> empty
Rule 36    local_decls -> local_decl_list
Rule 37    local_decl_list -> local_decl
Rule 38    local_decl_list -> local_decl_list local_decl
Rule 39    local_decl -> type_spec IDENT [ ] ;
Rule 40    local_decl -> type_spec IDENT _4_0x3d_expr_optional ;
Rule 41    _4_0x3d_expr_optional -> = expr  [precedence=right, level=10]
Rule 42    _4_0x3d_expr_optional -> <empty>
Rule 43    stmt_list -> stmt
Rule 44    stmt_list -> stmt_list stmt
Rule 45    stmt -> sprintf_stmt
Rule 46    stmt -> scanf_stmt
Rule 47    stmt -> printf_stmt
Rule 48    stmt -> for_stmt
Rule 49    stmt -> break_stmt
Rule 50    stmt -> return_stmt
Rule 51    stmt -> while_stmt
Rule 52    stmt -> if_stmt
Rule 53    stmt -> compound_stmt
Rule 54    stmt -> expr_stmt
Rule 55    expr_stmt -> ;
Rule 56    expr_stmt -> expr ;
Rule 57    while_stmt -> WHILE ( expr ) stmt
Rule 58    for_stmt -> FOR ( local_decl expr ; expr ) stmt
Rule 59    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 60    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=5]
Rule 61    if_stmt -> IF ( expr ) stmt  [precedence=right, level=4]
Rule 62    return_stmt -> RETURN expr ;
Rule 63    return_stmt -> RETURN ;
Rule 64    break_stmt -> CONTINUE ;
Rule 65    break_stmt -> BREAK ;
Rule 66    expr -> IDENT DIVEQ expr  [precedence=right, level=9]
Rule 67    expr -> IDENT MULEQ expr  [precedence=right, level=8]
Rule 68    expr -> IDENT MINUSEQ expr  [precedence=right, level=7]
Rule 69    expr -> IDENT PLUSEQ expr  [precedence=right, level=6]
Rule 70    expr -> MINUSMINUS expr  [precedence=left, level=2]
Rule 71    expr -> PLUSPLUS expr  [precedence=left, level=1]
Rule 72    expr -> expr MINUSMINUS  [precedence=left, level=2]
Rule 73    expr -> expr PLUSPLUS  [precedence=left, level=1]
Rule 74    expr -> NEW type_spec [ expr ]
Rule 75    expr -> STRING
Rule 76    expr -> FLOAT_LIT
Rule 77    expr -> INT_LIT
Rule 78    expr -> BOOL_LIT
Rule 79    expr -> CAST type_spec ( expr )
Rule 80    expr -> INTTOFLOAT ( IDENT )
Rule 81    expr -> IDENT . SIZE
Rule 82    expr -> IDENT ( args )
Rule 83    expr -> IDENT [ expr ]
Rule 84    expr -> IDENT
Rule 85    expr -> ( expr )
Rule 86    expr -> + expr  [precedence=right, level=17]
Rule 87    expr -> - expr  [precedence=right, level=17]
Rule 88    expr -> ! expr  [precedence=right, level=17]
Rule 89    expr -> expr AND expr  [precedence=left, level=12]
Rule 90    expr -> expr OR expr  [precedence=left, level=11]
Rule 91    expr -> expr % expr  [precedence=left, level=16]
Rule 92    expr -> expr / expr  [precedence=left, level=16]
Rule 93    expr -> expr * expr  [precedence=left, level=16]
Rule 94    expr -> expr - expr  [precedence=left, level=15]
Rule 95    expr -> expr + expr  [precedence=left, level=15]
Rule 96    expr -> expr > expr  [precedence=left, level=14]
Rule 97    expr -> expr GE expr  [precedence=left, level=14]
Rule 98    expr -> expr < expr  [precedence=left, level=14]
Rule 99    expr -> expr LE expr  [precedence=left, level=14]
Rule 100   expr -> expr NE expr  [precedence=left, level=13]
Rule 101   expr -> expr EQ expr  [precedence=left, level=13]
Rule 102   expr -> expr POINT IDENT = expr  [precedence=right, level=10]
Rule 103   expr -> expr POINT IDENT
Rule 104   expr -> SUPER POINT IDENT
Rule 105   expr -> THIS
Rule 106   expr -> IDENT [ expr ] = expr  [precedence=right, level=10]
Rule 107   expr -> IDENT = expr  [precedence=right, level=10]
Rule 108   args -> empty
Rule 109   args -> arg_list
Rule 110   arg_list -> expr
Rule 111   arg_list -> arg_list , expr
Rule 112   printf_stmt -> PRINTF ( STRING , arg_list ) ;
Rule 113   printf_stmt -> PRINTF ( STRING ) ;
Rule 114   scanf_stmt -> SCANF ( STRING , arg_list ) ;
Rule 115   sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ;
Rule 116   empty -> <empty>

Terminals, with rules where they appear:

!                    : 88
%                    : 91
(                    : 14 25 57 58 59 60 61 79 80 82 85 112 113 114 115
)                    : 14 25 57 58 59 60 61 79 80 82 85 112 113 114 115
*                    : 93
+                    : 86 95
,                    : 31 111 112 114 115 115
-                    : 87 94
.                    : 81
/                    : 92
:                    : 8
;                    : 7 17 18 39 40 55 56 58 59 59 62 63 64 65 112 113 114 115
<                    : 98
=                    : 19 41 102 106 107
>                    : 96
AND                  : 89
BOOL                 : 23
BOOL_LIT             : 78
BREAK                : 65
CAST                 : 79
CLASS                : 7
CONTINUE             : 64
DIVEQ                : 66
ELSE                 : 60
EQ                   : 101
FLOAT                : 21
FLOAT_LIT            : 76
FOR                  : 58 59
GE                   : 97
IDENT                : 7 8 14 17 18 25 32 33 39 40 66 67 68 69 80 81 82 83 84 102 103 104 106 107 115
IF                   : 60 61
INT                  : 22
INTTOFLOAT           : 80
INT_LIT              : 77
LE                   : 99
MINUSEQ              : 68
MINUSMINUS           : 70 72
MULEQ                : 67
NE                   : 100
NEW                  : 74
OR                   : 90
PLUSEQ               : 69
PLUSPLUS             : 71 73
POINT                : 102 103 104
PRINTF               : 112 113
RETURN               : 62 63
SCANF                : 114
SIZE                 : 81
SPRINTF              : 115
STRING               : 75 112 113 114 115
SUPER                : 104
THIS                 : 105
VOID                 : 24 28
WHILE                : 57
[                    : 17 32 39 74 83 106
]                    : 17 32 39 74 83 106
error                : 
{                    : 7 34
}                    : 7 34

Nonterminals, with rules where they appear:

_1_params_optional   : 14
_2_0x3d_expr_optional : 18
_3_params_optional   : 25
_4_0x3d_expr_optional : 40
arg_list             : 109 111 112 114 115
args                 : 82
break_stmt           : 49
class_body           : 7
class_decl           : 4
class_member         : 11 12
class_member_list    : 10 12
compound_stmt        : 14 25 53
decl                 : 2 3
decl_list            : 1 3
empty                : 9 35 108
expr                 : 19 41 56 57 58 58 59 59 59 60 61 62 66 67 68 69 70 71 72 73 74 79 83 85 86 87 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 106 106 107 110 111
expr_stmt            : 54
for_stmt             : 48
func_decl            : 5
if_stmt              : 52
local_decl           : 37 38 58
local_decl_list      : 36 38
local_decls          : 34
method_decl          : 13
param                : 30 31
param_list           : 29 31
params               : 15 26
printf_stmt          : 47
program              : 0
return_stmt          : 50
scanf_stmt           : 46
sclass_opt           : 7
sprintf_stmt         : 45
stmt                 : 43 44 57 58 59 60 60 61
stmt_list            : 34 44
type_spec            : 14 17 18 25 32 33 39 40 74 79
var_decl             : 6
while_stmt           : 51


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT sclass_opt { class_body } ;
    (25) func_decl -> . type_spec IDENT ( _3_params_optional ) compound_stmt
    (17) var_decl -> . type_spec IDENT [ ] ;
    (18) var_decl -> . type_spec IDENT _2_0x3d_expr_optional ;
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT sclass_opt { class_body } ;
    (25) func_decl -> . type_spec IDENT ( _3_params_optional ) compound_stmt
    (17) var_decl -> . type_spec IDENT [ ] ;
    (18) var_decl -> . type_spec IDENT _2_0x3d_expr_optional ;
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) class_decl -> CLASS . IDENT sclass_opt { class_body } ;
    IDENT           shift and go to state 14


state 8

    (25) func_decl -> type_spec . IDENT ( _3_params_optional ) compound_stmt
    (17) var_decl -> type_spec . IDENT [ ] ;
    (18) var_decl -> type_spec . IDENT _2_0x3d_expr_optional ;
    IDENT           shift and go to state 15


state 9

    (21) type_spec -> FLOAT .
    IDENT           reduce using rule 21 (type_spec -> FLOAT .)
    [               reduce using rule 21 (type_spec -> FLOAT .)
    (               reduce using rule 21 (type_spec -> FLOAT .)


state 10

    (22) type_spec -> INT .
    IDENT           reduce using rule 22 (type_spec -> INT .)
    [               reduce using rule 22 (type_spec -> INT .)
    (               reduce using rule 22 (type_spec -> INT .)


state 11

    (23) type_spec -> BOOL .
    IDENT           reduce using rule 23 (type_spec -> BOOL .)
    [               reduce using rule 23 (type_spec -> BOOL .)
    (               reduce using rule 23 (type_spec -> BOOL .)


state 12

    (24) type_spec -> VOID .
    IDENT           reduce using rule 24 (type_spec -> VOID .)
    [               reduce using rule 24 (type_spec -> VOID .)
    (               reduce using rule 24 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (7) class_decl -> CLASS IDENT . sclass_opt { class_body } ;
    (8) sclass_opt -> . : IDENT
    (9) sclass_opt -> . empty
    (116) empty -> .
    :               shift and go to state 17
    {               reduce using rule 116 (empty -> .)

    sclass_opt                     shift and go to state 16
    empty                          shift and go to state 18

state 15

    (25) func_decl -> type_spec IDENT . ( _3_params_optional ) compound_stmt
    (17) var_decl -> type_spec IDENT . [ ] ;
    (18) var_decl -> type_spec IDENT . _2_0x3d_expr_optional ;
    (19) _2_0x3d_expr_optional -> . = expr
    (20) _2_0x3d_expr_optional -> .
    (               shift and go to state 19
    [               shift and go to state 20
    =               shift and go to state 22
    ;               reduce using rule 20 (_2_0x3d_expr_optional -> .)

    _2_0x3d_expr_optional          shift and go to state 21

state 16

    (7) class_decl -> CLASS IDENT sclass_opt . { class_body } ;
    {               shift and go to state 23


state 17

    (8) sclass_opt -> : . IDENT
    IDENT           shift and go to state 24


state 18

    (9) sclass_opt -> empty .
    {               reduce using rule 9 (sclass_opt -> empty .)


state 19

    (25) func_decl -> type_spec IDENT ( . _3_params_optional ) compound_stmt
    (26) _3_params_optional -> . params
    (27) _3_params_optional -> .
    (28) params -> . VOID
    (29) params -> . param_list
    (30) param_list -> . param
    (31) param_list -> . param_list , param
    (32) param -> . type_spec IDENT [ ]
    (33) param -> . type_spec IDENT
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    )               reduce using rule 27 (_3_params_optional -> .)
    VOID            shift and go to state 28
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 25
    _3_params_optional             shift and go to state 26
    params                         shift and go to state 27
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 20

    (17) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 31


state 21

    (18) var_decl -> type_spec IDENT _2_0x3d_expr_optional . ;
    ;               shift and go to state 32


state 22

    (19) _2_0x3d_expr_optional -> = . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 33

state 23

    (7) class_decl -> CLASS IDENT sclass_opt { . class_body } ;
    (10) class_body -> . class_member_list
    (11) class_member_list -> . class_member
    (12) class_member_list -> . class_member_list class_member
    (13) class_member -> . method_decl
    (14) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_body                     shift and go to state 50
    class_member_list              shift and go to state 51
    class_member                   shift and go to state 52
    method_decl                    shift and go to state 53
    type_spec                      shift and go to state 54

state 24

    (8) sclass_opt -> : IDENT .
    {               reduce using rule 8 (sclass_opt -> : IDENT .)


state 25

    (32) param -> type_spec . IDENT [ ]
    (33) param -> type_spec . IDENT
    IDENT           shift and go to state 55


state 26

    (25) func_decl -> type_spec IDENT ( _3_params_optional . ) compound_stmt
    )               shift and go to state 56


state 27

    (26) _3_params_optional -> params .
    )               reduce using rule 26 (_3_params_optional -> params .)


state 28

    (28) params -> VOID .
    (24) type_spec -> VOID .
    )               reduce using rule 28 (params -> VOID .)
    IDENT           reduce using rule 24 (type_spec -> VOID .)


state 29

    (29) params -> param_list .
    (31) param_list -> param_list . , param
    )               reduce using rule 29 (params -> param_list .)
    ,               shift and go to state 57


state 30

    (30) param_list -> param .
    ,               reduce using rule 30 (param_list -> param .)
    )               reduce using rule 30 (param_list -> param .)


state 31

    (17) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 58


state 32

    (18) var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .
    CLASS           reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)
    FLOAT           reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)
    INT             reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)
    BOOL            reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)
    VOID            reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)
    $end            reduce using rule 18 (var_decl -> type_spec IDENT _2_0x3d_expr_optional ; .)


state 33

    (19) _2_0x3d_expr_optional -> = expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               reduce using rule 19 (_2_0x3d_expr_optional -> = expr .)
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 34

    (66) expr -> IDENT . DIVEQ expr
    (67) expr -> IDENT . MULEQ expr
    (68) expr -> IDENT . MINUSEQ expr
    (69) expr -> IDENT . PLUSEQ expr
    (81) expr -> IDENT . . SIZE
    (82) expr -> IDENT . ( args )
    (83) expr -> IDENT . [ expr ]
    (84) expr -> IDENT .
    (106) expr -> IDENT . [ expr ] = expr
    (107) expr -> IDENT . = expr
    DIVEQ           shift and go to state 75
    MULEQ           shift and go to state 76
    MINUSEQ         shift and go to state 77
    PLUSEQ          shift and go to state 78
    .               shift and go to state 79
    (               shift and go to state 80
    [               shift and go to state 81
    MINUSMINUS      reduce using rule 84 (expr -> IDENT .)
    PLUSPLUS        reduce using rule 84 (expr -> IDENT .)
    AND             reduce using rule 84 (expr -> IDENT .)
    OR              reduce using rule 84 (expr -> IDENT .)
    %               reduce using rule 84 (expr -> IDENT .)
    /               reduce using rule 84 (expr -> IDENT .)
    *               reduce using rule 84 (expr -> IDENT .)
    -               reduce using rule 84 (expr -> IDENT .)
    +               reduce using rule 84 (expr -> IDENT .)
    >               reduce using rule 84 (expr -> IDENT .)
    GE              reduce using rule 84 (expr -> IDENT .)
    <               reduce using rule 84 (expr -> IDENT .)
    LE              reduce using rule 84 (expr -> IDENT .)
    NE              reduce using rule 84 (expr -> IDENT .)
    EQ              reduce using rule 84 (expr -> IDENT .)
    POINT           reduce using rule 84 (expr -> IDENT .)
    ;               reduce using rule 84 (expr -> IDENT .)
    )               reduce using rule 84 (expr -> IDENT .)
    ,               reduce using rule 84 (expr -> IDENT .)
    ]               reduce using rule 84 (expr -> IDENT .)
    =               shift and go to state 82


state 35

    (70) expr -> MINUSMINUS . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 83

state 36

    (71) expr -> PLUSPLUS . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 84

state 37

    (74) expr -> NEW . type_spec [ expr ]
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 85

state 38

    (75) expr -> STRING .
    MINUSMINUS      reduce using rule 75 (expr -> STRING .)
    PLUSPLUS        reduce using rule 75 (expr -> STRING .)
    AND             reduce using rule 75 (expr -> STRING .)
    OR              reduce using rule 75 (expr -> STRING .)
    %               reduce using rule 75 (expr -> STRING .)
    /               reduce using rule 75 (expr -> STRING .)
    *               reduce using rule 75 (expr -> STRING .)
    -               reduce using rule 75 (expr -> STRING .)
    +               reduce using rule 75 (expr -> STRING .)
    >               reduce using rule 75 (expr -> STRING .)
    GE              reduce using rule 75 (expr -> STRING .)
    <               reduce using rule 75 (expr -> STRING .)
    LE              reduce using rule 75 (expr -> STRING .)
    NE              reduce using rule 75 (expr -> STRING .)
    EQ              reduce using rule 75 (expr -> STRING .)
    POINT           reduce using rule 75 (expr -> STRING .)
    ;               reduce using rule 75 (expr -> STRING .)
    )               reduce using rule 75 (expr -> STRING .)
    ,               reduce using rule 75 (expr -> STRING .)
    ]               reduce using rule 75 (expr -> STRING .)


state 39

    (76) expr -> FLOAT_LIT .
    MINUSMINUS      reduce using rule 76 (expr -> FLOAT_LIT .)
    PLUSPLUS        reduce using rule 76 (expr -> FLOAT_LIT .)
    AND             reduce using rule 76 (expr -> FLOAT_LIT .)
    OR              reduce using rule 76 (expr -> FLOAT_LIT .)
    %               reduce using rule 76 (expr -> FLOAT_LIT .)
    /               reduce using rule 76 (expr -> FLOAT_LIT .)
    *               reduce using rule 76 (expr -> FLOAT_LIT .)
    -               reduce using rule 76 (expr -> FLOAT_LIT .)
    +               reduce using rule 76 (expr -> FLOAT_LIT .)
    >               reduce using rule 76 (expr -> FLOAT_LIT .)
    GE              reduce using rule 76 (expr -> FLOAT_LIT .)
    <               reduce using rule 76 (expr -> FLOAT_LIT .)
    LE              reduce using rule 76 (expr -> FLOAT_LIT .)
    NE              reduce using rule 76 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 76 (expr -> FLOAT_LIT .)
    POINT           reduce using rule 76 (expr -> FLOAT_LIT .)
    ;               reduce using rule 76 (expr -> FLOAT_LIT .)
    )               reduce using rule 76 (expr -> FLOAT_LIT .)
    ,               reduce using rule 76 (expr -> FLOAT_LIT .)
    ]               reduce using rule 76 (expr -> FLOAT_LIT .)


state 40

    (77) expr -> INT_LIT .
    MINUSMINUS      reduce using rule 77 (expr -> INT_LIT .)
    PLUSPLUS        reduce using rule 77 (expr -> INT_LIT .)
    AND             reduce using rule 77 (expr -> INT_LIT .)
    OR              reduce using rule 77 (expr -> INT_LIT .)
    %               reduce using rule 77 (expr -> INT_LIT .)
    /               reduce using rule 77 (expr -> INT_LIT .)
    *               reduce using rule 77 (expr -> INT_LIT .)
    -               reduce using rule 77 (expr -> INT_LIT .)
    +               reduce using rule 77 (expr -> INT_LIT .)
    >               reduce using rule 77 (expr -> INT_LIT .)
    GE              reduce using rule 77 (expr -> INT_LIT .)
    <               reduce using rule 77 (expr -> INT_LIT .)
    LE              reduce using rule 77 (expr -> INT_LIT .)
    NE              reduce using rule 77 (expr -> INT_LIT .)
    EQ              reduce using rule 77 (expr -> INT_LIT .)
    POINT           reduce using rule 77 (expr -> INT_LIT .)
    ;               reduce using rule 77 (expr -> INT_LIT .)
    )               reduce using rule 77 (expr -> INT_LIT .)
    ,               reduce using rule 77 (expr -> INT_LIT .)
    ]               reduce using rule 77 (expr -> INT_LIT .)


state 41

    (78) expr -> BOOL_LIT .
    MINUSMINUS      reduce using rule 78 (expr -> BOOL_LIT .)
    PLUSPLUS        reduce using rule 78 (expr -> BOOL_LIT .)
    AND             reduce using rule 78 (expr -> BOOL_LIT .)
    OR              reduce using rule 78 (expr -> BOOL_LIT .)
    %               reduce using rule 78 (expr -> BOOL_LIT .)
    /               reduce using rule 78 (expr -> BOOL_LIT .)
    *               reduce using rule 78 (expr -> BOOL_LIT .)
    -               reduce using rule 78 (expr -> BOOL_LIT .)
    +               reduce using rule 78 (expr -> BOOL_LIT .)
    >               reduce using rule 78 (expr -> BOOL_LIT .)
    GE              reduce using rule 78 (expr -> BOOL_LIT .)
    <               reduce using rule 78 (expr -> BOOL_LIT .)
    LE              reduce using rule 78 (expr -> BOOL_LIT .)
    NE              reduce using rule 78 (expr -> BOOL_LIT .)
    EQ              reduce using rule 78 (expr -> BOOL_LIT .)
    POINT           reduce using rule 78 (expr -> BOOL_LIT .)
    ;               reduce using rule 78 (expr -> BOOL_LIT .)
    )               reduce using rule 78 (expr -> BOOL_LIT .)
    ,               reduce using rule 78 (expr -> BOOL_LIT .)
    ]               reduce using rule 78 (expr -> BOOL_LIT .)


state 42

    (79) expr -> CAST . type_spec ( expr )
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 86

state 43

    (85) expr -> ( . expr )
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 87

state 44

    (80) expr -> INTTOFLOAT . ( IDENT )
    (               shift and go to state 88


state 45

    (86) expr -> + . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 89

state 46

    (87) expr -> - . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 90

state 47

    (88) expr -> ! . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 91

state 48

    (104) expr -> SUPER . POINT IDENT
    POINT           shift and go to state 92


state 49

    (105) expr -> THIS .
    MINUSMINUS      reduce using rule 105 (expr -> THIS .)
    PLUSPLUS        reduce using rule 105 (expr -> THIS .)
    AND             reduce using rule 105 (expr -> THIS .)
    OR              reduce using rule 105 (expr -> THIS .)
    %               reduce using rule 105 (expr -> THIS .)
    /               reduce using rule 105 (expr -> THIS .)
    *               reduce using rule 105 (expr -> THIS .)
    -               reduce using rule 105 (expr -> THIS .)
    +               reduce using rule 105 (expr -> THIS .)
    >               reduce using rule 105 (expr -> THIS .)
    GE              reduce using rule 105 (expr -> THIS .)
    <               reduce using rule 105 (expr -> THIS .)
    LE              reduce using rule 105 (expr -> THIS .)
    NE              reduce using rule 105 (expr -> THIS .)
    EQ              reduce using rule 105 (expr -> THIS .)
    POINT           reduce using rule 105 (expr -> THIS .)
    ;               reduce using rule 105 (expr -> THIS .)
    )               reduce using rule 105 (expr -> THIS .)
    ,               reduce using rule 105 (expr -> THIS .)
    ]               reduce using rule 105 (expr -> THIS .)


state 50

    (7) class_decl -> CLASS IDENT sclass_opt { class_body . } ;
    }               shift and go to state 93


state 51

    (10) class_body -> class_member_list .
    (12) class_member_list -> class_member_list . class_member
    (13) class_member -> . method_decl
    (14) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    }               reduce using rule 10 (class_body -> class_member_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_member                   shift and go to state 94
    method_decl                    shift and go to state 53
    type_spec                      shift and go to state 54

state 52

    (11) class_member_list -> class_member .
    FLOAT           reduce using rule 11 (class_member_list -> class_member .)
    INT             reduce using rule 11 (class_member_list -> class_member .)
    BOOL            reduce using rule 11 (class_member_list -> class_member .)
    VOID            reduce using rule 11 (class_member_list -> class_member .)
    }               reduce using rule 11 (class_member_list -> class_member .)


state 53

    (13) class_member -> method_decl .
    FLOAT           reduce using rule 13 (class_member -> method_decl .)
    INT             reduce using rule 13 (class_member -> method_decl .)
    BOOL            reduce using rule 13 (class_member -> method_decl .)
    VOID            reduce using rule 13 (class_member -> method_decl .)
    }               reduce using rule 13 (class_member -> method_decl .)


state 54

    (14) method_decl -> type_spec . IDENT ( _1_params_optional ) compound_stmt
    IDENT           shift and go to state 95


state 55

    (32) param -> type_spec IDENT . [ ]
    (33) param -> type_spec IDENT .
    [               shift and go to state 96
    ,               reduce using rule 33 (param -> type_spec IDENT .)
    )               reduce using rule 33 (param -> type_spec IDENT .)


state 56

    (25) func_decl -> type_spec IDENT ( _3_params_optional ) . compound_stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 98

    compound_stmt                  shift and go to state 97

state 57

    (31) param_list -> param_list , . param
    (32) param -> . type_spec IDENT [ ]
    (33) param -> . type_spec IDENT
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 99
    type_spec                      shift and go to state 25

state 58

    (17) var_decl -> type_spec IDENT [ ] ; .
    CLASS           reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)


state 59

    (72) expr -> expr MINUSMINUS .
    MINUSMINUS      reduce using rule 72 (expr -> expr MINUSMINUS .)
    PLUSPLUS        reduce using rule 72 (expr -> expr MINUSMINUS .)
    AND             reduce using rule 72 (expr -> expr MINUSMINUS .)
    OR              reduce using rule 72 (expr -> expr MINUSMINUS .)
    %               reduce using rule 72 (expr -> expr MINUSMINUS .)
    /               reduce using rule 72 (expr -> expr MINUSMINUS .)
    *               reduce using rule 72 (expr -> expr MINUSMINUS .)
    -               reduce using rule 72 (expr -> expr MINUSMINUS .)
    +               reduce using rule 72 (expr -> expr MINUSMINUS .)
    >               reduce using rule 72 (expr -> expr MINUSMINUS .)
    GE              reduce using rule 72 (expr -> expr MINUSMINUS .)
    <               reduce using rule 72 (expr -> expr MINUSMINUS .)
    LE              reduce using rule 72 (expr -> expr MINUSMINUS .)
    NE              reduce using rule 72 (expr -> expr MINUSMINUS .)
    EQ              reduce using rule 72 (expr -> expr MINUSMINUS .)
    POINT           reduce using rule 72 (expr -> expr MINUSMINUS .)
    ;               reduce using rule 72 (expr -> expr MINUSMINUS .)
    )               reduce using rule 72 (expr -> expr MINUSMINUS .)
    ,               reduce using rule 72 (expr -> expr MINUSMINUS .)
    ]               reduce using rule 72 (expr -> expr MINUSMINUS .)


state 60

    (73) expr -> expr PLUSPLUS .
    MINUSMINUS      reduce using rule 73 (expr -> expr PLUSPLUS .)
    PLUSPLUS        reduce using rule 73 (expr -> expr PLUSPLUS .)
    AND             reduce using rule 73 (expr -> expr PLUSPLUS .)
    OR              reduce using rule 73 (expr -> expr PLUSPLUS .)
    %               reduce using rule 73 (expr -> expr PLUSPLUS .)
    /               reduce using rule 73 (expr -> expr PLUSPLUS .)
    *               reduce using rule 73 (expr -> expr PLUSPLUS .)
    -               reduce using rule 73 (expr -> expr PLUSPLUS .)
    +               reduce using rule 73 (expr -> expr PLUSPLUS .)
    >               reduce using rule 73 (expr -> expr PLUSPLUS .)
    GE              reduce using rule 73 (expr -> expr PLUSPLUS .)
    <               reduce using rule 73 (expr -> expr PLUSPLUS .)
    LE              reduce using rule 73 (expr -> expr PLUSPLUS .)
    NE              reduce using rule 73 (expr -> expr PLUSPLUS .)
    EQ              reduce using rule 73 (expr -> expr PLUSPLUS .)
    POINT           reduce using rule 73 (expr -> expr PLUSPLUS .)
    ;               reduce using rule 73 (expr -> expr PLUSPLUS .)
    )               reduce using rule 73 (expr -> expr PLUSPLUS .)
    ,               reduce using rule 73 (expr -> expr PLUSPLUS .)
    ]               reduce using rule 73 (expr -> expr PLUSPLUS .)


state 61

    (89) expr -> expr AND . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 100

state 62

    (90) expr -> expr OR . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 101

state 63

    (91) expr -> expr % . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 102

state 64

    (92) expr -> expr / . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 103

state 65

    (93) expr -> expr * . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 104

state 66

    (94) expr -> expr - . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 105

state 67

    (95) expr -> expr + . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 106

state 68

    (96) expr -> expr > . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 107

state 69

    (97) expr -> expr GE . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 108

state 70

    (98) expr -> expr < . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 109

state 71

    (99) expr -> expr LE . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 110

state 72

    (100) expr -> expr NE . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 111

state 73

    (101) expr -> expr EQ . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 112

state 74

    (102) expr -> expr POINT . IDENT = expr
    (103) expr -> expr POINT . IDENT
    IDENT           shift and go to state 113


state 75

    (66) expr -> IDENT DIVEQ . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 114

state 76

    (67) expr -> IDENT MULEQ . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 115

state 77

    (68) expr -> IDENT MINUSEQ . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 116

state 78

    (69) expr -> IDENT PLUSEQ . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 117

state 79

    (81) expr -> IDENT . . SIZE
    SIZE            shift and go to state 118


state 80

    (82) expr -> IDENT ( . args )
    (108) args -> . empty
    (109) args -> . arg_list
    (116) empty -> .
    (110) arg_list -> . expr
    (111) arg_list -> . arg_list , expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    )               reduce using rule 116 (empty -> .)
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    args                           shift and go to state 119
    empty                          shift and go to state 120
    arg_list                       shift and go to state 121
    expr                           shift and go to state 122

state 81

    (83) expr -> IDENT [ . expr ]
    (106) expr -> IDENT [ . expr ] = expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 123

state 82

    (107) expr -> IDENT = . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 124

state 83

    (70) expr -> MINUSMINUS expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 70 (expr -> MINUSMINUS expr .)
    PLUSPLUS        reduce using rule 70 (expr -> MINUSMINUS expr .)
    POINT           reduce using rule 70 (expr -> MINUSMINUS expr .)
    ;               reduce using rule 70 (expr -> MINUSMINUS expr .)
    )               reduce using rule 70 (expr -> MINUSMINUS expr .)
    ,               reduce using rule 70 (expr -> MINUSMINUS expr .)
    ]               reduce using rule 70 (expr -> MINUSMINUS expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 84

    (71) expr -> PLUSPLUS expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    PLUSPLUS        reduce using rule 71 (expr -> PLUSPLUS expr .)
    POINT           reduce using rule 71 (expr -> PLUSPLUS expr .)
    ;               reduce using rule 71 (expr -> PLUSPLUS expr .)
    )               reduce using rule 71 (expr -> PLUSPLUS expr .)
    ,               reduce using rule 71 (expr -> PLUSPLUS expr .)
    ]               reduce using rule 71 (expr -> PLUSPLUS expr .)
    MINUSMINUS      shift and go to state 59
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 85

    (74) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 125


state 86

    (79) expr -> CAST type_spec . ( expr )
    (               shift and go to state 126


state 87

    (85) expr -> ( expr . )
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 127
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 88

    (80) expr -> INTTOFLOAT ( . IDENT )
    IDENT           shift and go to state 128


state 89

    (86) expr -> + expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 86 (expr -> + expr .)
    PLUSPLUS        reduce using rule 86 (expr -> + expr .)
    AND             reduce using rule 86 (expr -> + expr .)
    OR              reduce using rule 86 (expr -> + expr .)
    %               reduce using rule 86 (expr -> + expr .)
    /               reduce using rule 86 (expr -> + expr .)
    *               reduce using rule 86 (expr -> + expr .)
    -               reduce using rule 86 (expr -> + expr .)
    +               reduce using rule 86 (expr -> + expr .)
    >               reduce using rule 86 (expr -> + expr .)
    GE              reduce using rule 86 (expr -> + expr .)
    <               reduce using rule 86 (expr -> + expr .)
    LE              reduce using rule 86 (expr -> + expr .)
    NE              reduce using rule 86 (expr -> + expr .)
    EQ              reduce using rule 86 (expr -> + expr .)
    POINT           reduce using rule 86 (expr -> + expr .)
    ;               reduce using rule 86 (expr -> + expr .)
    )               reduce using rule 86 (expr -> + expr .)
    ,               reduce using rule 86 (expr -> + expr .)
    ]               reduce using rule 86 (expr -> + expr .)


state 90

    (87) expr -> - expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 87 (expr -> - expr .)
    PLUSPLUS        reduce using rule 87 (expr -> - expr .)
    AND             reduce using rule 87 (expr -> - expr .)
    OR              reduce using rule 87 (expr -> - expr .)
    %               reduce using rule 87 (expr -> - expr .)
    /               reduce using rule 87 (expr -> - expr .)
    *               reduce using rule 87 (expr -> - expr .)
    -               reduce using rule 87 (expr -> - expr .)
    +               reduce using rule 87 (expr -> - expr .)
    >               reduce using rule 87 (expr -> - expr .)
    GE              reduce using rule 87 (expr -> - expr .)
    <               reduce using rule 87 (expr -> - expr .)
    LE              reduce using rule 87 (expr -> - expr .)
    NE              reduce using rule 87 (expr -> - expr .)
    EQ              reduce using rule 87 (expr -> - expr .)
    POINT           reduce using rule 87 (expr -> - expr .)
    ;               reduce using rule 87 (expr -> - expr .)
    )               reduce using rule 87 (expr -> - expr .)
    ,               reduce using rule 87 (expr -> - expr .)
    ]               reduce using rule 87 (expr -> - expr .)


state 91

    (88) expr -> ! expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 88 (expr -> ! expr .)
    PLUSPLUS        reduce using rule 88 (expr -> ! expr .)
    AND             reduce using rule 88 (expr -> ! expr .)
    OR              reduce using rule 88 (expr -> ! expr .)
    %               reduce using rule 88 (expr -> ! expr .)
    /               reduce using rule 88 (expr -> ! expr .)
    *               reduce using rule 88 (expr -> ! expr .)
    -               reduce using rule 88 (expr -> ! expr .)
    +               reduce using rule 88 (expr -> ! expr .)
    >               reduce using rule 88 (expr -> ! expr .)
    GE              reduce using rule 88 (expr -> ! expr .)
    <               reduce using rule 88 (expr -> ! expr .)
    LE              reduce using rule 88 (expr -> ! expr .)
    NE              reduce using rule 88 (expr -> ! expr .)
    EQ              reduce using rule 88 (expr -> ! expr .)
    POINT           reduce using rule 88 (expr -> ! expr .)
    ;               reduce using rule 88 (expr -> ! expr .)
    )               reduce using rule 88 (expr -> ! expr .)
    ,               reduce using rule 88 (expr -> ! expr .)
    ]               reduce using rule 88 (expr -> ! expr .)


state 92

    (104) expr -> SUPER POINT . IDENT
    IDENT           shift and go to state 129


state 93

    (7) class_decl -> CLASS IDENT sclass_opt { class_body } . ;
    ;               shift and go to state 130


state 94

    (12) class_member_list -> class_member_list class_member .
    FLOAT           reduce using rule 12 (class_member_list -> class_member_list class_member .)
    INT             reduce using rule 12 (class_member_list -> class_member_list class_member .)
    BOOL            reduce using rule 12 (class_member_list -> class_member_list class_member .)
    VOID            reduce using rule 12 (class_member_list -> class_member_list class_member .)
    }               reduce using rule 12 (class_member_list -> class_member_list class_member .)


state 95

    (14) method_decl -> type_spec IDENT . ( _1_params_optional ) compound_stmt
    (               shift and go to state 131


state 96

    (32) param -> type_spec IDENT [ . ]
    ]               shift and go to state 132


state 97

    (25) func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .
    CLASS           reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)
    FLOAT           reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)
    INT             reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)
    BOOL            reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)
    VOID            reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)
    $end            reduce using rule 25 (func_decl -> type_spec IDENT ( _3_params_optional ) compound_stmt .)


state 98

    (34) compound_stmt -> { . local_decls stmt_list }
    (35) local_decls -> . empty
    (36) local_decls -> . local_decl_list
    (116) empty -> .
    (37) local_decl_list -> . local_decl
    (38) local_decl_list -> . local_decl_list local_decl
    (39) local_decl -> . type_spec IDENT [ ] ;
    (40) local_decl -> . type_spec IDENT _4_0x3d_expr_optional ;
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    SPRINTF         reduce using rule 116 (empty -> .)
    SCANF           reduce using rule 116 (empty -> .)
    PRINTF          reduce using rule 116 (empty -> .)
    FOR             reduce using rule 116 (empty -> .)
    CONTINUE        reduce using rule 116 (empty -> .)
    BREAK           reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    {               reduce using rule 116 (empty -> .)
    ;               reduce using rule 116 (empty -> .)
    IDENT           reduce using rule 116 (empty -> .)
    MINUSMINUS      reduce using rule 116 (empty -> .)
    PLUSPLUS        reduce using rule 116 (empty -> .)
    NEW             reduce using rule 116 (empty -> .)
    STRING          reduce using rule 116 (empty -> .)
    FLOAT_LIT       reduce using rule 116 (empty -> .)
    INT_LIT         reduce using rule 116 (empty -> .)
    BOOL_LIT        reduce using rule 116 (empty -> .)
    CAST            reduce using rule 116 (empty -> .)
    INTTOFLOAT      reduce using rule 116 (empty -> .)
    (               reduce using rule 116 (empty -> .)
    +               reduce using rule 116 (empty -> .)
    -               reduce using rule 116 (empty -> .)
    !               reduce using rule 116 (empty -> .)
    SUPER           reduce using rule 116 (empty -> .)
    THIS            reduce using rule 116 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 133
    empty                          shift and go to state 134
    local_decl_list                shift and go to state 135
    local_decl                     shift and go to state 136
    type_spec                      shift and go to state 137

state 99

    (31) param_list -> param_list , param .
    ,               reduce using rule 31 (param_list -> param_list , param .)
    )               reduce using rule 31 (param_list -> param_list , param .)


state 100

    (89) expr -> expr AND expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 89 (expr -> expr AND expr .)
    PLUSPLUS        reduce using rule 89 (expr -> expr AND expr .)
    AND             reduce using rule 89 (expr -> expr AND expr .)
    OR              reduce using rule 89 (expr -> expr AND expr .)
    POINT           reduce using rule 89 (expr -> expr AND expr .)
    ;               reduce using rule 89 (expr -> expr AND expr .)
    )               reduce using rule 89 (expr -> expr AND expr .)
    ,               reduce using rule 89 (expr -> expr AND expr .)
    ]               reduce using rule 89 (expr -> expr AND expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 101

    (90) expr -> expr OR expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 90 (expr -> expr OR expr .)
    PLUSPLUS        reduce using rule 90 (expr -> expr OR expr .)
    OR              reduce using rule 90 (expr -> expr OR expr .)
    POINT           reduce using rule 90 (expr -> expr OR expr .)
    ;               reduce using rule 90 (expr -> expr OR expr .)
    )               reduce using rule 90 (expr -> expr OR expr .)
    ,               reduce using rule 90 (expr -> expr OR expr .)
    ]               reduce using rule 90 (expr -> expr OR expr .)
    AND             shift and go to state 61
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 102

    (91) expr -> expr % expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 91 (expr -> expr % expr .)
    PLUSPLUS        reduce using rule 91 (expr -> expr % expr .)
    AND             reduce using rule 91 (expr -> expr % expr .)
    OR              reduce using rule 91 (expr -> expr % expr .)
    %               reduce using rule 91 (expr -> expr % expr .)
    /               reduce using rule 91 (expr -> expr % expr .)
    *               reduce using rule 91 (expr -> expr % expr .)
    -               reduce using rule 91 (expr -> expr % expr .)
    +               reduce using rule 91 (expr -> expr % expr .)
    >               reduce using rule 91 (expr -> expr % expr .)
    GE              reduce using rule 91 (expr -> expr % expr .)
    <               reduce using rule 91 (expr -> expr % expr .)
    LE              reduce using rule 91 (expr -> expr % expr .)
    NE              reduce using rule 91 (expr -> expr % expr .)
    EQ              reduce using rule 91 (expr -> expr % expr .)
    POINT           reduce using rule 91 (expr -> expr % expr .)
    ;               reduce using rule 91 (expr -> expr % expr .)
    )               reduce using rule 91 (expr -> expr % expr .)
    ,               reduce using rule 91 (expr -> expr % expr .)
    ]               reduce using rule 91 (expr -> expr % expr .)


state 103

    (92) expr -> expr / expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 92 (expr -> expr / expr .)
    PLUSPLUS        reduce using rule 92 (expr -> expr / expr .)
    AND             reduce using rule 92 (expr -> expr / expr .)
    OR              reduce using rule 92 (expr -> expr / expr .)
    %               reduce using rule 92 (expr -> expr / expr .)
    /               reduce using rule 92 (expr -> expr / expr .)
    *               reduce using rule 92 (expr -> expr / expr .)
    -               reduce using rule 92 (expr -> expr / expr .)
    +               reduce using rule 92 (expr -> expr / expr .)
    >               reduce using rule 92 (expr -> expr / expr .)
    GE              reduce using rule 92 (expr -> expr / expr .)
    <               reduce using rule 92 (expr -> expr / expr .)
    LE              reduce using rule 92 (expr -> expr / expr .)
    NE              reduce using rule 92 (expr -> expr / expr .)
    EQ              reduce using rule 92 (expr -> expr / expr .)
    POINT           reduce using rule 92 (expr -> expr / expr .)
    ;               reduce using rule 92 (expr -> expr / expr .)
    )               reduce using rule 92 (expr -> expr / expr .)
    ,               reduce using rule 92 (expr -> expr / expr .)
    ]               reduce using rule 92 (expr -> expr / expr .)


state 104

    (93) expr -> expr * expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 93 (expr -> expr * expr .)
    PLUSPLUS        reduce using rule 93 (expr -> expr * expr .)
    AND             reduce using rule 93 (expr -> expr * expr .)
    OR              reduce using rule 93 (expr -> expr * expr .)
    %               reduce using rule 93 (expr -> expr * expr .)
    /               reduce using rule 93 (expr -> expr * expr .)
    *               reduce using rule 93 (expr -> expr * expr .)
    -               reduce using rule 93 (expr -> expr * expr .)
    +               reduce using rule 93 (expr -> expr * expr .)
    >               reduce using rule 93 (expr -> expr * expr .)
    GE              reduce using rule 93 (expr -> expr * expr .)
    <               reduce using rule 93 (expr -> expr * expr .)
    LE              reduce using rule 93 (expr -> expr * expr .)
    NE              reduce using rule 93 (expr -> expr * expr .)
    EQ              reduce using rule 93 (expr -> expr * expr .)
    POINT           reduce using rule 93 (expr -> expr * expr .)
    ;               reduce using rule 93 (expr -> expr * expr .)
    )               reduce using rule 93 (expr -> expr * expr .)
    ,               reduce using rule 93 (expr -> expr * expr .)
    ]               reduce using rule 93 (expr -> expr * expr .)


state 105

    (94) expr -> expr - expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 94 (expr -> expr - expr .)
    PLUSPLUS        reduce using rule 94 (expr -> expr - expr .)
    AND             reduce using rule 94 (expr -> expr - expr .)
    OR              reduce using rule 94 (expr -> expr - expr .)
    -               reduce using rule 94 (expr -> expr - expr .)
    +               reduce using rule 94 (expr -> expr - expr .)
    >               reduce using rule 94 (expr -> expr - expr .)
    GE              reduce using rule 94 (expr -> expr - expr .)
    <               reduce using rule 94 (expr -> expr - expr .)
    LE              reduce using rule 94 (expr -> expr - expr .)
    NE              reduce using rule 94 (expr -> expr - expr .)
    EQ              reduce using rule 94 (expr -> expr - expr .)
    POINT           reduce using rule 94 (expr -> expr - expr .)
    ;               reduce using rule 94 (expr -> expr - expr .)
    )               reduce using rule 94 (expr -> expr - expr .)
    ,               reduce using rule 94 (expr -> expr - expr .)
    ]               reduce using rule 94 (expr -> expr - expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65


state 106

    (95) expr -> expr + expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 95 (expr -> expr + expr .)
    PLUSPLUS        reduce using rule 95 (expr -> expr + expr .)
    AND             reduce using rule 95 (expr -> expr + expr .)
    OR              reduce using rule 95 (expr -> expr + expr .)
    -               reduce using rule 95 (expr -> expr + expr .)
    +               reduce using rule 95 (expr -> expr + expr .)
    >               reduce using rule 95 (expr -> expr + expr .)
    GE              reduce using rule 95 (expr -> expr + expr .)
    <               reduce using rule 95 (expr -> expr + expr .)
    LE              reduce using rule 95 (expr -> expr + expr .)
    NE              reduce using rule 95 (expr -> expr + expr .)
    EQ              reduce using rule 95 (expr -> expr + expr .)
    POINT           reduce using rule 95 (expr -> expr + expr .)
    ;               reduce using rule 95 (expr -> expr + expr .)
    )               reduce using rule 95 (expr -> expr + expr .)
    ,               reduce using rule 95 (expr -> expr + expr .)
    ]               reduce using rule 95 (expr -> expr + expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65


state 107

    (96) expr -> expr > expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 96 (expr -> expr > expr .)
    PLUSPLUS        reduce using rule 96 (expr -> expr > expr .)
    AND             reduce using rule 96 (expr -> expr > expr .)
    OR              reduce using rule 96 (expr -> expr > expr .)
    >               reduce using rule 96 (expr -> expr > expr .)
    GE              reduce using rule 96 (expr -> expr > expr .)
    <               reduce using rule 96 (expr -> expr > expr .)
    LE              reduce using rule 96 (expr -> expr > expr .)
    NE              reduce using rule 96 (expr -> expr > expr .)
    EQ              reduce using rule 96 (expr -> expr > expr .)
    POINT           reduce using rule 96 (expr -> expr > expr .)
    ;               reduce using rule 96 (expr -> expr > expr .)
    )               reduce using rule 96 (expr -> expr > expr .)
    ,               reduce using rule 96 (expr -> expr > expr .)
    ]               reduce using rule 96 (expr -> expr > expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67


state 108

    (97) expr -> expr GE expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 97 (expr -> expr GE expr .)
    PLUSPLUS        reduce using rule 97 (expr -> expr GE expr .)
    AND             reduce using rule 97 (expr -> expr GE expr .)
    OR              reduce using rule 97 (expr -> expr GE expr .)
    >               reduce using rule 97 (expr -> expr GE expr .)
    GE              reduce using rule 97 (expr -> expr GE expr .)
    <               reduce using rule 97 (expr -> expr GE expr .)
    LE              reduce using rule 97 (expr -> expr GE expr .)
    NE              reduce using rule 97 (expr -> expr GE expr .)
    EQ              reduce using rule 97 (expr -> expr GE expr .)
    POINT           reduce using rule 97 (expr -> expr GE expr .)
    ;               reduce using rule 97 (expr -> expr GE expr .)
    )               reduce using rule 97 (expr -> expr GE expr .)
    ,               reduce using rule 97 (expr -> expr GE expr .)
    ]               reduce using rule 97 (expr -> expr GE expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67


state 109

    (98) expr -> expr < expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 98 (expr -> expr < expr .)
    PLUSPLUS        reduce using rule 98 (expr -> expr < expr .)
    AND             reduce using rule 98 (expr -> expr < expr .)
    OR              reduce using rule 98 (expr -> expr < expr .)
    >               reduce using rule 98 (expr -> expr < expr .)
    GE              reduce using rule 98 (expr -> expr < expr .)
    <               reduce using rule 98 (expr -> expr < expr .)
    LE              reduce using rule 98 (expr -> expr < expr .)
    NE              reduce using rule 98 (expr -> expr < expr .)
    EQ              reduce using rule 98 (expr -> expr < expr .)
    POINT           reduce using rule 98 (expr -> expr < expr .)
    ;               reduce using rule 98 (expr -> expr < expr .)
    )               reduce using rule 98 (expr -> expr < expr .)
    ,               reduce using rule 98 (expr -> expr < expr .)
    ]               reduce using rule 98 (expr -> expr < expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67


state 110

    (99) expr -> expr LE expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 99 (expr -> expr LE expr .)
    PLUSPLUS        reduce using rule 99 (expr -> expr LE expr .)
    AND             reduce using rule 99 (expr -> expr LE expr .)
    OR              reduce using rule 99 (expr -> expr LE expr .)
    >               reduce using rule 99 (expr -> expr LE expr .)
    GE              reduce using rule 99 (expr -> expr LE expr .)
    <               reduce using rule 99 (expr -> expr LE expr .)
    LE              reduce using rule 99 (expr -> expr LE expr .)
    NE              reduce using rule 99 (expr -> expr LE expr .)
    EQ              reduce using rule 99 (expr -> expr LE expr .)
    POINT           reduce using rule 99 (expr -> expr LE expr .)
    ;               reduce using rule 99 (expr -> expr LE expr .)
    )               reduce using rule 99 (expr -> expr LE expr .)
    ,               reduce using rule 99 (expr -> expr LE expr .)
    ]               reduce using rule 99 (expr -> expr LE expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67


state 111

    (100) expr -> expr NE expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 100 (expr -> expr NE expr .)
    PLUSPLUS        reduce using rule 100 (expr -> expr NE expr .)
    AND             reduce using rule 100 (expr -> expr NE expr .)
    OR              reduce using rule 100 (expr -> expr NE expr .)
    NE              reduce using rule 100 (expr -> expr NE expr .)
    EQ              reduce using rule 100 (expr -> expr NE expr .)
    POINT           reduce using rule 100 (expr -> expr NE expr .)
    ;               reduce using rule 100 (expr -> expr NE expr .)
    )               reduce using rule 100 (expr -> expr NE expr .)
    ,               reduce using rule 100 (expr -> expr NE expr .)
    ]               reduce using rule 100 (expr -> expr NE expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71


state 112

    (101) expr -> expr EQ expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 101 (expr -> expr EQ expr .)
    PLUSPLUS        reduce using rule 101 (expr -> expr EQ expr .)
    AND             reduce using rule 101 (expr -> expr EQ expr .)
    OR              reduce using rule 101 (expr -> expr EQ expr .)
    NE              reduce using rule 101 (expr -> expr EQ expr .)
    EQ              reduce using rule 101 (expr -> expr EQ expr .)
    POINT           reduce using rule 101 (expr -> expr EQ expr .)
    ;               reduce using rule 101 (expr -> expr EQ expr .)
    )               reduce using rule 101 (expr -> expr EQ expr .)
    ,               reduce using rule 101 (expr -> expr EQ expr .)
    ]               reduce using rule 101 (expr -> expr EQ expr .)
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71


state 113

    (102) expr -> expr POINT IDENT . = expr
    (103) expr -> expr POINT IDENT .
    =               shift and go to state 138
    MINUSMINUS      reduce using rule 103 (expr -> expr POINT IDENT .)
    PLUSPLUS        reduce using rule 103 (expr -> expr POINT IDENT .)
    AND             reduce using rule 103 (expr -> expr POINT IDENT .)
    OR              reduce using rule 103 (expr -> expr POINT IDENT .)
    %               reduce using rule 103 (expr -> expr POINT IDENT .)
    /               reduce using rule 103 (expr -> expr POINT IDENT .)
    *               reduce using rule 103 (expr -> expr POINT IDENT .)
    -               reduce using rule 103 (expr -> expr POINT IDENT .)
    +               reduce using rule 103 (expr -> expr POINT IDENT .)
    >               reduce using rule 103 (expr -> expr POINT IDENT .)
    GE              reduce using rule 103 (expr -> expr POINT IDENT .)
    <               reduce using rule 103 (expr -> expr POINT IDENT .)
    LE              reduce using rule 103 (expr -> expr POINT IDENT .)
    NE              reduce using rule 103 (expr -> expr POINT IDENT .)
    EQ              reduce using rule 103 (expr -> expr POINT IDENT .)
    POINT           reduce using rule 103 (expr -> expr POINT IDENT .)
    ;               reduce using rule 103 (expr -> expr POINT IDENT .)
    )               reduce using rule 103 (expr -> expr POINT IDENT .)
    ,               reduce using rule 103 (expr -> expr POINT IDENT .)
    ]               reduce using rule 103 (expr -> expr POINT IDENT .)


state 114

    (66) expr -> IDENT DIVEQ expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    PLUSPLUS        reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    POINT           reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    ;               reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    )               reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    ,               reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    ]               reduce using rule 66 (expr -> IDENT DIVEQ expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 115

    (67) expr -> IDENT MULEQ expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 67 (expr -> IDENT MULEQ expr .)
    PLUSPLUS        reduce using rule 67 (expr -> IDENT MULEQ expr .)
    POINT           reduce using rule 67 (expr -> IDENT MULEQ expr .)
    ;               reduce using rule 67 (expr -> IDENT MULEQ expr .)
    )               reduce using rule 67 (expr -> IDENT MULEQ expr .)
    ,               reduce using rule 67 (expr -> IDENT MULEQ expr .)
    ]               reduce using rule 67 (expr -> IDENT MULEQ expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 116

    (68) expr -> IDENT MINUSEQ expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    PLUSPLUS        reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    POINT           reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    ;               reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    )               reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    ,               reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    ]               reduce using rule 68 (expr -> IDENT MINUSEQ expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 117

    (69) expr -> IDENT PLUSEQ expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    PLUSPLUS        reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    POINT           reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    ;               reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    )               reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    ,               reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    ]               reduce using rule 69 (expr -> IDENT PLUSEQ expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 118

    (81) expr -> IDENT . SIZE .
    MINUSMINUS      reduce using rule 81 (expr -> IDENT . SIZE .)
    PLUSPLUS        reduce using rule 81 (expr -> IDENT . SIZE .)
    AND             reduce using rule 81 (expr -> IDENT . SIZE .)
    OR              reduce using rule 81 (expr -> IDENT . SIZE .)
    %               reduce using rule 81 (expr -> IDENT . SIZE .)
    /               reduce using rule 81 (expr -> IDENT . SIZE .)
    *               reduce using rule 81 (expr -> IDENT . SIZE .)
    -               reduce using rule 81 (expr -> IDENT . SIZE .)
    +               reduce using rule 81 (expr -> IDENT . SIZE .)
    >               reduce using rule 81 (expr -> IDENT . SIZE .)
    GE              reduce using rule 81 (expr -> IDENT . SIZE .)
    <               reduce using rule 81 (expr -> IDENT . SIZE .)
    LE              reduce using rule 81 (expr -> IDENT . SIZE .)
    NE              reduce using rule 81 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 81 (expr -> IDENT . SIZE .)
    POINT           reduce using rule 81 (expr -> IDENT . SIZE .)
    ;               reduce using rule 81 (expr -> IDENT . SIZE .)
    )               reduce using rule 81 (expr -> IDENT . SIZE .)
    ,               reduce using rule 81 (expr -> IDENT . SIZE .)
    ]               reduce using rule 81 (expr -> IDENT . SIZE .)


state 119

    (82) expr -> IDENT ( args . )
    )               shift and go to state 139


state 120

    (108) args -> empty .
    )               reduce using rule 108 (args -> empty .)


state 121

    (109) args -> arg_list .
    (111) arg_list -> arg_list . , expr
    )               reduce using rule 109 (args -> arg_list .)
    ,               shift and go to state 140


state 122

    (110) arg_list -> expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ,               reduce using rule 110 (arg_list -> expr .)
    )               reduce using rule 110 (arg_list -> expr .)
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 123

    (83) expr -> IDENT [ expr . ]
    (106) expr -> IDENT [ expr . ] = expr
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ]               shift and go to state 141
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 124

    (107) expr -> IDENT = expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 107 (expr -> IDENT = expr .)
    PLUSPLUS        reduce using rule 107 (expr -> IDENT = expr .)
    POINT           reduce using rule 107 (expr -> IDENT = expr .)
    ;               reduce using rule 107 (expr -> IDENT = expr .)
    )               reduce using rule 107 (expr -> IDENT = expr .)
    ,               reduce using rule 107 (expr -> IDENT = expr .)
    ]               reduce using rule 107 (expr -> IDENT = expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 125

    (74) expr -> NEW type_spec [ . expr ]
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 142

state 126

    (79) expr -> CAST type_spec ( . expr )
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 143

state 127

    (85) expr -> ( expr ) .
    MINUSMINUS      reduce using rule 85 (expr -> ( expr ) .)
    PLUSPLUS        reduce using rule 85 (expr -> ( expr ) .)
    AND             reduce using rule 85 (expr -> ( expr ) .)
    OR              reduce using rule 85 (expr -> ( expr ) .)
    %               reduce using rule 85 (expr -> ( expr ) .)
    /               reduce using rule 85 (expr -> ( expr ) .)
    *               reduce using rule 85 (expr -> ( expr ) .)
    -               reduce using rule 85 (expr -> ( expr ) .)
    +               reduce using rule 85 (expr -> ( expr ) .)
    >               reduce using rule 85 (expr -> ( expr ) .)
    GE              reduce using rule 85 (expr -> ( expr ) .)
    <               reduce using rule 85 (expr -> ( expr ) .)
    LE              reduce using rule 85 (expr -> ( expr ) .)
    NE              reduce using rule 85 (expr -> ( expr ) .)
    EQ              reduce using rule 85 (expr -> ( expr ) .)
    POINT           reduce using rule 85 (expr -> ( expr ) .)
    ;               reduce using rule 85 (expr -> ( expr ) .)
    )               reduce using rule 85 (expr -> ( expr ) .)
    ,               reduce using rule 85 (expr -> ( expr ) .)
    ]               reduce using rule 85 (expr -> ( expr ) .)


state 128

    (80) expr -> INTTOFLOAT ( IDENT . )
    )               shift and go to state 144


state 129

    (104) expr -> SUPER POINT IDENT .
    MINUSMINUS      reduce using rule 104 (expr -> SUPER POINT IDENT .)
    PLUSPLUS        reduce using rule 104 (expr -> SUPER POINT IDENT .)
    AND             reduce using rule 104 (expr -> SUPER POINT IDENT .)
    OR              reduce using rule 104 (expr -> SUPER POINT IDENT .)
    %               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    /               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    *               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    -               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    +               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    >               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    GE              reduce using rule 104 (expr -> SUPER POINT IDENT .)
    <               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    LE              reduce using rule 104 (expr -> SUPER POINT IDENT .)
    NE              reduce using rule 104 (expr -> SUPER POINT IDENT .)
    EQ              reduce using rule 104 (expr -> SUPER POINT IDENT .)
    POINT           reduce using rule 104 (expr -> SUPER POINT IDENT .)
    ;               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    )               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    ,               reduce using rule 104 (expr -> SUPER POINT IDENT .)
    ]               reduce using rule 104 (expr -> SUPER POINT IDENT .)


state 130

    (7) class_decl -> CLASS IDENT sclass_opt { class_body } ; .
    CLASS           reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    FLOAT           reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    INT             reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    BOOL            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    VOID            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    $end            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)


state 131

    (14) method_decl -> type_spec IDENT ( . _1_params_optional ) compound_stmt
    (15) _1_params_optional -> . params
    (16) _1_params_optional -> .
    (28) params -> . VOID
    (29) params -> . param_list
    (30) param_list -> . param
    (31) param_list -> . param_list , param
    (32) param -> . type_spec IDENT [ ]
    (33) param -> . type_spec IDENT
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    )               reduce using rule 16 (_1_params_optional -> .)
    VOID            shift and go to state 28
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 25
    _1_params_optional             shift and go to state 145
    params                         shift and go to state 146
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 132

    (32) param -> type_spec IDENT [ ] .
    ,               reduce using rule 32 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 32 (param -> type_spec IDENT [ ] .)


state 133

    (34) compound_stmt -> { local_decls . stmt_list }
    (43) stmt_list -> . stmt
    (44) stmt_list -> . stmt_list stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    stmt_list                      shift and go to state 147
    stmt                           shift and go to state 148
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158
    expr                           shift and go to state 164

state 134

    (35) local_decls -> empty .
    SPRINTF         reduce using rule 35 (local_decls -> empty .)
    SCANF           reduce using rule 35 (local_decls -> empty .)
    PRINTF          reduce using rule 35 (local_decls -> empty .)
    FOR             reduce using rule 35 (local_decls -> empty .)
    CONTINUE        reduce using rule 35 (local_decls -> empty .)
    BREAK           reduce using rule 35 (local_decls -> empty .)
    RETURN          reduce using rule 35 (local_decls -> empty .)
    WHILE           reduce using rule 35 (local_decls -> empty .)
    IF              reduce using rule 35 (local_decls -> empty .)
    {               reduce using rule 35 (local_decls -> empty .)
    ;               reduce using rule 35 (local_decls -> empty .)
    IDENT           reduce using rule 35 (local_decls -> empty .)
    MINUSMINUS      reduce using rule 35 (local_decls -> empty .)
    PLUSPLUS        reduce using rule 35 (local_decls -> empty .)
    NEW             reduce using rule 35 (local_decls -> empty .)
    STRING          reduce using rule 35 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 35 (local_decls -> empty .)
    INT_LIT         reduce using rule 35 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 35 (local_decls -> empty .)
    CAST            reduce using rule 35 (local_decls -> empty .)
    INTTOFLOAT      reduce using rule 35 (local_decls -> empty .)
    (               reduce using rule 35 (local_decls -> empty .)
    +               reduce using rule 35 (local_decls -> empty .)
    -               reduce using rule 35 (local_decls -> empty .)
    !               reduce using rule 35 (local_decls -> empty .)
    SUPER           reduce using rule 35 (local_decls -> empty .)
    THIS            reduce using rule 35 (local_decls -> empty .)


state 135

    (36) local_decls -> local_decl_list .
    (38) local_decl_list -> local_decl_list . local_decl
    (39) local_decl -> . type_spec IDENT [ ] ;
    (40) local_decl -> . type_spec IDENT _4_0x3d_expr_optional ;
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    SPRINTF         reduce using rule 36 (local_decls -> local_decl_list .)
    SCANF           reduce using rule 36 (local_decls -> local_decl_list .)
    PRINTF          reduce using rule 36 (local_decls -> local_decl_list .)
    FOR             reduce using rule 36 (local_decls -> local_decl_list .)
    CONTINUE        reduce using rule 36 (local_decls -> local_decl_list .)
    BREAK           reduce using rule 36 (local_decls -> local_decl_list .)
    RETURN          reduce using rule 36 (local_decls -> local_decl_list .)
    WHILE           reduce using rule 36 (local_decls -> local_decl_list .)
    IF              reduce using rule 36 (local_decls -> local_decl_list .)
    {               reduce using rule 36 (local_decls -> local_decl_list .)
    ;               reduce using rule 36 (local_decls -> local_decl_list .)
    IDENT           reduce using rule 36 (local_decls -> local_decl_list .)
    MINUSMINUS      reduce using rule 36 (local_decls -> local_decl_list .)
    PLUSPLUS        reduce using rule 36 (local_decls -> local_decl_list .)
    NEW             reduce using rule 36 (local_decls -> local_decl_list .)
    STRING          reduce using rule 36 (local_decls -> local_decl_list .)
    FLOAT_LIT       reduce using rule 36 (local_decls -> local_decl_list .)
    INT_LIT         reduce using rule 36 (local_decls -> local_decl_list .)
    BOOL_LIT        reduce using rule 36 (local_decls -> local_decl_list .)
    CAST            reduce using rule 36 (local_decls -> local_decl_list .)
    INTTOFLOAT      reduce using rule 36 (local_decls -> local_decl_list .)
    (               reduce using rule 36 (local_decls -> local_decl_list .)
    +               reduce using rule 36 (local_decls -> local_decl_list .)
    -               reduce using rule 36 (local_decls -> local_decl_list .)
    !               reduce using rule 36 (local_decls -> local_decl_list .)
    SUPER           reduce using rule 36 (local_decls -> local_decl_list .)
    THIS            reduce using rule 36 (local_decls -> local_decl_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 170
    type_spec                      shift and go to state 137

state 136

    (37) local_decl_list -> local_decl .
    FLOAT           reduce using rule 37 (local_decl_list -> local_decl .)
    INT             reduce using rule 37 (local_decl_list -> local_decl .)
    BOOL            reduce using rule 37 (local_decl_list -> local_decl .)
    VOID            reduce using rule 37 (local_decl_list -> local_decl .)
    SPRINTF         reduce using rule 37 (local_decl_list -> local_decl .)
    SCANF           reduce using rule 37 (local_decl_list -> local_decl .)
    PRINTF          reduce using rule 37 (local_decl_list -> local_decl .)
    FOR             reduce using rule 37 (local_decl_list -> local_decl .)
    CONTINUE        reduce using rule 37 (local_decl_list -> local_decl .)
    BREAK           reduce using rule 37 (local_decl_list -> local_decl .)
    RETURN          reduce using rule 37 (local_decl_list -> local_decl .)
    WHILE           reduce using rule 37 (local_decl_list -> local_decl .)
    IF              reduce using rule 37 (local_decl_list -> local_decl .)
    {               reduce using rule 37 (local_decl_list -> local_decl .)
    ;               reduce using rule 37 (local_decl_list -> local_decl .)
    IDENT           reduce using rule 37 (local_decl_list -> local_decl .)
    MINUSMINUS      reduce using rule 37 (local_decl_list -> local_decl .)
    PLUSPLUS        reduce using rule 37 (local_decl_list -> local_decl .)
    NEW             reduce using rule 37 (local_decl_list -> local_decl .)
    STRING          reduce using rule 37 (local_decl_list -> local_decl .)
    FLOAT_LIT       reduce using rule 37 (local_decl_list -> local_decl .)
    INT_LIT         reduce using rule 37 (local_decl_list -> local_decl .)
    BOOL_LIT        reduce using rule 37 (local_decl_list -> local_decl .)
    CAST            reduce using rule 37 (local_decl_list -> local_decl .)
    INTTOFLOAT      reduce using rule 37 (local_decl_list -> local_decl .)
    (               reduce using rule 37 (local_decl_list -> local_decl .)
    +               reduce using rule 37 (local_decl_list -> local_decl .)
    -               reduce using rule 37 (local_decl_list -> local_decl .)
    !               reduce using rule 37 (local_decl_list -> local_decl .)
    SUPER           reduce using rule 37 (local_decl_list -> local_decl .)
    THIS            reduce using rule 37 (local_decl_list -> local_decl .)


state 137

    (39) local_decl -> type_spec . IDENT [ ] ;
    (40) local_decl -> type_spec . IDENT _4_0x3d_expr_optional ;
    IDENT           shift and go to state 171


state 138

    (102) expr -> expr POINT IDENT = . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 172

state 139

    (82) expr -> IDENT ( args ) .
    MINUSMINUS      reduce using rule 82 (expr -> IDENT ( args ) .)
    PLUSPLUS        reduce using rule 82 (expr -> IDENT ( args ) .)
    AND             reduce using rule 82 (expr -> IDENT ( args ) .)
    OR              reduce using rule 82 (expr -> IDENT ( args ) .)
    %               reduce using rule 82 (expr -> IDENT ( args ) .)
    /               reduce using rule 82 (expr -> IDENT ( args ) .)
    *               reduce using rule 82 (expr -> IDENT ( args ) .)
    -               reduce using rule 82 (expr -> IDENT ( args ) .)
    +               reduce using rule 82 (expr -> IDENT ( args ) .)
    >               reduce using rule 82 (expr -> IDENT ( args ) .)
    GE              reduce using rule 82 (expr -> IDENT ( args ) .)
    <               reduce using rule 82 (expr -> IDENT ( args ) .)
    LE              reduce using rule 82 (expr -> IDENT ( args ) .)
    NE              reduce using rule 82 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 82 (expr -> IDENT ( args ) .)
    POINT           reduce using rule 82 (expr -> IDENT ( args ) .)
    ;               reduce using rule 82 (expr -> IDENT ( args ) .)
    )               reduce using rule 82 (expr -> IDENT ( args ) .)
    ,               reduce using rule 82 (expr -> IDENT ( args ) .)
    ]               reduce using rule 82 (expr -> IDENT ( args ) .)


state 140

    (111) arg_list -> arg_list , . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 173

state 141

    (83) expr -> IDENT [ expr ] .
    (106) expr -> IDENT [ expr ] . = expr
    MINUSMINUS      reduce using rule 83 (expr -> IDENT [ expr ] .)
    PLUSPLUS        reduce using rule 83 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 83 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 83 (expr -> IDENT [ expr ] .)
    %               reduce using rule 83 (expr -> IDENT [ expr ] .)
    /               reduce using rule 83 (expr -> IDENT [ expr ] .)
    *               reduce using rule 83 (expr -> IDENT [ expr ] .)
    -               reduce using rule 83 (expr -> IDENT [ expr ] .)
    +               reduce using rule 83 (expr -> IDENT [ expr ] .)
    >               reduce using rule 83 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 83 (expr -> IDENT [ expr ] .)
    <               reduce using rule 83 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 83 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 83 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 83 (expr -> IDENT [ expr ] .)
    POINT           reduce using rule 83 (expr -> IDENT [ expr ] .)
    ;               reduce using rule 83 (expr -> IDENT [ expr ] .)
    )               reduce using rule 83 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 83 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 83 (expr -> IDENT [ expr ] .)
    =               shift and go to state 174


state 142

    (74) expr -> NEW type_spec [ expr . ]
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ]               shift and go to state 175
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 143

    (79) expr -> CAST type_spec ( expr . )
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 176
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 144

    (80) expr -> INTTOFLOAT ( IDENT ) .
    MINUSMINUS      reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    PLUSPLUS        reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    AND             reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    OR              reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    %               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    /               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    *               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    -               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    +               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    >               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    GE              reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    <               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    LE              reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    NE              reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    EQ              reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    POINT           reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    ;               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    )               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    ,               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)
    ]               reduce using rule 80 (expr -> INTTOFLOAT ( IDENT ) .)


state 145

    (14) method_decl -> type_spec IDENT ( _1_params_optional . ) compound_stmt
    )               shift and go to state 177


state 146

    (15) _1_params_optional -> params .
    )               reduce using rule 15 (_1_params_optional -> params .)


state 147

    (34) compound_stmt -> { local_decls stmt_list . }
    (44) stmt_list -> stmt_list . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    }               shift and go to state 178
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    stmt                           shift and go to state 179
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158
    expr                           shift and go to state 164

state 148

    (43) stmt_list -> stmt .
    }               reduce using rule 43 (stmt_list -> stmt .)
    SPRINTF         reduce using rule 43 (stmt_list -> stmt .)
    SCANF           reduce using rule 43 (stmt_list -> stmt .)
    PRINTF          reduce using rule 43 (stmt_list -> stmt .)
    FOR             reduce using rule 43 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 43 (stmt_list -> stmt .)
    BREAK           reduce using rule 43 (stmt_list -> stmt .)
    RETURN          reduce using rule 43 (stmt_list -> stmt .)
    WHILE           reduce using rule 43 (stmt_list -> stmt .)
    IF              reduce using rule 43 (stmt_list -> stmt .)
    {               reduce using rule 43 (stmt_list -> stmt .)
    ;               reduce using rule 43 (stmt_list -> stmt .)
    IDENT           reduce using rule 43 (stmt_list -> stmt .)
    MINUSMINUS      reduce using rule 43 (stmt_list -> stmt .)
    PLUSPLUS        reduce using rule 43 (stmt_list -> stmt .)
    NEW             reduce using rule 43 (stmt_list -> stmt .)
    STRING          reduce using rule 43 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 43 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 43 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 43 (stmt_list -> stmt .)
    CAST            reduce using rule 43 (stmt_list -> stmt .)
    INTTOFLOAT      reduce using rule 43 (stmt_list -> stmt .)
    (               reduce using rule 43 (stmt_list -> stmt .)
    +               reduce using rule 43 (stmt_list -> stmt .)
    -               reduce using rule 43 (stmt_list -> stmt .)
    !               reduce using rule 43 (stmt_list -> stmt .)
    SUPER           reduce using rule 43 (stmt_list -> stmt .)
    THIS            reduce using rule 43 (stmt_list -> stmt .)


state 149

    (45) stmt -> sprintf_stmt .
    }               reduce using rule 45 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 45 (stmt -> sprintf_stmt .)
    SCANF           reduce using rule 45 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 45 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 45 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 45 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 45 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 45 (stmt -> sprintf_stmt .)
    IF              reduce using rule 45 (stmt -> sprintf_stmt .)
    {               reduce using rule 45 (stmt -> sprintf_stmt .)
    ;               reduce using rule 45 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 45 (stmt -> sprintf_stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> sprintf_stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> sprintf_stmt .)
    NEW             reduce using rule 45 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 45 (stmt -> sprintf_stmt .)
    FLOAT_LIT       reduce using rule 45 (stmt -> sprintf_stmt .)
    INT_LIT         reduce using rule 45 (stmt -> sprintf_stmt .)
    BOOL_LIT        reduce using rule 45 (stmt -> sprintf_stmt .)
    CAST            reduce using rule 45 (stmt -> sprintf_stmt .)
    INTTOFLOAT      reduce using rule 45 (stmt -> sprintf_stmt .)
    (               reduce using rule 45 (stmt -> sprintf_stmt .)
    +               reduce using rule 45 (stmt -> sprintf_stmt .)
    -               reduce using rule 45 (stmt -> sprintf_stmt .)
    !               reduce using rule 45 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 45 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 45 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 45 (stmt -> sprintf_stmt .)


state 150

    (46) stmt -> scanf_stmt .
    }               reduce using rule 46 (stmt -> scanf_stmt .)
    SPRINTF         reduce using rule 46 (stmt -> scanf_stmt .)
    SCANF           reduce using rule 46 (stmt -> scanf_stmt .)
    PRINTF          reduce using rule 46 (stmt -> scanf_stmt .)
    FOR             reduce using rule 46 (stmt -> scanf_stmt .)
    CONTINUE        reduce using rule 46 (stmt -> scanf_stmt .)
    BREAK           reduce using rule 46 (stmt -> scanf_stmt .)
    RETURN          reduce using rule 46 (stmt -> scanf_stmt .)
    WHILE           reduce using rule 46 (stmt -> scanf_stmt .)
    IF              reduce using rule 46 (stmt -> scanf_stmt .)
    {               reduce using rule 46 (stmt -> scanf_stmt .)
    ;               reduce using rule 46 (stmt -> scanf_stmt .)
    IDENT           reduce using rule 46 (stmt -> scanf_stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> scanf_stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> scanf_stmt .)
    NEW             reduce using rule 46 (stmt -> scanf_stmt .)
    STRING          reduce using rule 46 (stmt -> scanf_stmt .)
    FLOAT_LIT       reduce using rule 46 (stmt -> scanf_stmt .)
    INT_LIT         reduce using rule 46 (stmt -> scanf_stmt .)
    BOOL_LIT        reduce using rule 46 (stmt -> scanf_stmt .)
    CAST            reduce using rule 46 (stmt -> scanf_stmt .)
    INTTOFLOAT      reduce using rule 46 (stmt -> scanf_stmt .)
    (               reduce using rule 46 (stmt -> scanf_stmt .)
    +               reduce using rule 46 (stmt -> scanf_stmt .)
    -               reduce using rule 46 (stmt -> scanf_stmt .)
    !               reduce using rule 46 (stmt -> scanf_stmt .)
    SUPER           reduce using rule 46 (stmt -> scanf_stmt .)
    THIS            reduce using rule 46 (stmt -> scanf_stmt .)
    ELSE            reduce using rule 46 (stmt -> scanf_stmt .)


state 151

    (47) stmt -> printf_stmt .
    }               reduce using rule 47 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 47 (stmt -> printf_stmt .)
    SCANF           reduce using rule 47 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 47 (stmt -> printf_stmt .)
    FOR             reduce using rule 47 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 47 (stmt -> printf_stmt .)
    BREAK           reduce using rule 47 (stmt -> printf_stmt .)
    RETURN          reduce using rule 47 (stmt -> printf_stmt .)
    WHILE           reduce using rule 47 (stmt -> printf_stmt .)
    IF              reduce using rule 47 (stmt -> printf_stmt .)
    {               reduce using rule 47 (stmt -> printf_stmt .)
    ;               reduce using rule 47 (stmt -> printf_stmt .)
    IDENT           reduce using rule 47 (stmt -> printf_stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> printf_stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> printf_stmt .)
    NEW             reduce using rule 47 (stmt -> printf_stmt .)
    STRING          reduce using rule 47 (stmt -> printf_stmt .)
    FLOAT_LIT       reduce using rule 47 (stmt -> printf_stmt .)
    INT_LIT         reduce using rule 47 (stmt -> printf_stmt .)
    BOOL_LIT        reduce using rule 47 (stmt -> printf_stmt .)
    CAST            reduce using rule 47 (stmt -> printf_stmt .)
    INTTOFLOAT      reduce using rule 47 (stmt -> printf_stmt .)
    (               reduce using rule 47 (stmt -> printf_stmt .)
    +               reduce using rule 47 (stmt -> printf_stmt .)
    -               reduce using rule 47 (stmt -> printf_stmt .)
    !               reduce using rule 47 (stmt -> printf_stmt .)
    SUPER           reduce using rule 47 (stmt -> printf_stmt .)
    THIS            reduce using rule 47 (stmt -> printf_stmt .)
    ELSE            reduce using rule 47 (stmt -> printf_stmt .)


state 152

    (48) stmt -> for_stmt .
    }               reduce using rule 48 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 48 (stmt -> for_stmt .)
    SCANF           reduce using rule 48 (stmt -> for_stmt .)
    PRINTF          reduce using rule 48 (stmt -> for_stmt .)
    FOR             reduce using rule 48 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 48 (stmt -> for_stmt .)
    BREAK           reduce using rule 48 (stmt -> for_stmt .)
    RETURN          reduce using rule 48 (stmt -> for_stmt .)
    WHILE           reduce using rule 48 (stmt -> for_stmt .)
    IF              reduce using rule 48 (stmt -> for_stmt .)
    {               reduce using rule 48 (stmt -> for_stmt .)
    ;               reduce using rule 48 (stmt -> for_stmt .)
    IDENT           reduce using rule 48 (stmt -> for_stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> for_stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> for_stmt .)
    NEW             reduce using rule 48 (stmt -> for_stmt .)
    STRING          reduce using rule 48 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 48 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 48 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 48 (stmt -> for_stmt .)
    CAST            reduce using rule 48 (stmt -> for_stmt .)
    INTTOFLOAT      reduce using rule 48 (stmt -> for_stmt .)
    (               reduce using rule 48 (stmt -> for_stmt .)
    +               reduce using rule 48 (stmt -> for_stmt .)
    -               reduce using rule 48 (stmt -> for_stmt .)
    !               reduce using rule 48 (stmt -> for_stmt .)
    SUPER           reduce using rule 48 (stmt -> for_stmt .)
    THIS            reduce using rule 48 (stmt -> for_stmt .)
    ELSE            reduce using rule 48 (stmt -> for_stmt .)


state 153

    (49) stmt -> break_stmt .
    }               reduce using rule 49 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 49 (stmt -> break_stmt .)
    SCANF           reduce using rule 49 (stmt -> break_stmt .)
    PRINTF          reduce using rule 49 (stmt -> break_stmt .)
    FOR             reduce using rule 49 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 49 (stmt -> break_stmt .)
    BREAK           reduce using rule 49 (stmt -> break_stmt .)
    RETURN          reduce using rule 49 (stmt -> break_stmt .)
    WHILE           reduce using rule 49 (stmt -> break_stmt .)
    IF              reduce using rule 49 (stmt -> break_stmt .)
    {               reduce using rule 49 (stmt -> break_stmt .)
    ;               reduce using rule 49 (stmt -> break_stmt .)
    IDENT           reduce using rule 49 (stmt -> break_stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> break_stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> break_stmt .)
    NEW             reduce using rule 49 (stmt -> break_stmt .)
    STRING          reduce using rule 49 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 49 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 49 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 49 (stmt -> break_stmt .)
    CAST            reduce using rule 49 (stmt -> break_stmt .)
    INTTOFLOAT      reduce using rule 49 (stmt -> break_stmt .)
    (               reduce using rule 49 (stmt -> break_stmt .)
    +               reduce using rule 49 (stmt -> break_stmt .)
    -               reduce using rule 49 (stmt -> break_stmt .)
    !               reduce using rule 49 (stmt -> break_stmt .)
    SUPER           reduce using rule 49 (stmt -> break_stmt .)
    THIS            reduce using rule 49 (stmt -> break_stmt .)
    ELSE            reduce using rule 49 (stmt -> break_stmt .)


state 154

    (50) stmt -> return_stmt .
    }               reduce using rule 50 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 50 (stmt -> return_stmt .)
    SCANF           reduce using rule 50 (stmt -> return_stmt .)
    PRINTF          reduce using rule 50 (stmt -> return_stmt .)
    FOR             reduce using rule 50 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 50 (stmt -> return_stmt .)
    BREAK           reduce using rule 50 (stmt -> return_stmt .)
    RETURN          reduce using rule 50 (stmt -> return_stmt .)
    WHILE           reduce using rule 50 (stmt -> return_stmt .)
    IF              reduce using rule 50 (stmt -> return_stmt .)
    {               reduce using rule 50 (stmt -> return_stmt .)
    ;               reduce using rule 50 (stmt -> return_stmt .)
    IDENT           reduce using rule 50 (stmt -> return_stmt .)
    MINUSMINUS      reduce using rule 50 (stmt -> return_stmt .)
    PLUSPLUS        reduce using rule 50 (stmt -> return_stmt .)
    NEW             reduce using rule 50 (stmt -> return_stmt .)
    STRING          reduce using rule 50 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 50 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 50 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 50 (stmt -> return_stmt .)
    CAST            reduce using rule 50 (stmt -> return_stmt .)
    INTTOFLOAT      reduce using rule 50 (stmt -> return_stmt .)
    (               reduce using rule 50 (stmt -> return_stmt .)
    +               reduce using rule 50 (stmt -> return_stmt .)
    -               reduce using rule 50 (stmt -> return_stmt .)
    !               reduce using rule 50 (stmt -> return_stmt .)
    SUPER           reduce using rule 50 (stmt -> return_stmt .)
    THIS            reduce using rule 50 (stmt -> return_stmt .)
    ELSE            reduce using rule 50 (stmt -> return_stmt .)


state 155

    (51) stmt -> while_stmt .
    }               reduce using rule 51 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 51 (stmt -> while_stmt .)
    SCANF           reduce using rule 51 (stmt -> while_stmt .)
    PRINTF          reduce using rule 51 (stmt -> while_stmt .)
    FOR             reduce using rule 51 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 51 (stmt -> while_stmt .)
    BREAK           reduce using rule 51 (stmt -> while_stmt .)
    RETURN          reduce using rule 51 (stmt -> while_stmt .)
    WHILE           reduce using rule 51 (stmt -> while_stmt .)
    IF              reduce using rule 51 (stmt -> while_stmt .)
    {               reduce using rule 51 (stmt -> while_stmt .)
    ;               reduce using rule 51 (stmt -> while_stmt .)
    IDENT           reduce using rule 51 (stmt -> while_stmt .)
    MINUSMINUS      reduce using rule 51 (stmt -> while_stmt .)
    PLUSPLUS        reduce using rule 51 (stmt -> while_stmt .)
    NEW             reduce using rule 51 (stmt -> while_stmt .)
    STRING          reduce using rule 51 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 51 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 51 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 51 (stmt -> while_stmt .)
    CAST            reduce using rule 51 (stmt -> while_stmt .)
    INTTOFLOAT      reduce using rule 51 (stmt -> while_stmt .)
    (               reduce using rule 51 (stmt -> while_stmt .)
    +               reduce using rule 51 (stmt -> while_stmt .)
    -               reduce using rule 51 (stmt -> while_stmt .)
    !               reduce using rule 51 (stmt -> while_stmt .)
    SUPER           reduce using rule 51 (stmt -> while_stmt .)
    THIS            reduce using rule 51 (stmt -> while_stmt .)
    ELSE            reduce using rule 51 (stmt -> while_stmt .)


state 156

    (52) stmt -> if_stmt .
    }               reduce using rule 52 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 52 (stmt -> if_stmt .)
    SCANF           reduce using rule 52 (stmt -> if_stmt .)
    PRINTF          reduce using rule 52 (stmt -> if_stmt .)
    FOR             reduce using rule 52 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 52 (stmt -> if_stmt .)
    BREAK           reduce using rule 52 (stmt -> if_stmt .)
    RETURN          reduce using rule 52 (stmt -> if_stmt .)
    WHILE           reduce using rule 52 (stmt -> if_stmt .)
    IF              reduce using rule 52 (stmt -> if_stmt .)
    {               reduce using rule 52 (stmt -> if_stmt .)
    ;               reduce using rule 52 (stmt -> if_stmt .)
    IDENT           reduce using rule 52 (stmt -> if_stmt .)
    MINUSMINUS      reduce using rule 52 (stmt -> if_stmt .)
    PLUSPLUS        reduce using rule 52 (stmt -> if_stmt .)
    NEW             reduce using rule 52 (stmt -> if_stmt .)
    STRING          reduce using rule 52 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 52 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 52 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 52 (stmt -> if_stmt .)
    CAST            reduce using rule 52 (stmt -> if_stmt .)
    INTTOFLOAT      reduce using rule 52 (stmt -> if_stmt .)
    (               reduce using rule 52 (stmt -> if_stmt .)
    +               reduce using rule 52 (stmt -> if_stmt .)
    -               reduce using rule 52 (stmt -> if_stmt .)
    !               reduce using rule 52 (stmt -> if_stmt .)
    SUPER           reduce using rule 52 (stmt -> if_stmt .)
    THIS            reduce using rule 52 (stmt -> if_stmt .)
    ELSE            reduce using rule 52 (stmt -> if_stmt .)


state 157

    (53) stmt -> compound_stmt .
    }               reduce using rule 53 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 53 (stmt -> compound_stmt .)
    SCANF           reduce using rule 53 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 53 (stmt -> compound_stmt .)
    FOR             reduce using rule 53 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 53 (stmt -> compound_stmt .)
    BREAK           reduce using rule 53 (stmt -> compound_stmt .)
    RETURN          reduce using rule 53 (stmt -> compound_stmt .)
    WHILE           reduce using rule 53 (stmt -> compound_stmt .)
    IF              reduce using rule 53 (stmt -> compound_stmt .)
    {               reduce using rule 53 (stmt -> compound_stmt .)
    ;               reduce using rule 53 (stmt -> compound_stmt .)
    IDENT           reduce using rule 53 (stmt -> compound_stmt .)
    MINUSMINUS      reduce using rule 53 (stmt -> compound_stmt .)
    PLUSPLUS        reduce using rule 53 (stmt -> compound_stmt .)
    NEW             reduce using rule 53 (stmt -> compound_stmt .)
    STRING          reduce using rule 53 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 53 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 53 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 53 (stmt -> compound_stmt .)
    CAST            reduce using rule 53 (stmt -> compound_stmt .)
    INTTOFLOAT      reduce using rule 53 (stmt -> compound_stmt .)
    (               reduce using rule 53 (stmt -> compound_stmt .)
    +               reduce using rule 53 (stmt -> compound_stmt .)
    -               reduce using rule 53 (stmt -> compound_stmt .)
    !               reduce using rule 53 (stmt -> compound_stmt .)
    SUPER           reduce using rule 53 (stmt -> compound_stmt .)
    THIS            reduce using rule 53 (stmt -> compound_stmt .)
    ELSE            reduce using rule 53 (stmt -> compound_stmt .)


state 158

    (54) stmt -> expr_stmt .
    }               reduce using rule 54 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 54 (stmt -> expr_stmt .)
    SCANF           reduce using rule 54 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 54 (stmt -> expr_stmt .)
    FOR             reduce using rule 54 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 54 (stmt -> expr_stmt .)
    BREAK           reduce using rule 54 (stmt -> expr_stmt .)
    RETURN          reduce using rule 54 (stmt -> expr_stmt .)
    WHILE           reduce using rule 54 (stmt -> expr_stmt .)
    IF              reduce using rule 54 (stmt -> expr_stmt .)
    {               reduce using rule 54 (stmt -> expr_stmt .)
    ;               reduce using rule 54 (stmt -> expr_stmt .)
    IDENT           reduce using rule 54 (stmt -> expr_stmt .)
    MINUSMINUS      reduce using rule 54 (stmt -> expr_stmt .)
    PLUSPLUS        reduce using rule 54 (stmt -> expr_stmt .)
    NEW             reduce using rule 54 (stmt -> expr_stmt .)
    STRING          reduce using rule 54 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 54 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 54 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 54 (stmt -> expr_stmt .)
    CAST            reduce using rule 54 (stmt -> expr_stmt .)
    INTTOFLOAT      reduce using rule 54 (stmt -> expr_stmt .)
    (               reduce using rule 54 (stmt -> expr_stmt .)
    +               reduce using rule 54 (stmt -> expr_stmt .)
    -               reduce using rule 54 (stmt -> expr_stmt .)
    !               reduce using rule 54 (stmt -> expr_stmt .)
    SUPER           reduce using rule 54 (stmt -> expr_stmt .)
    THIS            reduce using rule 54 (stmt -> expr_stmt .)
    ELSE            reduce using rule 54 (stmt -> expr_stmt .)


state 159

    (115) sprintf_stmt -> SPRINTF . ( IDENT , STRING , arg_list ) ;
    (               shift and go to state 180


state 160

    (55) expr_stmt -> ; .
    }               reduce using rule 55 (expr_stmt -> ; .)
    SPRINTF         reduce using rule 55 (expr_stmt -> ; .)
    SCANF           reduce using rule 55 (expr_stmt -> ; .)
    PRINTF          reduce using rule 55 (expr_stmt -> ; .)
    FOR             reduce using rule 55 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 55 (expr_stmt -> ; .)
    BREAK           reduce using rule 55 (expr_stmt -> ; .)
    RETURN          reduce using rule 55 (expr_stmt -> ; .)
    WHILE           reduce using rule 55 (expr_stmt -> ; .)
    IF              reduce using rule 55 (expr_stmt -> ; .)
    {               reduce using rule 55 (expr_stmt -> ; .)
    ;               reduce using rule 55 (expr_stmt -> ; .)
    IDENT           reduce using rule 55 (expr_stmt -> ; .)
    MINUSMINUS      reduce using rule 55 (expr_stmt -> ; .)
    PLUSPLUS        reduce using rule 55 (expr_stmt -> ; .)
    NEW             reduce using rule 55 (expr_stmt -> ; .)
    STRING          reduce using rule 55 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 55 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 55 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 55 (expr_stmt -> ; .)
    CAST            reduce using rule 55 (expr_stmt -> ; .)
    INTTOFLOAT      reduce using rule 55 (expr_stmt -> ; .)
    (               reduce using rule 55 (expr_stmt -> ; .)
    +               reduce using rule 55 (expr_stmt -> ; .)
    -               reduce using rule 55 (expr_stmt -> ; .)
    !               reduce using rule 55 (expr_stmt -> ; .)
    SUPER           reduce using rule 55 (expr_stmt -> ; .)
    THIS            reduce using rule 55 (expr_stmt -> ; .)
    ELSE            reduce using rule 55 (expr_stmt -> ; .)


state 161

    (114) scanf_stmt -> SCANF . ( STRING , arg_list ) ;
    (               shift and go to state 181


state 162

    (112) printf_stmt -> PRINTF . ( STRING , arg_list ) ;
    (113) printf_stmt -> PRINTF . ( STRING ) ;
    (               shift and go to state 182


state 163

    (58) for_stmt -> FOR . ( local_decl expr ; expr ) stmt
    (59) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 183


state 164

    (56) expr_stmt -> expr . ;
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               shift and go to state 184
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 165

    (64) break_stmt -> CONTINUE . ;
    ;               shift and go to state 185


state 166

    (65) break_stmt -> BREAK . ;
    ;               shift and go to state 186


state 167

    (62) return_stmt -> RETURN . expr ;
    (63) return_stmt -> RETURN . ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    ;               shift and go to state 188
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 187

state 168

    (57) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 189


state 169

    (60) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (61) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 190


state 170

    (38) local_decl_list -> local_decl_list local_decl .
    FLOAT           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    INT             reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    BOOL            reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    VOID            reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    SPRINTF         reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    SCANF           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    PRINTF          reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    FOR             reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    CONTINUE        reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    BREAK           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    RETURN          reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    WHILE           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    IF              reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    {               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    ;               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    IDENT           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    MINUSMINUS      reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    PLUSPLUS        reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    NEW             reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    STRING          reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    FLOAT_LIT       reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    INT_LIT         reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    BOOL_LIT        reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    CAST            reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    INTTOFLOAT      reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    (               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    +               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    -               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    !               reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    SUPER           reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)
    THIS            reduce using rule 38 (local_decl_list -> local_decl_list local_decl .)


state 171

    (39) local_decl -> type_spec IDENT . [ ] ;
    (40) local_decl -> type_spec IDENT . _4_0x3d_expr_optional ;
    (41) _4_0x3d_expr_optional -> . = expr
    (42) _4_0x3d_expr_optional -> .
    [               shift and go to state 191
    =               shift and go to state 193
    ;               reduce using rule 42 (_4_0x3d_expr_optional -> .)

    _4_0x3d_expr_optional          shift and go to state 192

state 172

    (102) expr -> expr POINT IDENT = expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    PLUSPLUS        reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    POINT           reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    ;               reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    )               reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    ,               reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    ]               reduce using rule 102 (expr -> expr POINT IDENT = expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 173

    (111) arg_list -> arg_list , expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ,               reduce using rule 111 (arg_list -> arg_list , expr .)
    )               reduce using rule 111 (arg_list -> arg_list , expr .)
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 174

    (106) expr -> IDENT [ expr ] = . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 194

state 175

    (74) expr -> NEW type_spec [ expr ] .
    MINUSMINUS      reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    PLUSPLUS        reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    POINT           reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    ;               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 74 (expr -> NEW type_spec [ expr ] .)


state 176

    (79) expr -> CAST type_spec ( expr ) .
    MINUSMINUS      reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    PLUSPLUS        reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    AND             reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    OR              reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    %               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    /               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    *               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    -               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    +               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    >               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    GE              reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    <               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    LE              reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    NE              reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    EQ              reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    POINT           reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    ;               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    )               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    ,               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)
    ]               reduce using rule 79 (expr -> CAST type_spec ( expr ) .)


state 177

    (14) method_decl -> type_spec IDENT ( _1_params_optional ) . compound_stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 98

    compound_stmt                  shift and go to state 195

state 178

    (34) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    MINUSMINUS      reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    PLUSPLUS        reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    CAST            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    INTTOFLOAT      reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 34 (compound_stmt -> { local_decls stmt_list } .)


state 179

    (44) stmt_list -> stmt_list stmt .
    }               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    SPRINTF         reduce using rule 44 (stmt_list -> stmt_list stmt .)
    SCANF           reduce using rule 44 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 44 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 44 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 44 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 44 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 44 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 44 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 44 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 44 (stmt_list -> stmt_list stmt .)
    MINUSMINUS      reduce using rule 44 (stmt_list -> stmt_list stmt .)
    PLUSPLUS        reduce using rule 44 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 44 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 44 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 44 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 44 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 44 (stmt_list -> stmt_list stmt .)
    CAST            reduce using rule 44 (stmt_list -> stmt_list stmt .)
    INTTOFLOAT      reduce using rule 44 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 44 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 44 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 44 (stmt_list -> stmt_list stmt .)


state 180

    (115) sprintf_stmt -> SPRINTF ( . IDENT , STRING , arg_list ) ;
    IDENT           shift and go to state 196


state 181

    (114) scanf_stmt -> SCANF ( . STRING , arg_list ) ;
    STRING          shift and go to state 197


state 182

    (112) printf_stmt -> PRINTF ( . STRING , arg_list ) ;
    (113) printf_stmt -> PRINTF ( . STRING ) ;
    STRING          shift and go to state 198


state 183

    (58) for_stmt -> FOR ( . local_decl expr ; expr ) stmt
    (59) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (39) local_decl -> . type_spec IDENT [ ] ;
    (40) local_decl -> . type_spec IDENT _4_0x3d_expr_optional ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    (21) type_spec -> . FLOAT
    (22) type_spec -> . INT
    (23) type_spec -> . BOOL
    (24) type_spec -> . VOID
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 199
    expr                           shift and go to state 200
    type_spec                      shift and go to state 137

state 184

    (56) expr_stmt -> expr ; .
    }               reduce using rule 56 (expr_stmt -> expr ; .)
    SPRINTF         reduce using rule 56 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 56 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 56 (expr_stmt -> expr ; .)
    FOR             reduce using rule 56 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 56 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 56 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 56 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 56 (expr_stmt -> expr ; .)
    IF              reduce using rule 56 (expr_stmt -> expr ; .)
    {               reduce using rule 56 (expr_stmt -> expr ; .)
    ;               reduce using rule 56 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 56 (expr_stmt -> expr ; .)
    MINUSMINUS      reduce using rule 56 (expr_stmt -> expr ; .)
    PLUSPLUS        reduce using rule 56 (expr_stmt -> expr ; .)
    NEW             reduce using rule 56 (expr_stmt -> expr ; .)
    STRING          reduce using rule 56 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 56 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 56 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 56 (expr_stmt -> expr ; .)
    CAST            reduce using rule 56 (expr_stmt -> expr ; .)
    INTTOFLOAT      reduce using rule 56 (expr_stmt -> expr ; .)
    (               reduce using rule 56 (expr_stmt -> expr ; .)
    +               reduce using rule 56 (expr_stmt -> expr ; .)
    -               reduce using rule 56 (expr_stmt -> expr ; .)
    !               reduce using rule 56 (expr_stmt -> expr ; .)
    SUPER           reduce using rule 56 (expr_stmt -> expr ; .)
    THIS            reduce using rule 56 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 56 (expr_stmt -> expr ; .)


state 185

    (64) break_stmt -> CONTINUE ; .
    }               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 64 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 64 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 64 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 64 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 64 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 64 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 64 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 64 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 64 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 64 (break_stmt -> CONTINUE ; .)
    MINUSMINUS      reduce using rule 64 (break_stmt -> CONTINUE ; .)
    PLUSPLUS        reduce using rule 64 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 64 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 64 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 64 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 64 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 64 (break_stmt -> CONTINUE ; .)
    CAST            reduce using rule 64 (break_stmt -> CONTINUE ; .)
    INTTOFLOAT      reduce using rule 64 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 64 (break_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 64 (break_stmt -> CONTINUE ; .)
    THIS            reduce using rule 64 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 64 (break_stmt -> CONTINUE ; .)


state 186

    (65) break_stmt -> BREAK ; .
    }               reduce using rule 65 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 65 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 65 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 65 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 65 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 65 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 65 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 65 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 65 (break_stmt -> BREAK ; .)
    IF              reduce using rule 65 (break_stmt -> BREAK ; .)
    {               reduce using rule 65 (break_stmt -> BREAK ; .)
    ;               reduce using rule 65 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 65 (break_stmt -> BREAK ; .)
    MINUSMINUS      reduce using rule 65 (break_stmt -> BREAK ; .)
    PLUSPLUS        reduce using rule 65 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 65 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 65 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 65 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 65 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 65 (break_stmt -> BREAK ; .)
    CAST            reduce using rule 65 (break_stmt -> BREAK ; .)
    INTTOFLOAT      reduce using rule 65 (break_stmt -> BREAK ; .)
    (               reduce using rule 65 (break_stmt -> BREAK ; .)
    +               reduce using rule 65 (break_stmt -> BREAK ; .)
    -               reduce using rule 65 (break_stmt -> BREAK ; .)
    !               reduce using rule 65 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 65 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 65 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 65 (break_stmt -> BREAK ; .)


state 187

    (62) return_stmt -> RETURN expr . ;
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               shift and go to state 201
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 188

    (63) return_stmt -> RETURN ; .
    }               reduce using rule 63 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 63 (return_stmt -> RETURN ; .)
    SCANF           reduce using rule 63 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 63 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 63 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 63 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 63 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 63 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 63 (return_stmt -> RETURN ; .)
    IF              reduce using rule 63 (return_stmt -> RETURN ; .)
    {               reduce using rule 63 (return_stmt -> RETURN ; .)
    ;               reduce using rule 63 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 63 (return_stmt -> RETURN ; .)
    MINUSMINUS      reduce using rule 63 (return_stmt -> RETURN ; .)
    PLUSPLUS        reduce using rule 63 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 63 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 63 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 63 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 63 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 63 (return_stmt -> RETURN ; .)
    CAST            reduce using rule 63 (return_stmt -> RETURN ; .)
    INTTOFLOAT      reduce using rule 63 (return_stmt -> RETURN ; .)
    (               reduce using rule 63 (return_stmt -> RETURN ; .)
    +               reduce using rule 63 (return_stmt -> RETURN ; .)
    -               reduce using rule 63 (return_stmt -> RETURN ; .)
    !               reduce using rule 63 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 63 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 63 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 63 (return_stmt -> RETURN ; .)


state 189

    (57) while_stmt -> WHILE ( . expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 202

state 190

    (60) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (61) if_stmt -> IF ( . expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 203

state 191

    (39) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 204


state 192

    (40) local_decl -> type_spec IDENT _4_0x3d_expr_optional . ;
    ;               shift and go to state 205


state 193

    (41) _4_0x3d_expr_optional -> = . expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 206

state 194

    (106) expr -> IDENT [ expr ] = expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    MINUSMINUS      reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    PLUSPLUS        reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    POINT           reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    ;               reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 106 (expr -> IDENT [ expr ] = expr .)
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73


state 195

    (14) method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .
    FLOAT           reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    INT             reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    BOOL            reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    VOID            reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    }               reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)


state 196

    (115) sprintf_stmt -> SPRINTF ( IDENT . , STRING , arg_list ) ;
    ,               shift and go to state 207


state 197

    (114) scanf_stmt -> SCANF ( STRING . , arg_list ) ;
    ,               shift and go to state 208


state 198

    (112) printf_stmt -> PRINTF ( STRING . , arg_list ) ;
    (113) printf_stmt -> PRINTF ( STRING . ) ;
    ,               shift and go to state 209
    )               shift and go to state 210


state 199

    (58) for_stmt -> FOR ( local_decl . expr ; expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 211

state 200

    (59) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               shift and go to state 212
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 201

    (62) return_stmt -> RETURN expr ; .
    }               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 62 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 62 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 62 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 62 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 62 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 62 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 62 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 62 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 62 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 62 (return_stmt -> RETURN expr ; .)
    MINUSMINUS      reduce using rule 62 (return_stmt -> RETURN expr ; .)
    PLUSPLUS        reduce using rule 62 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 62 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 62 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 62 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 62 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 62 (return_stmt -> RETURN expr ; .)
    CAST            reduce using rule 62 (return_stmt -> RETURN expr ; .)
    INTTOFLOAT      reduce using rule 62 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 62 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 62 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 62 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 62 (return_stmt -> RETURN expr ; .)


state 202

    (57) while_stmt -> WHILE ( expr . ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 213
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 203

    (60) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (61) if_stmt -> IF ( expr . ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 214
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 204

    (39) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 215


state 205

    (40) local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .
    FLOAT           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    INT             reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    BOOL            reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    VOID            reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    SPRINTF         reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    SCANF           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    PRINTF          reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    FOR             reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    CONTINUE        reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    BREAK           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    RETURN          reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    WHILE           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    IF              reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    {               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    ;               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    IDENT           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    MINUSMINUS      reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    PLUSPLUS        reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    NEW             reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    STRING          reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    FLOAT_LIT       reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    INT_LIT         reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    BOOL_LIT        reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    CAST            reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    INTTOFLOAT      reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    (               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    +               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    -               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    !               reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    SUPER           reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)
    THIS            reduce using rule 40 (local_decl -> type_spec IDENT _4_0x3d_expr_optional ; .)


state 206

    (41) _4_0x3d_expr_optional -> = expr .
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               reduce using rule 41 (_4_0x3d_expr_optional -> = expr .)
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 207

    (115) sprintf_stmt -> SPRINTF ( IDENT , . STRING , arg_list ) ;
    STRING          shift and go to state 216


state 208

    (114) scanf_stmt -> SCANF ( STRING , . arg_list ) ;
    (110) arg_list -> . expr
    (111) arg_list -> . arg_list , expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    arg_list                       shift and go to state 217
    expr                           shift and go to state 122

state 209

    (112) printf_stmt -> PRINTF ( STRING , . arg_list ) ;
    (110) arg_list -> . expr
    (111) arg_list -> . arg_list , expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    arg_list                       shift and go to state 218
    expr                           shift and go to state 122

state 210

    (113) printf_stmt -> PRINTF ( STRING ) . ;
    ;               shift and go to state 219


state 211

    (58) for_stmt -> FOR ( local_decl expr . ; expr ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               shift and go to state 220
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 212

    (59) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 221

state 213

    (57) while_stmt -> WHILE ( expr ) . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 164
    stmt                           shift and go to state 222
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158

state 214

    (60) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (61) if_stmt -> IF ( expr ) . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 164
    stmt                           shift and go to state 223
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158

state 215

    (39) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    SPRINTF         reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    SCANF           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    PRINTF          reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    MINUSMINUS      reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    PLUSPLUS        reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    CAST            reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    INTTOFLOAT      reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    SUPER           reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)
    THIS            reduce using rule 39 (local_decl -> type_spec IDENT [ ] ; .)


state 216

    (115) sprintf_stmt -> SPRINTF ( IDENT , STRING . , arg_list ) ;
    ,               shift and go to state 224


state 217

    (114) scanf_stmt -> SCANF ( STRING , arg_list . ) ;
    (111) arg_list -> arg_list . , expr
    )               shift and go to state 225
    ,               shift and go to state 140


state 218

    (112) printf_stmt -> PRINTF ( STRING , arg_list . ) ;
    (111) arg_list -> arg_list . , expr
    )               shift and go to state 226
    ,               shift and go to state 140


state 219

    (113) printf_stmt -> PRINTF ( STRING ) ; .
    }               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    SPRINTF         reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    SCANF           reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    CONTINUE        reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    BREAK           reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    WHILE           reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    {               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    ;               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    IDENT           reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    MINUSMINUS      reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    PLUSPLUS        reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    NEW             reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    STRING          reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    FLOAT_LIT       reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    INT_LIT         reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    BOOL_LIT        reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    CAST            reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    INTTOFLOAT      reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    (               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    +               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    -               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    !               reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    SUPER           reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    THIS            reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)
    ELSE            reduce using rule 113 (printf_stmt -> PRINTF ( STRING ) ; .)


state 220

    (58) for_stmt -> FOR ( local_decl expr ; . expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 227

state 221

    (59) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    ;               shift and go to state 228
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 222

    (57) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    MINUSMINUS      reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    PLUSPLUS        reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    CAST            reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    INTTOFLOAT      reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 57 (while_stmt -> WHILE ( expr ) stmt .)


state 223

    (60) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (61) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 229
    }               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    MINUSMINUS      reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    PLUSPLUS        reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    CAST            reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    INTTOFLOAT      reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 61 (if_stmt -> IF ( expr ) stmt .)


state 224

    (115) sprintf_stmt -> SPRINTF ( IDENT , STRING , . arg_list ) ;
    (110) arg_list -> . expr
    (111) arg_list -> . arg_list , expr
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    arg_list                       shift and go to state 230
    expr                           shift and go to state 122

state 225

    (114) scanf_stmt -> SCANF ( STRING , arg_list ) . ;
    ;               shift and go to state 231


state 226

    (112) printf_stmt -> PRINTF ( STRING , arg_list ) . ;
    ;               shift and go to state 232


state 227

    (58) for_stmt -> FOR ( local_decl expr ; expr . ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 233
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 228

    (59) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 234

state 229

    (60) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 164
    stmt                           shift and go to state 235
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158

state 230

    (115) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list . ) ;
    (111) arg_list -> arg_list . , expr
    )               shift and go to state 236
    ,               shift and go to state 140


state 231

    (114) scanf_stmt -> SCANF ( STRING , arg_list ) ; .
    }               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IF              reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    {               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ;               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CAST            reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    (               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    +               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    -               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    !               reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 114 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)


state 232

    (112) printf_stmt -> PRINTF ( STRING , arg_list ) ; .
    }               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IF              reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    {               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ;               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CAST            reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    (               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    +               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    -               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    !               reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 112 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)


state 233

    (58) for_stmt -> FOR ( local_decl expr ; expr ) . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 164
    stmt                           shift and go to state 237
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158

state 234

    (59) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (72) expr -> expr . MINUSMINUS
    (73) expr -> expr . PLUSPLUS
    (89) expr -> expr . AND expr
    (90) expr -> expr . OR expr
    (91) expr -> expr . % expr
    (92) expr -> expr . / expr
    (93) expr -> expr . * expr
    (94) expr -> expr . - expr
    (95) expr -> expr . + expr
    (96) expr -> expr . > expr
    (97) expr -> expr . GE expr
    (98) expr -> expr . < expr
    (99) expr -> expr . LE expr
    (100) expr -> expr . NE expr
    (101) expr -> expr . EQ expr
    (102) expr -> expr . POINT IDENT = expr
    (103) expr -> expr . POINT IDENT
    )               shift and go to state 238
    MINUSMINUS      shift and go to state 59
    PLUSPLUS        shift and go to state 60
    AND             shift and go to state 61
    OR              shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    >               shift and go to state 68
    GE              shift and go to state 69
    <               shift and go to state 70
    LE              shift and go to state 71
    NE              shift and go to state 72
    EQ              shift and go to state 73
    POINT           shift and go to state 74


state 235

    (60) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CAST            reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTTOFLOAT      reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 60 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 236

    (115) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) . ;
    ;               shift and go to state 239


state 237

    (58) for_stmt -> FOR ( local_decl expr ; expr ) stmt .
    }               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    SPRINTF         reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    SCANF           reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    PRINTF          reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    FOR             reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    CONTINUE        reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    BREAK           reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    RETURN          reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    WHILE           reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    IF              reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    {               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    ;               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    IDENT           reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    NEW             reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    STRING          reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    INT_LIT         reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    CAST            reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    INTTOFLOAT      reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    (               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    +               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    -               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    !               reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    SUPER           reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    THIS            reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)
    ELSE            reduce using rule 58 (for_stmt -> FOR ( local_decl expr ; expr ) stmt .)


state 238

    (59) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (45) stmt -> . sprintf_stmt
    (46) stmt -> . scanf_stmt
    (47) stmt -> . printf_stmt
    (48) stmt -> . for_stmt
    (49) stmt -> . break_stmt
    (50) stmt -> . return_stmt
    (51) stmt -> . while_stmt
    (52) stmt -> . if_stmt
    (53) stmt -> . compound_stmt
    (54) stmt -> . expr_stmt
    (115) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (114) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (112) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (113) printf_stmt -> . PRINTF ( STRING ) ;
    (58) for_stmt -> . FOR ( local_decl expr ; expr ) stmt
    (59) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (64) break_stmt -> . CONTINUE ;
    (65) break_stmt -> . BREAK ;
    (62) return_stmt -> . RETURN expr ;
    (63) return_stmt -> . RETURN ;
    (57) while_stmt -> . WHILE ( expr ) stmt
    (60) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (61) if_stmt -> . IF ( expr ) stmt
    (34) compound_stmt -> . { local_decls stmt_list }
    (55) expr_stmt -> . ;
    (56) expr_stmt -> . expr ;
    (66) expr -> . IDENT DIVEQ expr
    (67) expr -> . IDENT MULEQ expr
    (68) expr -> . IDENT MINUSEQ expr
    (69) expr -> . IDENT PLUSEQ expr
    (70) expr -> . MINUSMINUS expr
    (71) expr -> . PLUSPLUS expr
    (72) expr -> . expr MINUSMINUS
    (73) expr -> . expr PLUSPLUS
    (74) expr -> . NEW type_spec [ expr ]
    (75) expr -> . STRING
    (76) expr -> . FLOAT_LIT
    (77) expr -> . INT_LIT
    (78) expr -> . BOOL_LIT
    (79) expr -> . CAST type_spec ( expr )
    (80) expr -> . INTTOFLOAT ( IDENT )
    (81) expr -> . IDENT . SIZE
    (82) expr -> . IDENT ( args )
    (83) expr -> . IDENT [ expr ]
    (84) expr -> . IDENT
    (85) expr -> . ( expr )
    (86) expr -> . + expr
    (87) expr -> . - expr
    (88) expr -> . ! expr
    (89) expr -> . expr AND expr
    (90) expr -> . expr OR expr
    (91) expr -> . expr % expr
    (92) expr -> . expr / expr
    (93) expr -> . expr * expr
    (94) expr -> . expr - expr
    (95) expr -> . expr + expr
    (96) expr -> . expr > expr
    (97) expr -> . expr GE expr
    (98) expr -> . expr < expr
    (99) expr -> . expr LE expr
    (100) expr -> . expr NE expr
    (101) expr -> . expr EQ expr
    (102) expr -> . expr POINT IDENT = expr
    (103) expr -> . expr POINT IDENT
    (104) expr -> . SUPER POINT IDENT
    (105) expr -> . THIS
    (106) expr -> . IDENT [ expr ] = expr
    (107) expr -> . IDENT = expr
    SPRINTF         shift and go to state 159
    SCANF           shift and go to state 161
    PRINTF          shift and go to state 162
    FOR             shift and go to state 163
    CONTINUE        shift and go to state 165
    BREAK           shift and go to state 166
    RETURN          shift and go to state 167
    WHILE           shift and go to state 168
    IF              shift and go to state 169
    {               shift and go to state 98
    ;               shift and go to state 160
    IDENT           shift and go to state 34
    MINUSMINUS      shift and go to state 35
    PLUSPLUS        shift and go to state 36
    NEW             shift and go to state 37
    STRING          shift and go to state 38
    FLOAT_LIT       shift and go to state 39
    INT_LIT         shift and go to state 40
    BOOL_LIT        shift and go to state 41
    CAST            shift and go to state 42
    INTTOFLOAT      shift and go to state 44
    (               shift and go to state 43
    +               shift and go to state 45
    -               shift and go to state 46
    !               shift and go to state 47
    SUPER           shift and go to state 48
    THIS            shift and go to state 49

    expr                           shift and go to state 164
    stmt                           shift and go to state 240
    sprintf_stmt                   shift and go to state 149
    scanf_stmt                     shift and go to state 150
    printf_stmt                    shift and go to state 151
    for_stmt                       shift and go to state 152
    break_stmt                     shift and go to state 153
    return_stmt                    shift and go to state 154
    while_stmt                     shift and go to state 155
    if_stmt                        shift and go to state 156
    compound_stmt                  shift and go to state 157
    expr_stmt                      shift and go to state 158

state 239

    (115) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .
    }               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SCANF           reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PRINTF          reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FOR             reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BREAK           reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    RETURN          reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    WHILE           reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IF              reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    {               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ;               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IDENT           reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    NEW             reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    STRING          reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CAST            reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    (               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    +               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    -               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    !               reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SUPER           reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    THIS            reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ELSE            reduce using rule 115 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)


state 240

    (59) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    }               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SPRINTF         reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CONTINUE        reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING          reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CAST            reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INTTOFLOAT      reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SUPER           reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    THIS            reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 59 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
