Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     class_decl -> CLASS IDENT sclass_opt { class_body } ;
Rule 8     sclass_opt -> : IDENT
Rule 9     sclass_opt -> empty
Rule 10    class_body -> class_member_list
Rule 11    class_member_list -> class_member
Rule 12    class_member_list -> class_member_list class_member
Rule 13    class_member -> method_decl
Rule 14    method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt
Rule 15    _1_params_optional -> params
Rule 16    _1_params_optional -> <empty>
Rule 17    var_decl -> type_spec IDENT [ ] ;
Rule 18    var_decl -> type_spec IDENT ;
Rule 19    type_spec -> FLOAT
Rule 20    type_spec -> INT
Rule 21    type_spec -> BOOL
Rule 22    type_spec -> VOID
Rule 23    func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt
Rule 24    _2_params_optional -> params
Rule 25    _2_params_optional -> <empty>
Rule 26    params -> VOID
Rule 27    params -> param_list
Rule 28    param_list -> param
Rule 29    param_list -> param_list , param
Rule 30    param -> type_spec IDENT [ ]
Rule 31    param -> type_spec IDENT
Rule 32    compound_stmt -> { local_decls stmt_list }
Rule 33    local_decls -> empty
Rule 34    local_decls -> local_decl_list
Rule 35    local_decl_list -> local_decl
Rule 36    local_decl_list -> local_decl_list local_decl
Rule 37    local_decl -> type_spec IDENT [ ] ;
Rule 38    local_decl -> type_spec IDENT ;
Rule 39    stmt_list -> stmt
Rule 40    stmt_list -> stmt_list stmt
Rule 41    stmt -> sprintf_stmt
Rule 42    stmt -> scanf_stmt
Rule 43    stmt -> printf_stmt
Rule 44    stmt -> for_stmt
Rule 45    stmt -> break_stmt
Rule 46    stmt -> return_stmt
Rule 47    stmt -> while_stmt
Rule 48    stmt -> if_stmt
Rule 49    stmt -> compound_stmt
Rule 50    stmt -> expr_stmt
Rule 51    expr_stmt -> ;
Rule 52    expr_stmt -> expr ;
Rule 53    while_stmt -> WHILE ( expr ) stmt
Rule 54    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 55    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=5]
Rule 56    if_stmt -> IF ( expr ) stmt  [precedence=left, level=4]
Rule 57    return_stmt -> RETURN expr ;
Rule 58    return_stmt -> RETURN ;
Rule 59    break_stmt -> CONTINUE ;
Rule 60    break_stmt -> BREAK ;
Rule 61    expr -> IDENT DIVEQ expr  [precedence=right, level=9]
Rule 62    expr -> IDENT MULEQ expr  [precedence=right, level=8]
Rule 63    expr -> IDENT MINUSEQ expr  [precedence=right, level=7]
Rule 64    expr -> IDENT PLUSEQ expr  [precedence=right, level=6]
Rule 65    expr -> MINUSMINUS expr  [precedence=left, level=2]
Rule 66    expr -> PLUSPLUS expr  [precedence=left, level=1]
Rule 67    expr -> expr MINUSMINUS  [precedence=left, level=2]
Rule 68    expr -> expr PLUSPLUS  [precedence=left, level=1]
Rule 69    expr -> NEW type_spec [ expr ]
Rule 70    expr -> STRING
Rule 71    expr -> FLOAT_LIT
Rule 72    expr -> INT_LIT
Rule 73    expr -> BOOL_LIT
Rule 74    expr -> CAST type_spec ( expr )
Rule 75    expr -> INTTOFLOAT ( IDENT )
Rule 76    expr -> IDENT . SIZE
Rule 77    expr -> IDENT ( args )
Rule 78    expr -> IDENT [ expr ]
Rule 79    expr -> IDENT
Rule 80    expr -> ( expr )
Rule 81    expr -> + expr  [precedence=right, level=17]
Rule 82    expr -> - expr  [precedence=right, level=17]
Rule 83    expr -> ! expr  [precedence=right, level=17]
Rule 84    expr -> expr AND expr  [precedence=left, level=12]
Rule 85    expr -> expr OR expr  [precedence=left, level=11]
Rule 86    expr -> expr % expr  [precedence=left, level=16]
Rule 87    expr -> expr / expr  [precedence=left, level=16]
Rule 88    expr -> expr * expr  [precedence=left, level=16]
Rule 89    expr -> expr - expr  [precedence=left, level=15]
Rule 90    expr -> expr + expr  [precedence=left, level=15]
Rule 91    expr -> expr > expr  [precedence=left, level=14]
Rule 92    expr -> expr GE expr  [precedence=left, level=14]
Rule 93    expr -> expr < expr  [precedence=left, level=14]
Rule 94    expr -> expr LE expr  [precedence=left, level=14]
Rule 95    expr -> expr NE expr  [precedence=left, level=13]
Rule 96    expr -> expr EQ expr  [precedence=left, level=13]
Rule 97    expr -> expr POINT IDENT = expr  [precedence=right, level=10]
Rule 98    expr -> expr POINT IDENT
Rule 99    expr -> SUPER POINT IDENT
Rule 100   expr -> THIS
Rule 101   expr -> IDENT [ expr ] = expr  [precedence=right, level=10]
Rule 102   expr -> IDENT = expr  [precedence=right, level=10]
Rule 103   args -> empty
Rule 104   args -> arg_list
Rule 105   arg_list -> expr
Rule 106   arg_list -> arg_list , expr
Rule 107   printf_stmt -> PRINTF ( STRING , arg_list ) ;
Rule 108   printf_stmt -> PRINTF ( STRING ) ;
Rule 109   scanf_stmt -> SCANF ( STRING , arg_list ) ;
Rule 110   sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ;
Rule 111   empty -> <empty>

Terminals, with rules where they appear:

!                    : 83
%                    : 86
(                    : 14 23 53 54 55 56 74 75 77 80 107 108 109 110
)                    : 14 23 53 54 55 56 74 75 77 80 107 108 109 110
*                    : 88
+                    : 81 90
,                    : 29 106 107 109 110 110
-                    : 82 89
.                    : 76
/                    : 87
:                    : 8
;                    : 7 17 18 37 38 51 52 54 54 57 58 59 60 107 108 109 110
<                    : 93
=                    : 97 101 102
>                    : 91
AND                  : 84
BOOL                 : 21
BOOL_LIT             : 73
BREAK                : 60
CAST                 : 74
CLASS                : 7
CONTINUE             : 59
DIVEQ                : 61
ELSE                 : 55
EQ                   : 96
FLOAT                : 19
FLOAT_LIT            : 71
FOR                  : 54
GE                   : 92
IDENT                : 7 8 14 17 18 23 30 31 37 38 61 62 63 64 75 76 77 78 79 97 98 99 101 102 110
IF                   : 55 56
INT                  : 20
INTTOFLOAT           : 75
INT_LIT              : 72
LE                   : 94
MINUSEQ              : 63
MINUSMINUS           : 65 67
MULEQ                : 62
NE                   : 95
NEW                  : 69
OR                   : 85
PLUSEQ               : 64
PLUSPLUS             : 66 68
POINT                : 97 98 99
PRINTF               : 107 108
RETURN               : 57 58
SCANF                : 109
SIZE                 : 76
SPRINTF              : 110
STRING               : 70 107 108 109 110
SUPER                : 99
THIS                 : 100
VOID                 : 22 26
WHILE                : 53
[                    : 17 30 37 69 78 101
]                    : 17 30 37 69 78 101
error                : 
{                    : 7 32
}                    : 7 32

Nonterminals, with rules where they appear:

_1_params_optional   : 14
_2_params_optional   : 23
arg_list             : 104 106 107 109 110
args                 : 77
break_stmt           : 45
class_body           : 7
class_decl           : 4
class_member         : 11 12
class_member_list    : 10 12
compound_stmt        : 14 23 49
decl                 : 2 3
decl_list            : 1 3
empty                : 9 33 103
expr                 : 52 53 54 54 54 55 56 57 61 62 63 64 65 66 67 68 69 74 78 80 81 82 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 101 101 102 105 106
expr_stmt            : 50
for_stmt             : 44
func_decl            : 5
if_stmt              : 48
local_decl           : 35 36
local_decl_list      : 34 36
local_decls          : 32
method_decl          : 13
param                : 28 29
param_list           : 27 29
params               : 15 24
printf_stmt          : 43
program              : 0
return_stmt          : 46
scanf_stmt           : 42
sclass_opt           : 7
sprintf_stmt         : 41
stmt                 : 39 40 53 54 55 55 56
stmt_list            : 32 40
type_spec            : 14 17 18 23 30 31 37 38 69 74
var_decl             : 6
while_stmt           : 47


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT sclass_opt { class_body } ;
    (23) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (17) var_decl -> . type_spec IDENT [ ] ;
    (18) var_decl -> . type_spec IDENT ;
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT sclass_opt { class_body } ;
    (23) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (17) var_decl -> . type_spec IDENT [ ] ;
    (18) var_decl -> . type_spec IDENT ;
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) class_decl -> CLASS . IDENT sclass_opt { class_body } ;
    IDENT           shift and go to state 14


state 8

    (23) func_decl -> type_spec . IDENT ( _2_params_optional ) compound_stmt
    (17) var_decl -> type_spec . IDENT [ ] ;
    (18) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 15


state 9

    (19) type_spec -> FLOAT .
    IDENT           reduce using rule 19 (type_spec -> FLOAT .)
    [               reduce using rule 19 (type_spec -> FLOAT .)
    (               reduce using rule 19 (type_spec -> FLOAT .)


state 10

    (20) type_spec -> INT .
    IDENT           reduce using rule 20 (type_spec -> INT .)
    [               reduce using rule 20 (type_spec -> INT .)
    (               reduce using rule 20 (type_spec -> INT .)


state 11

    (21) type_spec -> BOOL .
    IDENT           reduce using rule 21 (type_spec -> BOOL .)
    [               reduce using rule 21 (type_spec -> BOOL .)
    (               reduce using rule 21 (type_spec -> BOOL .)


state 12

    (22) type_spec -> VOID .
    IDENT           reduce using rule 22 (type_spec -> VOID .)
    [               reduce using rule 22 (type_spec -> VOID .)
    (               reduce using rule 22 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (7) class_decl -> CLASS IDENT . sclass_opt { class_body } ;
    (8) sclass_opt -> . : IDENT
    (9) sclass_opt -> . empty
    (111) empty -> .
    :               shift and go to state 17
    {               reduce using rule 111 (empty -> .)

    sclass_opt                     shift and go to state 16
    empty                          shift and go to state 18

state 15

    (23) func_decl -> type_spec IDENT . ( _2_params_optional ) compound_stmt
    (17) var_decl -> type_spec IDENT . [ ] ;
    (18) var_decl -> type_spec IDENT . ;
    (               shift and go to state 19
    [               shift and go to state 20
    ;               shift and go to state 21


state 16

    (7) class_decl -> CLASS IDENT sclass_opt . { class_body } ;
    {               shift and go to state 22


state 17

    (8) sclass_opt -> : . IDENT
    IDENT           shift and go to state 23


state 18

    (9) sclass_opt -> empty .
    {               reduce using rule 9 (sclass_opt -> empty .)


state 19

    (23) func_decl -> type_spec IDENT ( . _2_params_optional ) compound_stmt
    (24) _2_params_optional -> . params
    (25) _2_params_optional -> .
    (26) params -> . VOID
    (27) params -> . param_list
    (28) param_list -> . param
    (29) param_list -> . param_list , param
    (30) param -> . type_spec IDENT [ ]
    (31) param -> . type_spec IDENT
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    )               reduce using rule 25 (_2_params_optional -> .)
    VOID            shift and go to state 27
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 24
    _2_params_optional             shift and go to state 25
    params                         shift and go to state 26
    param_list                     shift and go to state 28
    param                          shift and go to state 29

state 20

    (17) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 30


state 21

    (18) var_decl -> type_spec IDENT ; .
    CLASS           reduce using rule 18 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 18 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 18 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 18 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 18 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 18 (var_decl -> type_spec IDENT ; .)


state 22

    (7) class_decl -> CLASS IDENT sclass_opt { . class_body } ;
    (10) class_body -> . class_member_list
    (11) class_member_list -> . class_member
    (12) class_member_list -> . class_member_list class_member
    (13) class_member -> . method_decl
    (14) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_body                     shift and go to state 31
    class_member_list              shift and go to state 32
    class_member                   shift and go to state 33
    method_decl                    shift and go to state 34
    type_spec                      shift and go to state 35

state 23

    (8) sclass_opt -> : IDENT .
    {               reduce using rule 8 (sclass_opt -> : IDENT .)


state 24

    (30) param -> type_spec . IDENT [ ]
    (31) param -> type_spec . IDENT
    IDENT           shift and go to state 36


state 25

    (23) func_decl -> type_spec IDENT ( _2_params_optional . ) compound_stmt
    )               shift and go to state 37


state 26

    (24) _2_params_optional -> params .
    )               reduce using rule 24 (_2_params_optional -> params .)


state 27

    (26) params -> VOID .
    (22) type_spec -> VOID .
    )               reduce using rule 26 (params -> VOID .)
    IDENT           reduce using rule 22 (type_spec -> VOID .)


state 28

    (27) params -> param_list .
    (29) param_list -> param_list . , param
    )               reduce using rule 27 (params -> param_list .)
    ,               shift and go to state 38


state 29

    (28) param_list -> param .
    ,               reduce using rule 28 (param_list -> param .)
    )               reduce using rule 28 (param_list -> param .)


state 30

    (17) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 39


state 31

    (7) class_decl -> CLASS IDENT sclass_opt { class_body . } ;
    }               shift and go to state 40


state 32

    (10) class_body -> class_member_list .
    (12) class_member_list -> class_member_list . class_member
    (13) class_member -> . method_decl
    (14) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    }               reduce using rule 10 (class_body -> class_member_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_member                   shift and go to state 41
    method_decl                    shift and go to state 34
    type_spec                      shift and go to state 35

state 33

    (11) class_member_list -> class_member .
    FLOAT           reduce using rule 11 (class_member_list -> class_member .)
    INT             reduce using rule 11 (class_member_list -> class_member .)
    BOOL            reduce using rule 11 (class_member_list -> class_member .)
    VOID            reduce using rule 11 (class_member_list -> class_member .)
    }               reduce using rule 11 (class_member_list -> class_member .)


state 34

    (13) class_member -> method_decl .
    FLOAT           reduce using rule 13 (class_member -> method_decl .)
    INT             reduce using rule 13 (class_member -> method_decl .)
    BOOL            reduce using rule 13 (class_member -> method_decl .)
    VOID            reduce using rule 13 (class_member -> method_decl .)
    }               reduce using rule 13 (class_member -> method_decl .)


state 35

    (14) method_decl -> type_spec . IDENT ( _1_params_optional ) compound_stmt
    IDENT           shift and go to state 42


state 36

    (30) param -> type_spec IDENT . [ ]
    (31) param -> type_spec IDENT .
    [               shift and go to state 43
    ,               reduce using rule 31 (param -> type_spec IDENT .)
    )               reduce using rule 31 (param -> type_spec IDENT .)


state 37

    (23) func_decl -> type_spec IDENT ( _2_params_optional ) . compound_stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 45

    compound_stmt                  shift and go to state 44

state 38

    (29) param_list -> param_list , . param
    (30) param -> . type_spec IDENT [ ]
    (31) param -> . type_spec IDENT
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 46
    type_spec                      shift and go to state 24

state 39

    (17) var_decl -> type_spec IDENT [ ] ; .
    CLASS           reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 17 (var_decl -> type_spec IDENT [ ] ; .)


state 40

    (7) class_decl -> CLASS IDENT sclass_opt { class_body } . ;
    ;               shift and go to state 47


state 41

    (12) class_member_list -> class_member_list class_member .
    FLOAT           reduce using rule 12 (class_member_list -> class_member_list class_member .)
    INT             reduce using rule 12 (class_member_list -> class_member_list class_member .)
    BOOL            reduce using rule 12 (class_member_list -> class_member_list class_member .)
    VOID            reduce using rule 12 (class_member_list -> class_member_list class_member .)
    }               reduce using rule 12 (class_member_list -> class_member_list class_member .)


state 42

    (14) method_decl -> type_spec IDENT . ( _1_params_optional ) compound_stmt
    (               shift and go to state 48


state 43

    (30) param -> type_spec IDENT [ . ]
    ]               shift and go to state 49


state 44

    (23) func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .
    CLASS           reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    FLOAT           reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    INT             reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    BOOL            reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    VOID            reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    $end            reduce using rule 23 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)


state 45

    (32) compound_stmt -> { . local_decls stmt_list }
    (33) local_decls -> . empty
    (34) local_decls -> . local_decl_list
    (111) empty -> .
    (35) local_decl_list -> . local_decl
    (36) local_decl_list -> . local_decl_list local_decl
    (37) local_decl -> . type_spec IDENT [ ] ;
    (38) local_decl -> . type_spec IDENT ;
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    SPRINTF         reduce using rule 111 (empty -> .)
    SCANF           reduce using rule 111 (empty -> .)
    PRINTF          reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    CONTINUE        reduce using rule 111 (empty -> .)
    BREAK           reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    {               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    IDENT           reduce using rule 111 (empty -> .)
    MINUSMINUS      reduce using rule 111 (empty -> .)
    PLUSPLUS        reduce using rule 111 (empty -> .)
    NEW             reduce using rule 111 (empty -> .)
    STRING          reduce using rule 111 (empty -> .)
    FLOAT_LIT       reduce using rule 111 (empty -> .)
    INT_LIT         reduce using rule 111 (empty -> .)
    BOOL_LIT        reduce using rule 111 (empty -> .)
    CAST            reduce using rule 111 (empty -> .)
    INTTOFLOAT      reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    +               reduce using rule 111 (empty -> .)
    -               reduce using rule 111 (empty -> .)
    !               reduce using rule 111 (empty -> .)
    SUPER           reduce using rule 111 (empty -> .)
    THIS            reduce using rule 111 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 50
    empty                          shift and go to state 51
    local_decl_list                shift and go to state 52
    local_decl                     shift and go to state 53
    type_spec                      shift and go to state 54

state 46

    (29) param_list -> param_list , param .
    ,               reduce using rule 29 (param_list -> param_list , param .)
    )               reduce using rule 29 (param_list -> param_list , param .)


state 47

    (7) class_decl -> CLASS IDENT sclass_opt { class_body } ; .
    CLASS           reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    FLOAT           reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    INT             reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    BOOL            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    VOID            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)
    $end            reduce using rule 7 (class_decl -> CLASS IDENT sclass_opt { class_body } ; .)


state 48

    (14) method_decl -> type_spec IDENT ( . _1_params_optional ) compound_stmt
    (15) _1_params_optional -> . params
    (16) _1_params_optional -> .
    (26) params -> . VOID
    (27) params -> . param_list
    (28) param_list -> . param
    (29) param_list -> . param_list , param
    (30) param -> . type_spec IDENT [ ]
    (31) param -> . type_spec IDENT
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    )               reduce using rule 16 (_1_params_optional -> .)
    VOID            shift and go to state 27
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 24
    _1_params_optional             shift and go to state 55
    params                         shift and go to state 56
    param_list                     shift and go to state 28
    param                          shift and go to state 29

state 49

    (30) param -> type_spec IDENT [ ] .
    ,               reduce using rule 30 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 30 (param -> type_spec IDENT [ ] .)


state 50

    (32) compound_stmt -> { local_decls . stmt_list }
    (39) stmt_list -> . stmt
    (40) stmt_list -> . stmt_list stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    stmt_list                      shift and go to state 57
    stmt                           shift and go to state 58
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68
    expr                           shift and go to state 77

state 51

    (33) local_decls -> empty .
    SPRINTF         reduce using rule 33 (local_decls -> empty .)
    SCANF           reduce using rule 33 (local_decls -> empty .)
    PRINTF          reduce using rule 33 (local_decls -> empty .)
    FOR             reduce using rule 33 (local_decls -> empty .)
    CONTINUE        reduce using rule 33 (local_decls -> empty .)
    BREAK           reduce using rule 33 (local_decls -> empty .)
    RETURN          reduce using rule 33 (local_decls -> empty .)
    WHILE           reduce using rule 33 (local_decls -> empty .)
    IF              reduce using rule 33 (local_decls -> empty .)
    {               reduce using rule 33 (local_decls -> empty .)
    ;               reduce using rule 33 (local_decls -> empty .)
    IDENT           reduce using rule 33 (local_decls -> empty .)
    MINUSMINUS      reduce using rule 33 (local_decls -> empty .)
    PLUSPLUS        reduce using rule 33 (local_decls -> empty .)
    NEW             reduce using rule 33 (local_decls -> empty .)
    STRING          reduce using rule 33 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 33 (local_decls -> empty .)
    INT_LIT         reduce using rule 33 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 33 (local_decls -> empty .)
    CAST            reduce using rule 33 (local_decls -> empty .)
    INTTOFLOAT      reduce using rule 33 (local_decls -> empty .)
    (               reduce using rule 33 (local_decls -> empty .)
    +               reduce using rule 33 (local_decls -> empty .)
    -               reduce using rule 33 (local_decls -> empty .)
    !               reduce using rule 33 (local_decls -> empty .)
    SUPER           reduce using rule 33 (local_decls -> empty .)
    THIS            reduce using rule 33 (local_decls -> empty .)


state 52

    (34) local_decls -> local_decl_list .
    (36) local_decl_list -> local_decl_list . local_decl
    (37) local_decl -> . type_spec IDENT [ ] ;
    (38) local_decl -> . type_spec IDENT ;
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    SPRINTF         reduce using rule 34 (local_decls -> local_decl_list .)
    SCANF           reduce using rule 34 (local_decls -> local_decl_list .)
    PRINTF          reduce using rule 34 (local_decls -> local_decl_list .)
    FOR             reduce using rule 34 (local_decls -> local_decl_list .)
    CONTINUE        reduce using rule 34 (local_decls -> local_decl_list .)
    BREAK           reduce using rule 34 (local_decls -> local_decl_list .)
    RETURN          reduce using rule 34 (local_decls -> local_decl_list .)
    WHILE           reduce using rule 34 (local_decls -> local_decl_list .)
    IF              reduce using rule 34 (local_decls -> local_decl_list .)
    {               reduce using rule 34 (local_decls -> local_decl_list .)
    ;               reduce using rule 34 (local_decls -> local_decl_list .)
    IDENT           reduce using rule 34 (local_decls -> local_decl_list .)
    MINUSMINUS      reduce using rule 34 (local_decls -> local_decl_list .)
    PLUSPLUS        reduce using rule 34 (local_decls -> local_decl_list .)
    NEW             reduce using rule 34 (local_decls -> local_decl_list .)
    STRING          reduce using rule 34 (local_decls -> local_decl_list .)
    FLOAT_LIT       reduce using rule 34 (local_decls -> local_decl_list .)
    INT_LIT         reduce using rule 34 (local_decls -> local_decl_list .)
    BOOL_LIT        reduce using rule 34 (local_decls -> local_decl_list .)
    CAST            reduce using rule 34 (local_decls -> local_decl_list .)
    INTTOFLOAT      reduce using rule 34 (local_decls -> local_decl_list .)
    (               reduce using rule 34 (local_decls -> local_decl_list .)
    +               reduce using rule 34 (local_decls -> local_decl_list .)
    -               reduce using rule 34 (local_decls -> local_decl_list .)
    !               reduce using rule 34 (local_decls -> local_decl_list .)
    SUPER           reduce using rule 34 (local_decls -> local_decl_list .)
    THIS            reduce using rule 34 (local_decls -> local_decl_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 96
    type_spec                      shift and go to state 54

state 53

    (35) local_decl_list -> local_decl .
    FLOAT           reduce using rule 35 (local_decl_list -> local_decl .)
    INT             reduce using rule 35 (local_decl_list -> local_decl .)
    BOOL            reduce using rule 35 (local_decl_list -> local_decl .)
    VOID            reduce using rule 35 (local_decl_list -> local_decl .)
    SPRINTF         reduce using rule 35 (local_decl_list -> local_decl .)
    SCANF           reduce using rule 35 (local_decl_list -> local_decl .)
    PRINTF          reduce using rule 35 (local_decl_list -> local_decl .)
    FOR             reduce using rule 35 (local_decl_list -> local_decl .)
    CONTINUE        reduce using rule 35 (local_decl_list -> local_decl .)
    BREAK           reduce using rule 35 (local_decl_list -> local_decl .)
    RETURN          reduce using rule 35 (local_decl_list -> local_decl .)
    WHILE           reduce using rule 35 (local_decl_list -> local_decl .)
    IF              reduce using rule 35 (local_decl_list -> local_decl .)
    {               reduce using rule 35 (local_decl_list -> local_decl .)
    ;               reduce using rule 35 (local_decl_list -> local_decl .)
    IDENT           reduce using rule 35 (local_decl_list -> local_decl .)
    MINUSMINUS      reduce using rule 35 (local_decl_list -> local_decl .)
    PLUSPLUS        reduce using rule 35 (local_decl_list -> local_decl .)
    NEW             reduce using rule 35 (local_decl_list -> local_decl .)
    STRING          reduce using rule 35 (local_decl_list -> local_decl .)
    FLOAT_LIT       reduce using rule 35 (local_decl_list -> local_decl .)
    INT_LIT         reduce using rule 35 (local_decl_list -> local_decl .)
    BOOL_LIT        reduce using rule 35 (local_decl_list -> local_decl .)
    CAST            reduce using rule 35 (local_decl_list -> local_decl .)
    INTTOFLOAT      reduce using rule 35 (local_decl_list -> local_decl .)
    (               reduce using rule 35 (local_decl_list -> local_decl .)
    +               reduce using rule 35 (local_decl_list -> local_decl .)
    -               reduce using rule 35 (local_decl_list -> local_decl .)
    !               reduce using rule 35 (local_decl_list -> local_decl .)
    SUPER           reduce using rule 35 (local_decl_list -> local_decl .)
    THIS            reduce using rule 35 (local_decl_list -> local_decl .)


state 54

    (37) local_decl -> type_spec . IDENT [ ] ;
    (38) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 97


state 55

    (14) method_decl -> type_spec IDENT ( _1_params_optional . ) compound_stmt
    )               shift and go to state 98


state 56

    (15) _1_params_optional -> params .
    )               reduce using rule 15 (_1_params_optional -> params .)


state 57

    (32) compound_stmt -> { local_decls stmt_list . }
    (40) stmt_list -> stmt_list . stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    }               shift and go to state 99
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    stmt                           shift and go to state 100
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68
    expr                           shift and go to state 77

state 58

    (39) stmt_list -> stmt .
    }               reduce using rule 39 (stmt_list -> stmt .)
    SPRINTF         reduce using rule 39 (stmt_list -> stmt .)
    SCANF           reduce using rule 39 (stmt_list -> stmt .)
    PRINTF          reduce using rule 39 (stmt_list -> stmt .)
    FOR             reduce using rule 39 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 39 (stmt_list -> stmt .)
    BREAK           reduce using rule 39 (stmt_list -> stmt .)
    RETURN          reduce using rule 39 (stmt_list -> stmt .)
    WHILE           reduce using rule 39 (stmt_list -> stmt .)
    IF              reduce using rule 39 (stmt_list -> stmt .)
    {               reduce using rule 39 (stmt_list -> stmt .)
    ;               reduce using rule 39 (stmt_list -> stmt .)
    IDENT           reduce using rule 39 (stmt_list -> stmt .)
    MINUSMINUS      reduce using rule 39 (stmt_list -> stmt .)
    PLUSPLUS        reduce using rule 39 (stmt_list -> stmt .)
    NEW             reduce using rule 39 (stmt_list -> stmt .)
    STRING          reduce using rule 39 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 39 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 39 (stmt_list -> stmt .)
    CAST            reduce using rule 39 (stmt_list -> stmt .)
    INTTOFLOAT      reduce using rule 39 (stmt_list -> stmt .)
    (               reduce using rule 39 (stmt_list -> stmt .)
    +               reduce using rule 39 (stmt_list -> stmt .)
    -               reduce using rule 39 (stmt_list -> stmt .)
    !               reduce using rule 39 (stmt_list -> stmt .)
    SUPER           reduce using rule 39 (stmt_list -> stmt .)
    THIS            reduce using rule 39 (stmt_list -> stmt .)


state 59

    (41) stmt -> sprintf_stmt .
    }               reduce using rule 41 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 41 (stmt -> sprintf_stmt .)
    SCANF           reduce using rule 41 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 41 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 41 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 41 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 41 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 41 (stmt -> sprintf_stmt .)
    IF              reduce using rule 41 (stmt -> sprintf_stmt .)
    {               reduce using rule 41 (stmt -> sprintf_stmt .)
    ;               reduce using rule 41 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 41 (stmt -> sprintf_stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> sprintf_stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> sprintf_stmt .)
    NEW             reduce using rule 41 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 41 (stmt -> sprintf_stmt .)
    FLOAT_LIT       reduce using rule 41 (stmt -> sprintf_stmt .)
    INT_LIT         reduce using rule 41 (stmt -> sprintf_stmt .)
    BOOL_LIT        reduce using rule 41 (stmt -> sprintf_stmt .)
    CAST            reduce using rule 41 (stmt -> sprintf_stmt .)
    INTTOFLOAT      reduce using rule 41 (stmt -> sprintf_stmt .)
    (               reduce using rule 41 (stmt -> sprintf_stmt .)
    +               reduce using rule 41 (stmt -> sprintf_stmt .)
    -               reduce using rule 41 (stmt -> sprintf_stmt .)
    !               reduce using rule 41 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 41 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 41 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 41 (stmt -> sprintf_stmt .)


state 60

    (42) stmt -> scanf_stmt .
    }               reduce using rule 42 (stmt -> scanf_stmt .)
    SPRINTF         reduce using rule 42 (stmt -> scanf_stmt .)
    SCANF           reduce using rule 42 (stmt -> scanf_stmt .)
    PRINTF          reduce using rule 42 (stmt -> scanf_stmt .)
    FOR             reduce using rule 42 (stmt -> scanf_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> scanf_stmt .)
    BREAK           reduce using rule 42 (stmt -> scanf_stmt .)
    RETURN          reduce using rule 42 (stmt -> scanf_stmt .)
    WHILE           reduce using rule 42 (stmt -> scanf_stmt .)
    IF              reduce using rule 42 (stmt -> scanf_stmt .)
    {               reduce using rule 42 (stmt -> scanf_stmt .)
    ;               reduce using rule 42 (stmt -> scanf_stmt .)
    IDENT           reduce using rule 42 (stmt -> scanf_stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> scanf_stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> scanf_stmt .)
    NEW             reduce using rule 42 (stmt -> scanf_stmt .)
    STRING          reduce using rule 42 (stmt -> scanf_stmt .)
    FLOAT_LIT       reduce using rule 42 (stmt -> scanf_stmt .)
    INT_LIT         reduce using rule 42 (stmt -> scanf_stmt .)
    BOOL_LIT        reduce using rule 42 (stmt -> scanf_stmt .)
    CAST            reduce using rule 42 (stmt -> scanf_stmt .)
    INTTOFLOAT      reduce using rule 42 (stmt -> scanf_stmt .)
    (               reduce using rule 42 (stmt -> scanf_stmt .)
    +               reduce using rule 42 (stmt -> scanf_stmt .)
    -               reduce using rule 42 (stmt -> scanf_stmt .)
    !               reduce using rule 42 (stmt -> scanf_stmt .)
    SUPER           reduce using rule 42 (stmt -> scanf_stmt .)
    THIS            reduce using rule 42 (stmt -> scanf_stmt .)
    ELSE            reduce using rule 42 (stmt -> scanf_stmt .)


state 61

    (43) stmt -> printf_stmt .
    }               reduce using rule 43 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 43 (stmt -> printf_stmt .)
    SCANF           reduce using rule 43 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 43 (stmt -> printf_stmt .)
    FOR             reduce using rule 43 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> printf_stmt .)
    BREAK           reduce using rule 43 (stmt -> printf_stmt .)
    RETURN          reduce using rule 43 (stmt -> printf_stmt .)
    WHILE           reduce using rule 43 (stmt -> printf_stmt .)
    IF              reduce using rule 43 (stmt -> printf_stmt .)
    {               reduce using rule 43 (stmt -> printf_stmt .)
    ;               reduce using rule 43 (stmt -> printf_stmt .)
    IDENT           reduce using rule 43 (stmt -> printf_stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> printf_stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> printf_stmt .)
    NEW             reduce using rule 43 (stmt -> printf_stmt .)
    STRING          reduce using rule 43 (stmt -> printf_stmt .)
    FLOAT_LIT       reduce using rule 43 (stmt -> printf_stmt .)
    INT_LIT         reduce using rule 43 (stmt -> printf_stmt .)
    BOOL_LIT        reduce using rule 43 (stmt -> printf_stmt .)
    CAST            reduce using rule 43 (stmt -> printf_stmt .)
    INTTOFLOAT      reduce using rule 43 (stmt -> printf_stmt .)
    (               reduce using rule 43 (stmt -> printf_stmt .)
    +               reduce using rule 43 (stmt -> printf_stmt .)
    -               reduce using rule 43 (stmt -> printf_stmt .)
    !               reduce using rule 43 (stmt -> printf_stmt .)
    SUPER           reduce using rule 43 (stmt -> printf_stmt .)
    THIS            reduce using rule 43 (stmt -> printf_stmt .)
    ELSE            reduce using rule 43 (stmt -> printf_stmt .)


state 62

    (44) stmt -> for_stmt .
    }               reduce using rule 44 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 44 (stmt -> for_stmt .)
    SCANF           reduce using rule 44 (stmt -> for_stmt .)
    PRINTF          reduce using rule 44 (stmt -> for_stmt .)
    FOR             reduce using rule 44 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 44 (stmt -> for_stmt .)
    BREAK           reduce using rule 44 (stmt -> for_stmt .)
    RETURN          reduce using rule 44 (stmt -> for_stmt .)
    WHILE           reduce using rule 44 (stmt -> for_stmt .)
    IF              reduce using rule 44 (stmt -> for_stmt .)
    {               reduce using rule 44 (stmt -> for_stmt .)
    ;               reduce using rule 44 (stmt -> for_stmt .)
    IDENT           reduce using rule 44 (stmt -> for_stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> for_stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> for_stmt .)
    NEW             reduce using rule 44 (stmt -> for_stmt .)
    STRING          reduce using rule 44 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 44 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 44 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 44 (stmt -> for_stmt .)
    CAST            reduce using rule 44 (stmt -> for_stmt .)
    INTTOFLOAT      reduce using rule 44 (stmt -> for_stmt .)
    (               reduce using rule 44 (stmt -> for_stmt .)
    +               reduce using rule 44 (stmt -> for_stmt .)
    -               reduce using rule 44 (stmt -> for_stmt .)
    !               reduce using rule 44 (stmt -> for_stmt .)
    SUPER           reduce using rule 44 (stmt -> for_stmt .)
    THIS            reduce using rule 44 (stmt -> for_stmt .)
    ELSE            reduce using rule 44 (stmt -> for_stmt .)


state 63

    (45) stmt -> break_stmt .
    }               reduce using rule 45 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 45 (stmt -> break_stmt .)
    SCANF           reduce using rule 45 (stmt -> break_stmt .)
    PRINTF          reduce using rule 45 (stmt -> break_stmt .)
    FOR             reduce using rule 45 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> break_stmt .)
    BREAK           reduce using rule 45 (stmt -> break_stmt .)
    RETURN          reduce using rule 45 (stmt -> break_stmt .)
    WHILE           reduce using rule 45 (stmt -> break_stmt .)
    IF              reduce using rule 45 (stmt -> break_stmt .)
    {               reduce using rule 45 (stmt -> break_stmt .)
    ;               reduce using rule 45 (stmt -> break_stmt .)
    IDENT           reduce using rule 45 (stmt -> break_stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> break_stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> break_stmt .)
    NEW             reduce using rule 45 (stmt -> break_stmt .)
    STRING          reduce using rule 45 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 45 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 45 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 45 (stmt -> break_stmt .)
    CAST            reduce using rule 45 (stmt -> break_stmt .)
    INTTOFLOAT      reduce using rule 45 (stmt -> break_stmt .)
    (               reduce using rule 45 (stmt -> break_stmt .)
    +               reduce using rule 45 (stmt -> break_stmt .)
    -               reduce using rule 45 (stmt -> break_stmt .)
    !               reduce using rule 45 (stmt -> break_stmt .)
    SUPER           reduce using rule 45 (stmt -> break_stmt .)
    THIS            reduce using rule 45 (stmt -> break_stmt .)
    ELSE            reduce using rule 45 (stmt -> break_stmt .)


state 64

    (46) stmt -> return_stmt .
    }               reduce using rule 46 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 46 (stmt -> return_stmt .)
    SCANF           reduce using rule 46 (stmt -> return_stmt .)
    PRINTF          reduce using rule 46 (stmt -> return_stmt .)
    FOR             reduce using rule 46 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 46 (stmt -> return_stmt .)
    BREAK           reduce using rule 46 (stmt -> return_stmt .)
    RETURN          reduce using rule 46 (stmt -> return_stmt .)
    WHILE           reduce using rule 46 (stmt -> return_stmt .)
    IF              reduce using rule 46 (stmt -> return_stmt .)
    {               reduce using rule 46 (stmt -> return_stmt .)
    ;               reduce using rule 46 (stmt -> return_stmt .)
    IDENT           reduce using rule 46 (stmt -> return_stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> return_stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> return_stmt .)
    NEW             reduce using rule 46 (stmt -> return_stmt .)
    STRING          reduce using rule 46 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 46 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 46 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 46 (stmt -> return_stmt .)
    CAST            reduce using rule 46 (stmt -> return_stmt .)
    INTTOFLOAT      reduce using rule 46 (stmt -> return_stmt .)
    (               reduce using rule 46 (stmt -> return_stmt .)
    +               reduce using rule 46 (stmt -> return_stmt .)
    -               reduce using rule 46 (stmt -> return_stmt .)
    !               reduce using rule 46 (stmt -> return_stmt .)
    SUPER           reduce using rule 46 (stmt -> return_stmt .)
    THIS            reduce using rule 46 (stmt -> return_stmt .)
    ELSE            reduce using rule 46 (stmt -> return_stmt .)


state 65

    (47) stmt -> while_stmt .
    }               reduce using rule 47 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 47 (stmt -> while_stmt .)
    SCANF           reduce using rule 47 (stmt -> while_stmt .)
    PRINTF          reduce using rule 47 (stmt -> while_stmt .)
    FOR             reduce using rule 47 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 47 (stmt -> while_stmt .)
    BREAK           reduce using rule 47 (stmt -> while_stmt .)
    RETURN          reduce using rule 47 (stmt -> while_stmt .)
    WHILE           reduce using rule 47 (stmt -> while_stmt .)
    IF              reduce using rule 47 (stmt -> while_stmt .)
    {               reduce using rule 47 (stmt -> while_stmt .)
    ;               reduce using rule 47 (stmt -> while_stmt .)
    IDENT           reduce using rule 47 (stmt -> while_stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> while_stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> while_stmt .)
    NEW             reduce using rule 47 (stmt -> while_stmt .)
    STRING          reduce using rule 47 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 47 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 47 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 47 (stmt -> while_stmt .)
    CAST            reduce using rule 47 (stmt -> while_stmt .)
    INTTOFLOAT      reduce using rule 47 (stmt -> while_stmt .)
    (               reduce using rule 47 (stmt -> while_stmt .)
    +               reduce using rule 47 (stmt -> while_stmt .)
    -               reduce using rule 47 (stmt -> while_stmt .)
    !               reduce using rule 47 (stmt -> while_stmt .)
    SUPER           reduce using rule 47 (stmt -> while_stmt .)
    THIS            reduce using rule 47 (stmt -> while_stmt .)
    ELSE            reduce using rule 47 (stmt -> while_stmt .)


state 66

    (48) stmt -> if_stmt .
    }               reduce using rule 48 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 48 (stmt -> if_stmt .)
    SCANF           reduce using rule 48 (stmt -> if_stmt .)
    PRINTF          reduce using rule 48 (stmt -> if_stmt .)
    FOR             reduce using rule 48 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 48 (stmt -> if_stmt .)
    BREAK           reduce using rule 48 (stmt -> if_stmt .)
    RETURN          reduce using rule 48 (stmt -> if_stmt .)
    WHILE           reduce using rule 48 (stmt -> if_stmt .)
    IF              reduce using rule 48 (stmt -> if_stmt .)
    {               reduce using rule 48 (stmt -> if_stmt .)
    ;               reduce using rule 48 (stmt -> if_stmt .)
    IDENT           reduce using rule 48 (stmt -> if_stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> if_stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> if_stmt .)
    NEW             reduce using rule 48 (stmt -> if_stmt .)
    STRING          reduce using rule 48 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 48 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 48 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 48 (stmt -> if_stmt .)
    CAST            reduce using rule 48 (stmt -> if_stmt .)
    INTTOFLOAT      reduce using rule 48 (stmt -> if_stmt .)
    (               reduce using rule 48 (stmt -> if_stmt .)
    +               reduce using rule 48 (stmt -> if_stmt .)
    -               reduce using rule 48 (stmt -> if_stmt .)
    !               reduce using rule 48 (stmt -> if_stmt .)
    SUPER           reduce using rule 48 (stmt -> if_stmt .)
    THIS            reduce using rule 48 (stmt -> if_stmt .)
    ELSE            reduce using rule 48 (stmt -> if_stmt .)


state 67

    (49) stmt -> compound_stmt .
    }               reduce using rule 49 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 49 (stmt -> compound_stmt .)
    SCANF           reduce using rule 49 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 49 (stmt -> compound_stmt .)
    FOR             reduce using rule 49 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 49 (stmt -> compound_stmt .)
    BREAK           reduce using rule 49 (stmt -> compound_stmt .)
    RETURN          reduce using rule 49 (stmt -> compound_stmt .)
    WHILE           reduce using rule 49 (stmt -> compound_stmt .)
    IF              reduce using rule 49 (stmt -> compound_stmt .)
    {               reduce using rule 49 (stmt -> compound_stmt .)
    ;               reduce using rule 49 (stmt -> compound_stmt .)
    IDENT           reduce using rule 49 (stmt -> compound_stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> compound_stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> compound_stmt .)
    NEW             reduce using rule 49 (stmt -> compound_stmt .)
    STRING          reduce using rule 49 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 49 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 49 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 49 (stmt -> compound_stmt .)
    CAST            reduce using rule 49 (stmt -> compound_stmt .)
    INTTOFLOAT      reduce using rule 49 (stmt -> compound_stmt .)
    (               reduce using rule 49 (stmt -> compound_stmt .)
    +               reduce using rule 49 (stmt -> compound_stmt .)
    -               reduce using rule 49 (stmt -> compound_stmt .)
    !               reduce using rule 49 (stmt -> compound_stmt .)
    SUPER           reduce using rule 49 (stmt -> compound_stmt .)
    THIS            reduce using rule 49 (stmt -> compound_stmt .)
    ELSE            reduce using rule 49 (stmt -> compound_stmt .)


state 68

    (50) stmt -> expr_stmt .
    }               reduce using rule 50 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 50 (stmt -> expr_stmt .)
    SCANF           reduce using rule 50 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 50 (stmt -> expr_stmt .)
    FOR             reduce using rule 50 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 50 (stmt -> expr_stmt .)
    BREAK           reduce using rule 50 (stmt -> expr_stmt .)
    RETURN          reduce using rule 50 (stmt -> expr_stmt .)
    WHILE           reduce using rule 50 (stmt -> expr_stmt .)
    IF              reduce using rule 50 (stmt -> expr_stmt .)
    {               reduce using rule 50 (stmt -> expr_stmt .)
    ;               reduce using rule 50 (stmt -> expr_stmt .)
    IDENT           reduce using rule 50 (stmt -> expr_stmt .)
    MINUSMINUS      reduce using rule 50 (stmt -> expr_stmt .)
    PLUSPLUS        reduce using rule 50 (stmt -> expr_stmt .)
    NEW             reduce using rule 50 (stmt -> expr_stmt .)
    STRING          reduce using rule 50 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 50 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 50 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 50 (stmt -> expr_stmt .)
    CAST            reduce using rule 50 (stmt -> expr_stmt .)
    INTTOFLOAT      reduce using rule 50 (stmt -> expr_stmt .)
    (               reduce using rule 50 (stmt -> expr_stmt .)
    +               reduce using rule 50 (stmt -> expr_stmt .)
    -               reduce using rule 50 (stmt -> expr_stmt .)
    !               reduce using rule 50 (stmt -> expr_stmt .)
    SUPER           reduce using rule 50 (stmt -> expr_stmt .)
    THIS            reduce using rule 50 (stmt -> expr_stmt .)
    ELSE            reduce using rule 50 (stmt -> expr_stmt .)


state 69

    (110) sprintf_stmt -> SPRINTF . ( IDENT , STRING , arg_list ) ;
    (               shift and go to state 101


state 70

    (80) expr -> ( . expr )
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 102

state 71

    (61) expr -> IDENT . DIVEQ expr
    (62) expr -> IDENT . MULEQ expr
    (63) expr -> IDENT . MINUSEQ expr
    (64) expr -> IDENT . PLUSEQ expr
    (76) expr -> IDENT . . SIZE
    (77) expr -> IDENT . ( args )
    (78) expr -> IDENT . [ expr ]
    (79) expr -> IDENT .
    (101) expr -> IDENT . [ expr ] = expr
    (102) expr -> IDENT . = expr
    DIVEQ           shift and go to state 103
    MULEQ           shift and go to state 104
    MINUSEQ         shift and go to state 105
    PLUSEQ          shift and go to state 106
    .               shift and go to state 107
    (               shift and go to state 108
    [               shift and go to state 109
    ;               reduce using rule 79 (expr -> IDENT .)
    MINUSMINUS      reduce using rule 79 (expr -> IDENT .)
    PLUSPLUS        reduce using rule 79 (expr -> IDENT .)
    AND             reduce using rule 79 (expr -> IDENT .)
    OR              reduce using rule 79 (expr -> IDENT .)
    %               reduce using rule 79 (expr -> IDENT .)
    /               reduce using rule 79 (expr -> IDENT .)
    *               reduce using rule 79 (expr -> IDENT .)
    -               reduce using rule 79 (expr -> IDENT .)
    +               reduce using rule 79 (expr -> IDENT .)
    >               reduce using rule 79 (expr -> IDENT .)
    GE              reduce using rule 79 (expr -> IDENT .)
    <               reduce using rule 79 (expr -> IDENT .)
    LE              reduce using rule 79 (expr -> IDENT .)
    NE              reduce using rule 79 (expr -> IDENT .)
    EQ              reduce using rule 79 (expr -> IDENT .)
    POINT           reduce using rule 79 (expr -> IDENT .)
    )               reduce using rule 79 (expr -> IDENT .)
    ,               reduce using rule 79 (expr -> IDENT .)
    ]               reduce using rule 79 (expr -> IDENT .)
    =               shift and go to state 110


state 72

    (70) expr -> STRING .
    ;               reduce using rule 70 (expr -> STRING .)
    MINUSMINUS      reduce using rule 70 (expr -> STRING .)
    PLUSPLUS        reduce using rule 70 (expr -> STRING .)
    AND             reduce using rule 70 (expr -> STRING .)
    OR              reduce using rule 70 (expr -> STRING .)
    %               reduce using rule 70 (expr -> STRING .)
    /               reduce using rule 70 (expr -> STRING .)
    *               reduce using rule 70 (expr -> STRING .)
    -               reduce using rule 70 (expr -> STRING .)
    +               reduce using rule 70 (expr -> STRING .)
    >               reduce using rule 70 (expr -> STRING .)
    GE              reduce using rule 70 (expr -> STRING .)
    <               reduce using rule 70 (expr -> STRING .)
    LE              reduce using rule 70 (expr -> STRING .)
    NE              reduce using rule 70 (expr -> STRING .)
    EQ              reduce using rule 70 (expr -> STRING .)
    POINT           reduce using rule 70 (expr -> STRING .)
    )               reduce using rule 70 (expr -> STRING .)
    ,               reduce using rule 70 (expr -> STRING .)
    ]               reduce using rule 70 (expr -> STRING .)


state 73

    (51) expr_stmt -> ; .
    }               reduce using rule 51 (expr_stmt -> ; .)
    SPRINTF         reduce using rule 51 (expr_stmt -> ; .)
    SCANF           reduce using rule 51 (expr_stmt -> ; .)
    PRINTF          reduce using rule 51 (expr_stmt -> ; .)
    FOR             reduce using rule 51 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 51 (expr_stmt -> ; .)
    BREAK           reduce using rule 51 (expr_stmt -> ; .)
    RETURN          reduce using rule 51 (expr_stmt -> ; .)
    WHILE           reduce using rule 51 (expr_stmt -> ; .)
    IF              reduce using rule 51 (expr_stmt -> ; .)
    {               reduce using rule 51 (expr_stmt -> ; .)
    ;               reduce using rule 51 (expr_stmt -> ; .)
    IDENT           reduce using rule 51 (expr_stmt -> ; .)
    MINUSMINUS      reduce using rule 51 (expr_stmt -> ; .)
    PLUSPLUS        reduce using rule 51 (expr_stmt -> ; .)
    NEW             reduce using rule 51 (expr_stmt -> ; .)
    STRING          reduce using rule 51 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 51 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 51 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 51 (expr_stmt -> ; .)
    CAST            reduce using rule 51 (expr_stmt -> ; .)
    INTTOFLOAT      reduce using rule 51 (expr_stmt -> ; .)
    (               reduce using rule 51 (expr_stmt -> ; .)
    +               reduce using rule 51 (expr_stmt -> ; .)
    -               reduce using rule 51 (expr_stmt -> ; .)
    !               reduce using rule 51 (expr_stmt -> ; .)
    SUPER           reduce using rule 51 (expr_stmt -> ; .)
    THIS            reduce using rule 51 (expr_stmt -> ; .)
    ELSE            reduce using rule 51 (expr_stmt -> ; .)


state 74

    (109) scanf_stmt -> SCANF . ( STRING , arg_list ) ;
    (               shift and go to state 111


state 75

    (107) printf_stmt -> PRINTF . ( STRING , arg_list ) ;
    (108) printf_stmt -> PRINTF . ( STRING ) ;
    (               shift and go to state 112


state 76

    (54) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 113


state 77

    (52) expr_stmt -> expr . ;
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               shift and go to state 114
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 78

    (59) break_stmt -> CONTINUE . ;
    ;               shift and go to state 131


state 79

    (60) break_stmt -> BREAK . ;
    ;               shift and go to state 132


state 80

    (57) return_stmt -> RETURN . expr ;
    (58) return_stmt -> RETURN . ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    ;               shift and go to state 134
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 133

state 81

    (53) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 135


state 82

    (55) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (56) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 136


state 83

    (65) expr -> MINUSMINUS . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 137

state 84

    (66) expr -> PLUSPLUS . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 138

state 85

    (69) expr -> NEW . type_spec [ expr ]
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 139

state 86

    (71) expr -> FLOAT_LIT .
    ;               reduce using rule 71 (expr -> FLOAT_LIT .)
    MINUSMINUS      reduce using rule 71 (expr -> FLOAT_LIT .)
    PLUSPLUS        reduce using rule 71 (expr -> FLOAT_LIT .)
    AND             reduce using rule 71 (expr -> FLOAT_LIT .)
    OR              reduce using rule 71 (expr -> FLOAT_LIT .)
    %               reduce using rule 71 (expr -> FLOAT_LIT .)
    /               reduce using rule 71 (expr -> FLOAT_LIT .)
    *               reduce using rule 71 (expr -> FLOAT_LIT .)
    -               reduce using rule 71 (expr -> FLOAT_LIT .)
    +               reduce using rule 71 (expr -> FLOAT_LIT .)
    >               reduce using rule 71 (expr -> FLOAT_LIT .)
    GE              reduce using rule 71 (expr -> FLOAT_LIT .)
    <               reduce using rule 71 (expr -> FLOAT_LIT .)
    LE              reduce using rule 71 (expr -> FLOAT_LIT .)
    NE              reduce using rule 71 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 71 (expr -> FLOAT_LIT .)
    POINT           reduce using rule 71 (expr -> FLOAT_LIT .)
    )               reduce using rule 71 (expr -> FLOAT_LIT .)
    ,               reduce using rule 71 (expr -> FLOAT_LIT .)
    ]               reduce using rule 71 (expr -> FLOAT_LIT .)


state 87

    (72) expr -> INT_LIT .
    ;               reduce using rule 72 (expr -> INT_LIT .)
    MINUSMINUS      reduce using rule 72 (expr -> INT_LIT .)
    PLUSPLUS        reduce using rule 72 (expr -> INT_LIT .)
    AND             reduce using rule 72 (expr -> INT_LIT .)
    OR              reduce using rule 72 (expr -> INT_LIT .)
    %               reduce using rule 72 (expr -> INT_LIT .)
    /               reduce using rule 72 (expr -> INT_LIT .)
    *               reduce using rule 72 (expr -> INT_LIT .)
    -               reduce using rule 72 (expr -> INT_LIT .)
    +               reduce using rule 72 (expr -> INT_LIT .)
    >               reduce using rule 72 (expr -> INT_LIT .)
    GE              reduce using rule 72 (expr -> INT_LIT .)
    <               reduce using rule 72 (expr -> INT_LIT .)
    LE              reduce using rule 72 (expr -> INT_LIT .)
    NE              reduce using rule 72 (expr -> INT_LIT .)
    EQ              reduce using rule 72 (expr -> INT_LIT .)
    POINT           reduce using rule 72 (expr -> INT_LIT .)
    )               reduce using rule 72 (expr -> INT_LIT .)
    ,               reduce using rule 72 (expr -> INT_LIT .)
    ]               reduce using rule 72 (expr -> INT_LIT .)


state 88

    (73) expr -> BOOL_LIT .
    ;               reduce using rule 73 (expr -> BOOL_LIT .)
    MINUSMINUS      reduce using rule 73 (expr -> BOOL_LIT .)
    PLUSPLUS        reduce using rule 73 (expr -> BOOL_LIT .)
    AND             reduce using rule 73 (expr -> BOOL_LIT .)
    OR              reduce using rule 73 (expr -> BOOL_LIT .)
    %               reduce using rule 73 (expr -> BOOL_LIT .)
    /               reduce using rule 73 (expr -> BOOL_LIT .)
    *               reduce using rule 73 (expr -> BOOL_LIT .)
    -               reduce using rule 73 (expr -> BOOL_LIT .)
    +               reduce using rule 73 (expr -> BOOL_LIT .)
    >               reduce using rule 73 (expr -> BOOL_LIT .)
    GE              reduce using rule 73 (expr -> BOOL_LIT .)
    <               reduce using rule 73 (expr -> BOOL_LIT .)
    LE              reduce using rule 73 (expr -> BOOL_LIT .)
    NE              reduce using rule 73 (expr -> BOOL_LIT .)
    EQ              reduce using rule 73 (expr -> BOOL_LIT .)
    POINT           reduce using rule 73 (expr -> BOOL_LIT .)
    )               reduce using rule 73 (expr -> BOOL_LIT .)
    ,               reduce using rule 73 (expr -> BOOL_LIT .)
    ]               reduce using rule 73 (expr -> BOOL_LIT .)


state 89

    (74) expr -> CAST . type_spec ( expr )
    (19) type_spec -> . FLOAT
    (20) type_spec -> . INT
    (21) type_spec -> . BOOL
    (22) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 140

state 90

    (75) expr -> INTTOFLOAT . ( IDENT )
    (               shift and go to state 141


state 91

    (81) expr -> + . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 142

state 92

    (82) expr -> - . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 143

state 93

    (83) expr -> ! . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 144

state 94

    (99) expr -> SUPER . POINT IDENT
    POINT           shift and go to state 145


state 95

    (100) expr -> THIS .
    ;               reduce using rule 100 (expr -> THIS .)
    MINUSMINUS      reduce using rule 100 (expr -> THIS .)
    PLUSPLUS        reduce using rule 100 (expr -> THIS .)
    AND             reduce using rule 100 (expr -> THIS .)
    OR              reduce using rule 100 (expr -> THIS .)
    %               reduce using rule 100 (expr -> THIS .)
    /               reduce using rule 100 (expr -> THIS .)
    *               reduce using rule 100 (expr -> THIS .)
    -               reduce using rule 100 (expr -> THIS .)
    +               reduce using rule 100 (expr -> THIS .)
    >               reduce using rule 100 (expr -> THIS .)
    GE              reduce using rule 100 (expr -> THIS .)
    <               reduce using rule 100 (expr -> THIS .)
    LE              reduce using rule 100 (expr -> THIS .)
    NE              reduce using rule 100 (expr -> THIS .)
    EQ              reduce using rule 100 (expr -> THIS .)
    POINT           reduce using rule 100 (expr -> THIS .)
    )               reduce using rule 100 (expr -> THIS .)
    ,               reduce using rule 100 (expr -> THIS .)
    ]               reduce using rule 100 (expr -> THIS .)


state 96

    (36) local_decl_list -> local_decl_list local_decl .
    FLOAT           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    INT             reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    BOOL            reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    VOID            reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    SPRINTF         reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    SCANF           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    PRINTF          reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    FOR             reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    CONTINUE        reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    BREAK           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    RETURN          reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    WHILE           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    IF              reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    {               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    ;               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    IDENT           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    MINUSMINUS      reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    PLUSPLUS        reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    NEW             reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    STRING          reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    FLOAT_LIT       reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    INT_LIT         reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    BOOL_LIT        reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    CAST            reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    INTTOFLOAT      reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    (               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    +               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    -               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    !               reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    SUPER           reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)
    THIS            reduce using rule 36 (local_decl_list -> local_decl_list local_decl .)


state 97

    (37) local_decl -> type_spec IDENT . [ ] ;
    (38) local_decl -> type_spec IDENT . ;
    [               shift and go to state 146
    ;               shift and go to state 147


state 98

    (14) method_decl -> type_spec IDENT ( _1_params_optional ) . compound_stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 45

    compound_stmt                  shift and go to state 148

state 99

    (32) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    MINUSMINUS      reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    PLUSPLUS        reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    CAST            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    INTTOFLOAT      reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 32 (compound_stmt -> { local_decls stmt_list } .)


state 100

    (40) stmt_list -> stmt_list stmt .
    }               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    SPRINTF         reduce using rule 40 (stmt_list -> stmt_list stmt .)
    SCANF           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 40 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 40 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    MINUSMINUS      reduce using rule 40 (stmt_list -> stmt_list stmt .)
    PLUSPLUS        reduce using rule 40 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 40 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 40 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 40 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 40 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 40 (stmt_list -> stmt_list stmt .)
    CAST            reduce using rule 40 (stmt_list -> stmt_list stmt .)
    INTTOFLOAT      reduce using rule 40 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 40 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 40 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 40 (stmt_list -> stmt_list stmt .)


state 101

    (110) sprintf_stmt -> SPRINTF ( . IDENT , STRING , arg_list ) ;
    IDENT           shift and go to state 149


state 102

    (80) expr -> ( expr . )
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    )               shift and go to state 150
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 103

    (61) expr -> IDENT DIVEQ . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 151

state 104

    (62) expr -> IDENT MULEQ . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 152

state 105

    (63) expr -> IDENT MINUSEQ . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 153

state 106

    (64) expr -> IDENT PLUSEQ . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 154

state 107

    (76) expr -> IDENT . . SIZE
    SIZE            shift and go to state 155


state 108

    (77) expr -> IDENT ( . args )
    (103) args -> . empty
    (104) args -> . arg_list
    (111) empty -> .
    (105) arg_list -> . expr
    (106) arg_list -> . arg_list , expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    )               reduce using rule 111 (empty -> .)
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    args                           shift and go to state 156
    empty                          shift and go to state 157
    arg_list                       shift and go to state 158
    expr                           shift and go to state 159

state 109

    (78) expr -> IDENT [ . expr ]
    (101) expr -> IDENT [ . expr ] = expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 160

state 110

    (102) expr -> IDENT = . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 161

state 111

    (109) scanf_stmt -> SCANF ( . STRING , arg_list ) ;
    STRING          shift and go to state 162


state 112

    (107) printf_stmt -> PRINTF ( . STRING , arg_list ) ;
    (108) printf_stmt -> PRINTF ( . STRING ) ;
    STRING          shift and go to state 163


state 113

    (54) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 164

state 114

    (52) expr_stmt -> expr ; .
    }               reduce using rule 52 (expr_stmt -> expr ; .)
    SPRINTF         reduce using rule 52 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 52 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 52 (expr_stmt -> expr ; .)
    FOR             reduce using rule 52 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 52 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 52 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 52 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 52 (expr_stmt -> expr ; .)
    IF              reduce using rule 52 (expr_stmt -> expr ; .)
    {               reduce using rule 52 (expr_stmt -> expr ; .)
    ;               reduce using rule 52 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 52 (expr_stmt -> expr ; .)
    MINUSMINUS      reduce using rule 52 (expr_stmt -> expr ; .)
    PLUSPLUS        reduce using rule 52 (expr_stmt -> expr ; .)
    NEW             reduce using rule 52 (expr_stmt -> expr ; .)
    STRING          reduce using rule 52 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 52 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 52 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 52 (expr_stmt -> expr ; .)
    CAST            reduce using rule 52 (expr_stmt -> expr ; .)
    INTTOFLOAT      reduce using rule 52 (expr_stmt -> expr ; .)
    (               reduce using rule 52 (expr_stmt -> expr ; .)
    +               reduce using rule 52 (expr_stmt -> expr ; .)
    -               reduce using rule 52 (expr_stmt -> expr ; .)
    !               reduce using rule 52 (expr_stmt -> expr ; .)
    SUPER           reduce using rule 52 (expr_stmt -> expr ; .)
    THIS            reduce using rule 52 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 52 (expr_stmt -> expr ; .)


state 115

    (67) expr -> expr MINUSMINUS .
    ;               reduce using rule 67 (expr -> expr MINUSMINUS .)
    MINUSMINUS      reduce using rule 67 (expr -> expr MINUSMINUS .)
    PLUSPLUS        reduce using rule 67 (expr -> expr MINUSMINUS .)
    AND             reduce using rule 67 (expr -> expr MINUSMINUS .)
    OR              reduce using rule 67 (expr -> expr MINUSMINUS .)
    %               reduce using rule 67 (expr -> expr MINUSMINUS .)
    /               reduce using rule 67 (expr -> expr MINUSMINUS .)
    *               reduce using rule 67 (expr -> expr MINUSMINUS .)
    -               reduce using rule 67 (expr -> expr MINUSMINUS .)
    +               reduce using rule 67 (expr -> expr MINUSMINUS .)
    >               reduce using rule 67 (expr -> expr MINUSMINUS .)
    GE              reduce using rule 67 (expr -> expr MINUSMINUS .)
    <               reduce using rule 67 (expr -> expr MINUSMINUS .)
    LE              reduce using rule 67 (expr -> expr MINUSMINUS .)
    NE              reduce using rule 67 (expr -> expr MINUSMINUS .)
    EQ              reduce using rule 67 (expr -> expr MINUSMINUS .)
    POINT           reduce using rule 67 (expr -> expr MINUSMINUS .)
    )               reduce using rule 67 (expr -> expr MINUSMINUS .)
    ,               reduce using rule 67 (expr -> expr MINUSMINUS .)
    ]               reduce using rule 67 (expr -> expr MINUSMINUS .)


state 116

    (68) expr -> expr PLUSPLUS .
    ;               reduce using rule 68 (expr -> expr PLUSPLUS .)
    MINUSMINUS      reduce using rule 68 (expr -> expr PLUSPLUS .)
    PLUSPLUS        reduce using rule 68 (expr -> expr PLUSPLUS .)
    AND             reduce using rule 68 (expr -> expr PLUSPLUS .)
    OR              reduce using rule 68 (expr -> expr PLUSPLUS .)
    %               reduce using rule 68 (expr -> expr PLUSPLUS .)
    /               reduce using rule 68 (expr -> expr PLUSPLUS .)
    *               reduce using rule 68 (expr -> expr PLUSPLUS .)
    -               reduce using rule 68 (expr -> expr PLUSPLUS .)
    +               reduce using rule 68 (expr -> expr PLUSPLUS .)
    >               reduce using rule 68 (expr -> expr PLUSPLUS .)
    GE              reduce using rule 68 (expr -> expr PLUSPLUS .)
    <               reduce using rule 68 (expr -> expr PLUSPLUS .)
    LE              reduce using rule 68 (expr -> expr PLUSPLUS .)
    NE              reduce using rule 68 (expr -> expr PLUSPLUS .)
    EQ              reduce using rule 68 (expr -> expr PLUSPLUS .)
    POINT           reduce using rule 68 (expr -> expr PLUSPLUS .)
    )               reduce using rule 68 (expr -> expr PLUSPLUS .)
    ,               reduce using rule 68 (expr -> expr PLUSPLUS .)
    ]               reduce using rule 68 (expr -> expr PLUSPLUS .)


state 117

    (84) expr -> expr AND . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 165

state 118

    (85) expr -> expr OR . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 166

state 119

    (86) expr -> expr % . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 167

state 120

    (87) expr -> expr / . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 168

state 121

    (88) expr -> expr * . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 169

state 122

    (89) expr -> expr - . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 170

state 123

    (90) expr -> expr + . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 171

state 124

    (91) expr -> expr > . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 172

state 125

    (92) expr -> expr GE . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 173

state 126

    (93) expr -> expr < . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 174

state 127

    (94) expr -> expr LE . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 175

state 128

    (95) expr -> expr NE . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 176

state 129

    (96) expr -> expr EQ . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 177

state 130

    (97) expr -> expr POINT . IDENT = expr
    (98) expr -> expr POINT . IDENT
    IDENT           shift and go to state 178


state 131

    (59) break_stmt -> CONTINUE ; .
    }               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 59 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 59 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 59 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 59 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 59 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 59 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 59 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 59 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 59 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 59 (break_stmt -> CONTINUE ; .)
    MINUSMINUS      reduce using rule 59 (break_stmt -> CONTINUE ; .)
    PLUSPLUS        reduce using rule 59 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 59 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 59 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 59 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 59 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 59 (break_stmt -> CONTINUE ; .)
    CAST            reduce using rule 59 (break_stmt -> CONTINUE ; .)
    INTTOFLOAT      reduce using rule 59 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 59 (break_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 59 (break_stmt -> CONTINUE ; .)
    THIS            reduce using rule 59 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 59 (break_stmt -> CONTINUE ; .)


state 132

    (60) break_stmt -> BREAK ; .
    }               reduce using rule 60 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 60 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 60 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 60 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 60 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 60 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 60 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 60 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 60 (break_stmt -> BREAK ; .)
    IF              reduce using rule 60 (break_stmt -> BREAK ; .)
    {               reduce using rule 60 (break_stmt -> BREAK ; .)
    ;               reduce using rule 60 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 60 (break_stmt -> BREAK ; .)
    MINUSMINUS      reduce using rule 60 (break_stmt -> BREAK ; .)
    PLUSPLUS        reduce using rule 60 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 60 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 60 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 60 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 60 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 60 (break_stmt -> BREAK ; .)
    CAST            reduce using rule 60 (break_stmt -> BREAK ; .)
    INTTOFLOAT      reduce using rule 60 (break_stmt -> BREAK ; .)
    (               reduce using rule 60 (break_stmt -> BREAK ; .)
    +               reduce using rule 60 (break_stmt -> BREAK ; .)
    -               reduce using rule 60 (break_stmt -> BREAK ; .)
    !               reduce using rule 60 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 60 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 60 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 60 (break_stmt -> BREAK ; .)


state 133

    (57) return_stmt -> RETURN expr . ;
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               shift and go to state 179
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 134

    (58) return_stmt -> RETURN ; .
    }               reduce using rule 58 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 58 (return_stmt -> RETURN ; .)
    SCANF           reduce using rule 58 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 58 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 58 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 58 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 58 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 58 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 58 (return_stmt -> RETURN ; .)
    IF              reduce using rule 58 (return_stmt -> RETURN ; .)
    {               reduce using rule 58 (return_stmt -> RETURN ; .)
    ;               reduce using rule 58 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 58 (return_stmt -> RETURN ; .)
    MINUSMINUS      reduce using rule 58 (return_stmt -> RETURN ; .)
    PLUSPLUS        reduce using rule 58 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 58 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 58 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 58 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 58 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 58 (return_stmt -> RETURN ; .)
    CAST            reduce using rule 58 (return_stmt -> RETURN ; .)
    INTTOFLOAT      reduce using rule 58 (return_stmt -> RETURN ; .)
    (               reduce using rule 58 (return_stmt -> RETURN ; .)
    +               reduce using rule 58 (return_stmt -> RETURN ; .)
    -               reduce using rule 58 (return_stmt -> RETURN ; .)
    !               reduce using rule 58 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 58 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 58 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 58 (return_stmt -> RETURN ; .)


state 135

    (53) while_stmt -> WHILE ( . expr ) stmt
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 180

state 136

    (55) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (56) if_stmt -> IF ( . expr ) stmt
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 181

state 137

    (65) expr -> MINUSMINUS expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 65 (expr -> MINUSMINUS expr .)
    MINUSMINUS      reduce using rule 65 (expr -> MINUSMINUS expr .)
    PLUSPLUS        reduce using rule 65 (expr -> MINUSMINUS expr .)
    POINT           reduce using rule 65 (expr -> MINUSMINUS expr .)
    )               reduce using rule 65 (expr -> MINUSMINUS expr .)
    ,               reduce using rule 65 (expr -> MINUSMINUS expr .)
    ]               reduce using rule 65 (expr -> MINUSMINUS expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 138

    (66) expr -> PLUSPLUS expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 66 (expr -> PLUSPLUS expr .)
    PLUSPLUS        reduce using rule 66 (expr -> PLUSPLUS expr .)
    POINT           reduce using rule 66 (expr -> PLUSPLUS expr .)
    )               reduce using rule 66 (expr -> PLUSPLUS expr .)
    ,               reduce using rule 66 (expr -> PLUSPLUS expr .)
    ]               reduce using rule 66 (expr -> PLUSPLUS expr .)
    MINUSMINUS      shift and go to state 115
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 139

    (69) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 182


state 140

    (74) expr -> CAST type_spec . ( expr )
    (               shift and go to state 183


state 141

    (75) expr -> INTTOFLOAT ( . IDENT )
    IDENT           shift and go to state 184


state 142

    (81) expr -> + expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 81 (expr -> + expr .)
    MINUSMINUS      reduce using rule 81 (expr -> + expr .)
    PLUSPLUS        reduce using rule 81 (expr -> + expr .)
    AND             reduce using rule 81 (expr -> + expr .)
    OR              reduce using rule 81 (expr -> + expr .)
    %               reduce using rule 81 (expr -> + expr .)
    /               reduce using rule 81 (expr -> + expr .)
    *               reduce using rule 81 (expr -> + expr .)
    -               reduce using rule 81 (expr -> + expr .)
    +               reduce using rule 81 (expr -> + expr .)
    >               reduce using rule 81 (expr -> + expr .)
    GE              reduce using rule 81 (expr -> + expr .)
    <               reduce using rule 81 (expr -> + expr .)
    LE              reduce using rule 81 (expr -> + expr .)
    NE              reduce using rule 81 (expr -> + expr .)
    EQ              reduce using rule 81 (expr -> + expr .)
    POINT           reduce using rule 81 (expr -> + expr .)
    )               reduce using rule 81 (expr -> + expr .)
    ,               reduce using rule 81 (expr -> + expr .)
    ]               reduce using rule 81 (expr -> + expr .)


state 143

    (82) expr -> - expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 82 (expr -> - expr .)
    MINUSMINUS      reduce using rule 82 (expr -> - expr .)
    PLUSPLUS        reduce using rule 82 (expr -> - expr .)
    AND             reduce using rule 82 (expr -> - expr .)
    OR              reduce using rule 82 (expr -> - expr .)
    %               reduce using rule 82 (expr -> - expr .)
    /               reduce using rule 82 (expr -> - expr .)
    *               reduce using rule 82 (expr -> - expr .)
    -               reduce using rule 82 (expr -> - expr .)
    +               reduce using rule 82 (expr -> - expr .)
    >               reduce using rule 82 (expr -> - expr .)
    GE              reduce using rule 82 (expr -> - expr .)
    <               reduce using rule 82 (expr -> - expr .)
    LE              reduce using rule 82 (expr -> - expr .)
    NE              reduce using rule 82 (expr -> - expr .)
    EQ              reduce using rule 82 (expr -> - expr .)
    POINT           reduce using rule 82 (expr -> - expr .)
    )               reduce using rule 82 (expr -> - expr .)
    ,               reduce using rule 82 (expr -> - expr .)
    ]               reduce using rule 82 (expr -> - expr .)


state 144

    (83) expr -> ! expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 83 (expr -> ! expr .)
    MINUSMINUS      reduce using rule 83 (expr -> ! expr .)
    PLUSPLUS        reduce using rule 83 (expr -> ! expr .)
    AND             reduce using rule 83 (expr -> ! expr .)
    OR              reduce using rule 83 (expr -> ! expr .)
    %               reduce using rule 83 (expr -> ! expr .)
    /               reduce using rule 83 (expr -> ! expr .)
    *               reduce using rule 83 (expr -> ! expr .)
    -               reduce using rule 83 (expr -> ! expr .)
    +               reduce using rule 83 (expr -> ! expr .)
    >               reduce using rule 83 (expr -> ! expr .)
    GE              reduce using rule 83 (expr -> ! expr .)
    <               reduce using rule 83 (expr -> ! expr .)
    LE              reduce using rule 83 (expr -> ! expr .)
    NE              reduce using rule 83 (expr -> ! expr .)
    EQ              reduce using rule 83 (expr -> ! expr .)
    POINT           reduce using rule 83 (expr -> ! expr .)
    )               reduce using rule 83 (expr -> ! expr .)
    ,               reduce using rule 83 (expr -> ! expr .)
    ]               reduce using rule 83 (expr -> ! expr .)


state 145

    (99) expr -> SUPER POINT . IDENT
    IDENT           shift and go to state 185


state 146

    (37) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 186


state 147

    (38) local_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    SCANF           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    MINUSMINUS      reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    PLUSPLUS        reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    CAST            reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    INTTOFLOAT      reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 38 (local_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 38 (local_decl -> type_spec IDENT ; .)


state 148

    (14) method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .
    FLOAT           reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    INT             reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    BOOL            reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    VOID            reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    }               reduce using rule 14 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)


state 149

    (110) sprintf_stmt -> SPRINTF ( IDENT . , STRING , arg_list ) ;
    ,               shift and go to state 187


state 150

    (80) expr -> ( expr ) .
    ;               reduce using rule 80 (expr -> ( expr ) .)
    MINUSMINUS      reduce using rule 80 (expr -> ( expr ) .)
    PLUSPLUS        reduce using rule 80 (expr -> ( expr ) .)
    AND             reduce using rule 80 (expr -> ( expr ) .)
    OR              reduce using rule 80 (expr -> ( expr ) .)
    %               reduce using rule 80 (expr -> ( expr ) .)
    /               reduce using rule 80 (expr -> ( expr ) .)
    *               reduce using rule 80 (expr -> ( expr ) .)
    -               reduce using rule 80 (expr -> ( expr ) .)
    +               reduce using rule 80 (expr -> ( expr ) .)
    >               reduce using rule 80 (expr -> ( expr ) .)
    GE              reduce using rule 80 (expr -> ( expr ) .)
    <               reduce using rule 80 (expr -> ( expr ) .)
    LE              reduce using rule 80 (expr -> ( expr ) .)
    NE              reduce using rule 80 (expr -> ( expr ) .)
    EQ              reduce using rule 80 (expr -> ( expr ) .)
    POINT           reduce using rule 80 (expr -> ( expr ) .)
    )               reduce using rule 80 (expr -> ( expr ) .)
    ,               reduce using rule 80 (expr -> ( expr ) .)
    ]               reduce using rule 80 (expr -> ( expr ) .)


state 151

    (61) expr -> IDENT DIVEQ expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    MINUSMINUS      reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    PLUSPLUS        reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    POINT           reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    )               reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    ,               reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    ]               reduce using rule 61 (expr -> IDENT DIVEQ expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 152

    (62) expr -> IDENT MULEQ expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 62 (expr -> IDENT MULEQ expr .)
    MINUSMINUS      reduce using rule 62 (expr -> IDENT MULEQ expr .)
    PLUSPLUS        reduce using rule 62 (expr -> IDENT MULEQ expr .)
    POINT           reduce using rule 62 (expr -> IDENT MULEQ expr .)
    )               reduce using rule 62 (expr -> IDENT MULEQ expr .)
    ,               reduce using rule 62 (expr -> IDENT MULEQ expr .)
    ]               reduce using rule 62 (expr -> IDENT MULEQ expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 153

    (63) expr -> IDENT MINUSEQ expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    MINUSMINUS      reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    PLUSPLUS        reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    POINT           reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    )               reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    ,               reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    ]               reduce using rule 63 (expr -> IDENT MINUSEQ expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 154

    (64) expr -> IDENT PLUSEQ expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    MINUSMINUS      reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    PLUSPLUS        reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    POINT           reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    )               reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    ,               reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    ]               reduce using rule 64 (expr -> IDENT PLUSEQ expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 155

    (76) expr -> IDENT . SIZE .
    ;               reduce using rule 76 (expr -> IDENT . SIZE .)
    MINUSMINUS      reduce using rule 76 (expr -> IDENT . SIZE .)
    PLUSPLUS        reduce using rule 76 (expr -> IDENT . SIZE .)
    AND             reduce using rule 76 (expr -> IDENT . SIZE .)
    OR              reduce using rule 76 (expr -> IDENT . SIZE .)
    %               reduce using rule 76 (expr -> IDENT . SIZE .)
    /               reduce using rule 76 (expr -> IDENT . SIZE .)
    *               reduce using rule 76 (expr -> IDENT . SIZE .)
    -               reduce using rule 76 (expr -> IDENT . SIZE .)
    +               reduce using rule 76 (expr -> IDENT . SIZE .)
    >               reduce using rule 76 (expr -> IDENT . SIZE .)
    GE              reduce using rule 76 (expr -> IDENT . SIZE .)
    <               reduce using rule 76 (expr -> IDENT . SIZE .)
    LE              reduce using rule 76 (expr -> IDENT . SIZE .)
    NE              reduce using rule 76 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 76 (expr -> IDENT . SIZE .)
    POINT           reduce using rule 76 (expr -> IDENT . SIZE .)
    )               reduce using rule 76 (expr -> IDENT . SIZE .)
    ,               reduce using rule 76 (expr -> IDENT . SIZE .)
    ]               reduce using rule 76 (expr -> IDENT . SIZE .)


state 156

    (77) expr -> IDENT ( args . )
    )               shift and go to state 188


state 157

    (103) args -> empty .
    )               reduce using rule 103 (args -> empty .)


state 158

    (104) args -> arg_list .
    (106) arg_list -> arg_list . , expr
    )               reduce using rule 104 (args -> arg_list .)
    ,               shift and go to state 189


state 159

    (105) arg_list -> expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ,               reduce using rule 105 (arg_list -> expr .)
    )               reduce using rule 105 (arg_list -> expr .)
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 160

    (78) expr -> IDENT [ expr . ]
    (101) expr -> IDENT [ expr . ] = expr
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ]               shift and go to state 190
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 161

    (102) expr -> IDENT = expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 102 (expr -> IDENT = expr .)
    MINUSMINUS      reduce using rule 102 (expr -> IDENT = expr .)
    PLUSPLUS        reduce using rule 102 (expr -> IDENT = expr .)
    POINT           reduce using rule 102 (expr -> IDENT = expr .)
    )               reduce using rule 102 (expr -> IDENT = expr .)
    ,               reduce using rule 102 (expr -> IDENT = expr .)
    ]               reduce using rule 102 (expr -> IDENT = expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 162

    (109) scanf_stmt -> SCANF ( STRING . , arg_list ) ;
    ,               shift and go to state 191


state 163

    (107) printf_stmt -> PRINTF ( STRING . , arg_list ) ;
    (108) printf_stmt -> PRINTF ( STRING . ) ;
    ,               shift and go to state 192
    )               shift and go to state 193


state 164

    (54) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               shift and go to state 194
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 165

    (84) expr -> expr AND expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 84 (expr -> expr AND expr .)
    MINUSMINUS      reduce using rule 84 (expr -> expr AND expr .)
    PLUSPLUS        reduce using rule 84 (expr -> expr AND expr .)
    AND             reduce using rule 84 (expr -> expr AND expr .)
    OR              reduce using rule 84 (expr -> expr AND expr .)
    POINT           reduce using rule 84 (expr -> expr AND expr .)
    )               reduce using rule 84 (expr -> expr AND expr .)
    ,               reduce using rule 84 (expr -> expr AND expr .)
    ]               reduce using rule 84 (expr -> expr AND expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 166

    (85) expr -> expr OR expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 85 (expr -> expr OR expr .)
    MINUSMINUS      reduce using rule 85 (expr -> expr OR expr .)
    PLUSPLUS        reduce using rule 85 (expr -> expr OR expr .)
    OR              reduce using rule 85 (expr -> expr OR expr .)
    POINT           reduce using rule 85 (expr -> expr OR expr .)
    )               reduce using rule 85 (expr -> expr OR expr .)
    ,               reduce using rule 85 (expr -> expr OR expr .)
    ]               reduce using rule 85 (expr -> expr OR expr .)
    AND             shift and go to state 117
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 167

    (86) expr -> expr % expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 86 (expr -> expr % expr .)
    MINUSMINUS      reduce using rule 86 (expr -> expr % expr .)
    PLUSPLUS        reduce using rule 86 (expr -> expr % expr .)
    AND             reduce using rule 86 (expr -> expr % expr .)
    OR              reduce using rule 86 (expr -> expr % expr .)
    %               reduce using rule 86 (expr -> expr % expr .)
    /               reduce using rule 86 (expr -> expr % expr .)
    *               reduce using rule 86 (expr -> expr % expr .)
    -               reduce using rule 86 (expr -> expr % expr .)
    +               reduce using rule 86 (expr -> expr % expr .)
    >               reduce using rule 86 (expr -> expr % expr .)
    GE              reduce using rule 86 (expr -> expr % expr .)
    <               reduce using rule 86 (expr -> expr % expr .)
    LE              reduce using rule 86 (expr -> expr % expr .)
    NE              reduce using rule 86 (expr -> expr % expr .)
    EQ              reduce using rule 86 (expr -> expr % expr .)
    POINT           reduce using rule 86 (expr -> expr % expr .)
    )               reduce using rule 86 (expr -> expr % expr .)
    ,               reduce using rule 86 (expr -> expr % expr .)
    ]               reduce using rule 86 (expr -> expr % expr .)


state 168

    (87) expr -> expr / expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 87 (expr -> expr / expr .)
    MINUSMINUS      reduce using rule 87 (expr -> expr / expr .)
    PLUSPLUS        reduce using rule 87 (expr -> expr / expr .)
    AND             reduce using rule 87 (expr -> expr / expr .)
    OR              reduce using rule 87 (expr -> expr / expr .)
    %               reduce using rule 87 (expr -> expr / expr .)
    /               reduce using rule 87 (expr -> expr / expr .)
    *               reduce using rule 87 (expr -> expr / expr .)
    -               reduce using rule 87 (expr -> expr / expr .)
    +               reduce using rule 87 (expr -> expr / expr .)
    >               reduce using rule 87 (expr -> expr / expr .)
    GE              reduce using rule 87 (expr -> expr / expr .)
    <               reduce using rule 87 (expr -> expr / expr .)
    LE              reduce using rule 87 (expr -> expr / expr .)
    NE              reduce using rule 87 (expr -> expr / expr .)
    EQ              reduce using rule 87 (expr -> expr / expr .)
    POINT           reduce using rule 87 (expr -> expr / expr .)
    )               reduce using rule 87 (expr -> expr / expr .)
    ,               reduce using rule 87 (expr -> expr / expr .)
    ]               reduce using rule 87 (expr -> expr / expr .)


state 169

    (88) expr -> expr * expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 88 (expr -> expr * expr .)
    MINUSMINUS      reduce using rule 88 (expr -> expr * expr .)
    PLUSPLUS        reduce using rule 88 (expr -> expr * expr .)
    AND             reduce using rule 88 (expr -> expr * expr .)
    OR              reduce using rule 88 (expr -> expr * expr .)
    %               reduce using rule 88 (expr -> expr * expr .)
    /               reduce using rule 88 (expr -> expr * expr .)
    *               reduce using rule 88 (expr -> expr * expr .)
    -               reduce using rule 88 (expr -> expr * expr .)
    +               reduce using rule 88 (expr -> expr * expr .)
    >               reduce using rule 88 (expr -> expr * expr .)
    GE              reduce using rule 88 (expr -> expr * expr .)
    <               reduce using rule 88 (expr -> expr * expr .)
    LE              reduce using rule 88 (expr -> expr * expr .)
    NE              reduce using rule 88 (expr -> expr * expr .)
    EQ              reduce using rule 88 (expr -> expr * expr .)
    POINT           reduce using rule 88 (expr -> expr * expr .)
    )               reduce using rule 88 (expr -> expr * expr .)
    ,               reduce using rule 88 (expr -> expr * expr .)
    ]               reduce using rule 88 (expr -> expr * expr .)


state 170

    (89) expr -> expr - expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 89 (expr -> expr - expr .)
    MINUSMINUS      reduce using rule 89 (expr -> expr - expr .)
    PLUSPLUS        reduce using rule 89 (expr -> expr - expr .)
    AND             reduce using rule 89 (expr -> expr - expr .)
    OR              reduce using rule 89 (expr -> expr - expr .)
    -               reduce using rule 89 (expr -> expr - expr .)
    +               reduce using rule 89 (expr -> expr - expr .)
    >               reduce using rule 89 (expr -> expr - expr .)
    GE              reduce using rule 89 (expr -> expr - expr .)
    <               reduce using rule 89 (expr -> expr - expr .)
    LE              reduce using rule 89 (expr -> expr - expr .)
    NE              reduce using rule 89 (expr -> expr - expr .)
    EQ              reduce using rule 89 (expr -> expr - expr .)
    POINT           reduce using rule 89 (expr -> expr - expr .)
    )               reduce using rule 89 (expr -> expr - expr .)
    ,               reduce using rule 89 (expr -> expr - expr .)
    ]               reduce using rule 89 (expr -> expr - expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121


state 171

    (90) expr -> expr + expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 90 (expr -> expr + expr .)
    MINUSMINUS      reduce using rule 90 (expr -> expr + expr .)
    PLUSPLUS        reduce using rule 90 (expr -> expr + expr .)
    AND             reduce using rule 90 (expr -> expr + expr .)
    OR              reduce using rule 90 (expr -> expr + expr .)
    -               reduce using rule 90 (expr -> expr + expr .)
    +               reduce using rule 90 (expr -> expr + expr .)
    >               reduce using rule 90 (expr -> expr + expr .)
    GE              reduce using rule 90 (expr -> expr + expr .)
    <               reduce using rule 90 (expr -> expr + expr .)
    LE              reduce using rule 90 (expr -> expr + expr .)
    NE              reduce using rule 90 (expr -> expr + expr .)
    EQ              reduce using rule 90 (expr -> expr + expr .)
    POINT           reduce using rule 90 (expr -> expr + expr .)
    )               reduce using rule 90 (expr -> expr + expr .)
    ,               reduce using rule 90 (expr -> expr + expr .)
    ]               reduce using rule 90 (expr -> expr + expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121


state 172

    (91) expr -> expr > expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 91 (expr -> expr > expr .)
    MINUSMINUS      reduce using rule 91 (expr -> expr > expr .)
    PLUSPLUS        reduce using rule 91 (expr -> expr > expr .)
    AND             reduce using rule 91 (expr -> expr > expr .)
    OR              reduce using rule 91 (expr -> expr > expr .)
    >               reduce using rule 91 (expr -> expr > expr .)
    GE              reduce using rule 91 (expr -> expr > expr .)
    <               reduce using rule 91 (expr -> expr > expr .)
    LE              reduce using rule 91 (expr -> expr > expr .)
    NE              reduce using rule 91 (expr -> expr > expr .)
    EQ              reduce using rule 91 (expr -> expr > expr .)
    POINT           reduce using rule 91 (expr -> expr > expr .)
    )               reduce using rule 91 (expr -> expr > expr .)
    ,               reduce using rule 91 (expr -> expr > expr .)
    ]               reduce using rule 91 (expr -> expr > expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123


state 173

    (92) expr -> expr GE expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 92 (expr -> expr GE expr .)
    MINUSMINUS      reduce using rule 92 (expr -> expr GE expr .)
    PLUSPLUS        reduce using rule 92 (expr -> expr GE expr .)
    AND             reduce using rule 92 (expr -> expr GE expr .)
    OR              reduce using rule 92 (expr -> expr GE expr .)
    >               reduce using rule 92 (expr -> expr GE expr .)
    GE              reduce using rule 92 (expr -> expr GE expr .)
    <               reduce using rule 92 (expr -> expr GE expr .)
    LE              reduce using rule 92 (expr -> expr GE expr .)
    NE              reduce using rule 92 (expr -> expr GE expr .)
    EQ              reduce using rule 92 (expr -> expr GE expr .)
    POINT           reduce using rule 92 (expr -> expr GE expr .)
    )               reduce using rule 92 (expr -> expr GE expr .)
    ,               reduce using rule 92 (expr -> expr GE expr .)
    ]               reduce using rule 92 (expr -> expr GE expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123


state 174

    (93) expr -> expr < expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 93 (expr -> expr < expr .)
    MINUSMINUS      reduce using rule 93 (expr -> expr < expr .)
    PLUSPLUS        reduce using rule 93 (expr -> expr < expr .)
    AND             reduce using rule 93 (expr -> expr < expr .)
    OR              reduce using rule 93 (expr -> expr < expr .)
    >               reduce using rule 93 (expr -> expr < expr .)
    GE              reduce using rule 93 (expr -> expr < expr .)
    <               reduce using rule 93 (expr -> expr < expr .)
    LE              reduce using rule 93 (expr -> expr < expr .)
    NE              reduce using rule 93 (expr -> expr < expr .)
    EQ              reduce using rule 93 (expr -> expr < expr .)
    POINT           reduce using rule 93 (expr -> expr < expr .)
    )               reduce using rule 93 (expr -> expr < expr .)
    ,               reduce using rule 93 (expr -> expr < expr .)
    ]               reduce using rule 93 (expr -> expr < expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123


state 175

    (94) expr -> expr LE expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 94 (expr -> expr LE expr .)
    MINUSMINUS      reduce using rule 94 (expr -> expr LE expr .)
    PLUSPLUS        reduce using rule 94 (expr -> expr LE expr .)
    AND             reduce using rule 94 (expr -> expr LE expr .)
    OR              reduce using rule 94 (expr -> expr LE expr .)
    >               reduce using rule 94 (expr -> expr LE expr .)
    GE              reduce using rule 94 (expr -> expr LE expr .)
    <               reduce using rule 94 (expr -> expr LE expr .)
    LE              reduce using rule 94 (expr -> expr LE expr .)
    NE              reduce using rule 94 (expr -> expr LE expr .)
    EQ              reduce using rule 94 (expr -> expr LE expr .)
    POINT           reduce using rule 94 (expr -> expr LE expr .)
    )               reduce using rule 94 (expr -> expr LE expr .)
    ,               reduce using rule 94 (expr -> expr LE expr .)
    ]               reduce using rule 94 (expr -> expr LE expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123


state 176

    (95) expr -> expr NE expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 95 (expr -> expr NE expr .)
    MINUSMINUS      reduce using rule 95 (expr -> expr NE expr .)
    PLUSPLUS        reduce using rule 95 (expr -> expr NE expr .)
    AND             reduce using rule 95 (expr -> expr NE expr .)
    OR              reduce using rule 95 (expr -> expr NE expr .)
    NE              reduce using rule 95 (expr -> expr NE expr .)
    EQ              reduce using rule 95 (expr -> expr NE expr .)
    POINT           reduce using rule 95 (expr -> expr NE expr .)
    )               reduce using rule 95 (expr -> expr NE expr .)
    ,               reduce using rule 95 (expr -> expr NE expr .)
    ]               reduce using rule 95 (expr -> expr NE expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127


state 177

    (96) expr -> expr EQ expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 96 (expr -> expr EQ expr .)
    MINUSMINUS      reduce using rule 96 (expr -> expr EQ expr .)
    PLUSPLUS        reduce using rule 96 (expr -> expr EQ expr .)
    AND             reduce using rule 96 (expr -> expr EQ expr .)
    OR              reduce using rule 96 (expr -> expr EQ expr .)
    NE              reduce using rule 96 (expr -> expr EQ expr .)
    EQ              reduce using rule 96 (expr -> expr EQ expr .)
    POINT           reduce using rule 96 (expr -> expr EQ expr .)
    )               reduce using rule 96 (expr -> expr EQ expr .)
    ,               reduce using rule 96 (expr -> expr EQ expr .)
    ]               reduce using rule 96 (expr -> expr EQ expr .)
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127


state 178

    (97) expr -> expr POINT IDENT . = expr
    (98) expr -> expr POINT IDENT .
    =               shift and go to state 195
    ;               reduce using rule 98 (expr -> expr POINT IDENT .)
    MINUSMINUS      reduce using rule 98 (expr -> expr POINT IDENT .)
    PLUSPLUS        reduce using rule 98 (expr -> expr POINT IDENT .)
    AND             reduce using rule 98 (expr -> expr POINT IDENT .)
    OR              reduce using rule 98 (expr -> expr POINT IDENT .)
    %               reduce using rule 98 (expr -> expr POINT IDENT .)
    /               reduce using rule 98 (expr -> expr POINT IDENT .)
    *               reduce using rule 98 (expr -> expr POINT IDENT .)
    -               reduce using rule 98 (expr -> expr POINT IDENT .)
    +               reduce using rule 98 (expr -> expr POINT IDENT .)
    >               reduce using rule 98 (expr -> expr POINT IDENT .)
    GE              reduce using rule 98 (expr -> expr POINT IDENT .)
    <               reduce using rule 98 (expr -> expr POINT IDENT .)
    LE              reduce using rule 98 (expr -> expr POINT IDENT .)
    NE              reduce using rule 98 (expr -> expr POINT IDENT .)
    EQ              reduce using rule 98 (expr -> expr POINT IDENT .)
    POINT           reduce using rule 98 (expr -> expr POINT IDENT .)
    )               reduce using rule 98 (expr -> expr POINT IDENT .)
    ,               reduce using rule 98 (expr -> expr POINT IDENT .)
    ]               reduce using rule 98 (expr -> expr POINT IDENT .)


state 179

    (57) return_stmt -> RETURN expr ; .
    }               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 57 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 57 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 57 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 57 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 57 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 57 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 57 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 57 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 57 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 57 (return_stmt -> RETURN expr ; .)
    MINUSMINUS      reduce using rule 57 (return_stmt -> RETURN expr ; .)
    PLUSPLUS        reduce using rule 57 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 57 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 57 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 57 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 57 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 57 (return_stmt -> RETURN expr ; .)
    CAST            reduce using rule 57 (return_stmt -> RETURN expr ; .)
    INTTOFLOAT      reduce using rule 57 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 57 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 57 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 57 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 57 (return_stmt -> RETURN expr ; .)


state 180

    (53) while_stmt -> WHILE ( expr . ) stmt
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    )               shift and go to state 196
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 181

    (55) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (56) if_stmt -> IF ( expr . ) stmt
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    )               shift and go to state 197
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 182

    (69) expr -> NEW type_spec [ . expr ]
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 198

state 183

    (74) expr -> CAST type_spec ( . expr )
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 199

state 184

    (75) expr -> INTTOFLOAT ( IDENT . )
    )               shift and go to state 200


state 185

    (99) expr -> SUPER POINT IDENT .
    ;               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    MINUSMINUS      reduce using rule 99 (expr -> SUPER POINT IDENT .)
    PLUSPLUS        reduce using rule 99 (expr -> SUPER POINT IDENT .)
    AND             reduce using rule 99 (expr -> SUPER POINT IDENT .)
    OR              reduce using rule 99 (expr -> SUPER POINT IDENT .)
    %               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    /               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    *               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    -               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    +               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    >               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    GE              reduce using rule 99 (expr -> SUPER POINT IDENT .)
    <               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    LE              reduce using rule 99 (expr -> SUPER POINT IDENT .)
    NE              reduce using rule 99 (expr -> SUPER POINT IDENT .)
    EQ              reduce using rule 99 (expr -> SUPER POINT IDENT .)
    POINT           reduce using rule 99 (expr -> SUPER POINT IDENT .)
    )               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    ,               reduce using rule 99 (expr -> SUPER POINT IDENT .)
    ]               reduce using rule 99 (expr -> SUPER POINT IDENT .)


state 186

    (37) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 201


state 187

    (110) sprintf_stmt -> SPRINTF ( IDENT , . STRING , arg_list ) ;
    STRING          shift and go to state 202


state 188

    (77) expr -> IDENT ( args ) .
    ;               reduce using rule 77 (expr -> IDENT ( args ) .)
    MINUSMINUS      reduce using rule 77 (expr -> IDENT ( args ) .)
    PLUSPLUS        reduce using rule 77 (expr -> IDENT ( args ) .)
    AND             reduce using rule 77 (expr -> IDENT ( args ) .)
    OR              reduce using rule 77 (expr -> IDENT ( args ) .)
    %               reduce using rule 77 (expr -> IDENT ( args ) .)
    /               reduce using rule 77 (expr -> IDENT ( args ) .)
    *               reduce using rule 77 (expr -> IDENT ( args ) .)
    -               reduce using rule 77 (expr -> IDENT ( args ) .)
    +               reduce using rule 77 (expr -> IDENT ( args ) .)
    >               reduce using rule 77 (expr -> IDENT ( args ) .)
    GE              reduce using rule 77 (expr -> IDENT ( args ) .)
    <               reduce using rule 77 (expr -> IDENT ( args ) .)
    LE              reduce using rule 77 (expr -> IDENT ( args ) .)
    NE              reduce using rule 77 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 77 (expr -> IDENT ( args ) .)
    POINT           reduce using rule 77 (expr -> IDENT ( args ) .)
    )               reduce using rule 77 (expr -> IDENT ( args ) .)
    ,               reduce using rule 77 (expr -> IDENT ( args ) .)
    ]               reduce using rule 77 (expr -> IDENT ( args ) .)


state 189

    (106) arg_list -> arg_list , . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 203

state 190

    (78) expr -> IDENT [ expr ] .
    (101) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 78 (expr -> IDENT [ expr ] .)
    MINUSMINUS      reduce using rule 78 (expr -> IDENT [ expr ] .)
    PLUSPLUS        reduce using rule 78 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 78 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 78 (expr -> IDENT [ expr ] .)
    %               reduce using rule 78 (expr -> IDENT [ expr ] .)
    /               reduce using rule 78 (expr -> IDENT [ expr ] .)
    *               reduce using rule 78 (expr -> IDENT [ expr ] .)
    -               reduce using rule 78 (expr -> IDENT [ expr ] .)
    +               reduce using rule 78 (expr -> IDENT [ expr ] .)
    >               reduce using rule 78 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 78 (expr -> IDENT [ expr ] .)
    <               reduce using rule 78 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 78 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 78 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 78 (expr -> IDENT [ expr ] .)
    POINT           reduce using rule 78 (expr -> IDENT [ expr ] .)
    )               reduce using rule 78 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 78 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 78 (expr -> IDENT [ expr ] .)
    =               shift and go to state 204


state 191

    (109) scanf_stmt -> SCANF ( STRING , . arg_list ) ;
    (105) arg_list -> . expr
    (106) arg_list -> . arg_list , expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    arg_list                       shift and go to state 205
    expr                           shift and go to state 159

state 192

    (107) printf_stmt -> PRINTF ( STRING , . arg_list ) ;
    (105) arg_list -> . expr
    (106) arg_list -> . arg_list , expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    arg_list                       shift and go to state 206
    expr                           shift and go to state 159

state 193

    (108) printf_stmt -> PRINTF ( STRING ) . ;
    ;               shift and go to state 207


state 194

    (54) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 208

state 195

    (97) expr -> expr POINT IDENT = . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 209

state 196

    (53) while_stmt -> WHILE ( expr ) . stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 77
    stmt                           shift and go to state 210
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68

state 197

    (55) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (56) if_stmt -> IF ( expr ) . stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 77
    stmt                           shift and go to state 211
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68

state 198

    (69) expr -> NEW type_spec [ expr . ]
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ]               shift and go to state 212
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 199

    (74) expr -> CAST type_spec ( expr . )
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    )               shift and go to state 213
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 200

    (75) expr -> INTTOFLOAT ( IDENT ) .
    ;               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    MINUSMINUS      reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    PLUSPLUS        reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    AND             reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    OR              reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    %               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    /               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    *               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    -               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    +               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    >               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    GE              reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    <               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    LE              reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    NE              reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    EQ              reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    POINT           reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    )               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    ,               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)
    ]               reduce using rule 75 (expr -> INTTOFLOAT ( IDENT ) .)


state 201

    (37) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    SPRINTF         reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    SCANF           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    PRINTF          reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    MINUSMINUS      reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    PLUSPLUS        reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    CAST            reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    INTTOFLOAT      reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    SUPER           reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)
    THIS            reduce using rule 37 (local_decl -> type_spec IDENT [ ] ; .)


state 202

    (110) sprintf_stmt -> SPRINTF ( IDENT , STRING . , arg_list ) ;
    ,               shift and go to state 214


state 203

    (106) arg_list -> arg_list , expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ,               reduce using rule 106 (arg_list -> arg_list , expr .)
    )               reduce using rule 106 (arg_list -> arg_list , expr .)
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 204

    (101) expr -> IDENT [ expr ] = . expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 215

state 205

    (109) scanf_stmt -> SCANF ( STRING , arg_list . ) ;
    (106) arg_list -> arg_list . , expr
    )               shift and go to state 216
    ,               shift and go to state 189


state 206

    (107) printf_stmt -> PRINTF ( STRING , arg_list . ) ;
    (106) arg_list -> arg_list . , expr
    )               shift and go to state 217
    ,               shift and go to state 189


state 207

    (108) printf_stmt -> PRINTF ( STRING ) ; .
    }               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    SPRINTF         reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    SCANF           reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    CONTINUE        reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    BREAK           reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    WHILE           reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    {               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    ;               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    IDENT           reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    MINUSMINUS      reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    PLUSPLUS        reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    NEW             reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    STRING          reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    FLOAT_LIT       reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    INT_LIT         reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    BOOL_LIT        reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    CAST            reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    INTTOFLOAT      reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    (               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    +               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    -               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    !               reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    SUPER           reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    THIS            reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)
    ELSE            reduce using rule 108 (printf_stmt -> PRINTF ( STRING ) ; .)


state 208

    (54) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               shift and go to state 218
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 209

    (97) expr -> expr POINT IDENT = expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    MINUSMINUS      reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    PLUSPLUS        reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    POINT           reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    )               reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    ,               reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    ]               reduce using rule 97 (expr -> expr POINT IDENT = expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 210

    (53) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    MINUSMINUS      reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    PLUSPLUS        reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    CAST            reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    INTTOFLOAT      reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 53 (while_stmt -> WHILE ( expr ) stmt .)


state 211

    (55) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (56) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 219
    }               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    MINUSMINUS      reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    PLUSPLUS        reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    CAST            reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    INTTOFLOAT      reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 56 (if_stmt -> IF ( expr ) stmt .)


state 212

    (69) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    MINUSMINUS      reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    PLUSPLUS        reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    POINT           reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 69 (expr -> NEW type_spec [ expr ] .)


state 213

    (74) expr -> CAST type_spec ( expr ) .
    ;               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    MINUSMINUS      reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    PLUSPLUS        reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    AND             reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    OR              reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    %               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    /               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    *               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    -               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    +               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    >               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    GE              reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    <               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    LE              reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    NE              reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    EQ              reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    POINT           reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    )               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    ,               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)
    ]               reduce using rule 74 (expr -> CAST type_spec ( expr ) .)


state 214

    (110) sprintf_stmt -> SPRINTF ( IDENT , STRING , . arg_list ) ;
    (105) arg_list -> . expr
    (106) arg_list -> . arg_list , expr
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    arg_list                       shift and go to state 220
    expr                           shift and go to state 159

state 215

    (101) expr -> IDENT [ expr ] = expr .
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    ;               reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    MINUSMINUS      reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    PLUSPLUS        reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    POINT           reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 101 (expr -> IDENT [ expr ] = expr .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129


state 216

    (109) scanf_stmt -> SCANF ( STRING , arg_list ) . ;
    ;               shift and go to state 221


state 217

    (107) printf_stmt -> PRINTF ( STRING , arg_list ) . ;
    ;               shift and go to state 222


state 218

    (54) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 223

state 219

    (55) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 77
    stmt                           shift and go to state 224
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68

state 220

    (110) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list . ) ;
    (106) arg_list -> arg_list . , expr
    )               shift and go to state 225
    ,               shift and go to state 189


state 221

    (109) scanf_stmt -> SCANF ( STRING , arg_list ) ; .
    }               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IF              reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    {               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ;               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CAST            reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    (               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    +               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    -               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    !               reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 109 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)


state 222

    (107) printf_stmt -> PRINTF ( STRING , arg_list ) ; .
    }               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IF              reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    {               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ;               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CAST            reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    (               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    +               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    -               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    !               reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 107 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)


state 223

    (54) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (67) expr -> expr . MINUSMINUS
    (68) expr -> expr . PLUSPLUS
    (84) expr -> expr . AND expr
    (85) expr -> expr . OR expr
    (86) expr -> expr . % expr
    (87) expr -> expr . / expr
    (88) expr -> expr . * expr
    (89) expr -> expr . - expr
    (90) expr -> expr . + expr
    (91) expr -> expr . > expr
    (92) expr -> expr . GE expr
    (93) expr -> expr . < expr
    (94) expr -> expr . LE expr
    (95) expr -> expr . NE expr
    (96) expr -> expr . EQ expr
    (97) expr -> expr . POINT IDENT = expr
    (98) expr -> expr . POINT IDENT
    )               shift and go to state 226
    MINUSMINUS      shift and go to state 115
    PLUSPLUS        shift and go to state 116
    AND             shift and go to state 117
    OR              shift and go to state 118
    %               shift and go to state 119
    /               shift and go to state 120
    *               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    >               shift and go to state 124
    GE              shift and go to state 125
    <               shift and go to state 126
    LE              shift and go to state 127
    NE              shift and go to state 128
    EQ              shift and go to state 129
    POINT           shift and go to state 130


state 224

    (55) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CAST            reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTTOFLOAT      reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 55 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 225

    (110) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) . ;
    ;               shift and go to state 227


state 226

    (54) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (41) stmt -> . sprintf_stmt
    (42) stmt -> . scanf_stmt
    (43) stmt -> . printf_stmt
    (44) stmt -> . for_stmt
    (45) stmt -> . break_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . while_stmt
    (48) stmt -> . if_stmt
    (49) stmt -> . compound_stmt
    (50) stmt -> . expr_stmt
    (110) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (109) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (107) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (108) printf_stmt -> . PRINTF ( STRING ) ;
    (54) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (59) break_stmt -> . CONTINUE ;
    (60) break_stmt -> . BREAK ;
    (57) return_stmt -> . RETURN expr ;
    (58) return_stmt -> . RETURN ;
    (53) while_stmt -> . WHILE ( expr ) stmt
    (55) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (56) if_stmt -> . IF ( expr ) stmt
    (32) compound_stmt -> . { local_decls stmt_list }
    (51) expr_stmt -> . ;
    (52) expr_stmt -> . expr ;
    (61) expr -> . IDENT DIVEQ expr
    (62) expr -> . IDENT MULEQ expr
    (63) expr -> . IDENT MINUSEQ expr
    (64) expr -> . IDENT PLUSEQ expr
    (65) expr -> . MINUSMINUS expr
    (66) expr -> . PLUSPLUS expr
    (67) expr -> . expr MINUSMINUS
    (68) expr -> . expr PLUSPLUS
    (69) expr -> . NEW type_spec [ expr ]
    (70) expr -> . STRING
    (71) expr -> . FLOAT_LIT
    (72) expr -> . INT_LIT
    (73) expr -> . BOOL_LIT
    (74) expr -> . CAST type_spec ( expr )
    (75) expr -> . INTTOFLOAT ( IDENT )
    (76) expr -> . IDENT . SIZE
    (77) expr -> . IDENT ( args )
    (78) expr -> . IDENT [ expr ]
    (79) expr -> . IDENT
    (80) expr -> . ( expr )
    (81) expr -> . + expr
    (82) expr -> . - expr
    (83) expr -> . ! expr
    (84) expr -> . expr AND expr
    (85) expr -> . expr OR expr
    (86) expr -> . expr % expr
    (87) expr -> . expr / expr
    (88) expr -> . expr * expr
    (89) expr -> . expr - expr
    (90) expr -> . expr + expr
    (91) expr -> . expr > expr
    (92) expr -> . expr GE expr
    (93) expr -> . expr < expr
    (94) expr -> . expr LE expr
    (95) expr -> . expr NE expr
    (96) expr -> . expr EQ expr
    (97) expr -> . expr POINT IDENT = expr
    (98) expr -> . expr POINT IDENT
    (99) expr -> . SUPER POINT IDENT
    (100) expr -> . THIS
    (101) expr -> . IDENT [ expr ] = expr
    (102) expr -> . IDENT = expr
    SPRINTF         shift and go to state 69
    SCANF           shift and go to state 74
    PRINTF          shift and go to state 75
    FOR             shift and go to state 76
    CONTINUE        shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 80
    WHILE           shift and go to state 81
    IF              shift and go to state 82
    {               shift and go to state 45
    ;               shift and go to state 73
    IDENT           shift and go to state 71
    MINUSMINUS      shift and go to state 83
    PLUSPLUS        shift and go to state 84
    NEW             shift and go to state 85
    STRING          shift and go to state 72
    FLOAT_LIT       shift and go to state 86
    INT_LIT         shift and go to state 87
    BOOL_LIT        shift and go to state 88
    CAST            shift and go to state 89
    INTTOFLOAT      shift and go to state 90
    (               shift and go to state 70
    +               shift and go to state 91
    -               shift and go to state 92
    !               shift and go to state 93
    SUPER           shift and go to state 94
    THIS            shift and go to state 95

    expr                           shift and go to state 77
    stmt                           shift and go to state 228
    sprintf_stmt                   shift and go to state 59
    scanf_stmt                     shift and go to state 60
    printf_stmt                    shift and go to state 61
    for_stmt                       shift and go to state 62
    break_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 64
    while_stmt                     shift and go to state 65
    if_stmt                        shift and go to state 66
    compound_stmt                  shift and go to state 67
    expr_stmt                      shift and go to state 68

state 227

    (110) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .
    }               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SCANF           reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PRINTF          reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FOR             reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BREAK           reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    RETURN          reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    WHILE           reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IF              reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    {               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ;               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IDENT           reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    NEW             reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    STRING          reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CAST            reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INTTOFLOAT      reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    (               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    +               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    -               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    !               reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SUPER           reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    THIS            reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ELSE            reduce using rule 110 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)


state 228

    (54) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    }               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SPRINTF         reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CONTINUE        reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING          reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CAST            reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INTTOFLOAT      reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SUPER           reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    THIS            reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 54 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
