Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     class_decl -> CLASS IDENT { class_body } ;
Rule 8     class_body -> class_member_list
Rule 9     class_member_list -> class_member
Rule 10    class_member_list -> class_member_list class_member
Rule 11    class_member -> var_decl
Rule 12    class_member -> method_decl
Rule 13    method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt
Rule 14    _1_params_optional -> params
Rule 15    _1_params_optional -> <empty>
Rule 16    var_decl -> type_spec IDENT [ ] ;
Rule 17    var_decl -> type_spec IDENT ;
Rule 18    type_spec -> FLOAT
Rule 19    type_spec -> INT
Rule 20    type_spec -> BOOL
Rule 21    type_spec -> VOID
Rule 22    func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt
Rule 23    _2_params_optional -> params
Rule 24    _2_params_optional -> <empty>
Rule 25    params -> VOID
Rule 26    params -> param_list
Rule 27    param_list -> param
Rule 28    param_list -> param_list , param
Rule 29    param -> type_spec IDENT [ ]
Rule 30    param -> type_spec IDENT
Rule 31    compound_stmt -> { local_decls stmt_list }
Rule 32    local_decls -> empty
Rule 33    local_decls -> local_decl_list
Rule 34    local_decl_list -> local_decl
Rule 35    local_decl_list -> local_decl_list local_decl
Rule 36    local_decl -> type_spec IDENT [ ] ;
Rule 37    local_decl -> type_spec IDENT ;
Rule 38    stmt_list -> stmt
Rule 39    stmt_list -> stmt_list stmt
Rule 40    stmt -> sprintf_stmt
Rule 41    stmt -> scanf_stmt
Rule 42    stmt -> printf_stmt
Rule 43    stmt -> for_stmt
Rule 44    stmt -> break_stmt
Rule 45    stmt -> return_stmt
Rule 46    stmt -> while_stmt
Rule 47    stmt -> if_stmt
Rule 48    stmt -> compound_stmt
Rule 49    stmt -> expr_stmt
Rule 50    expr_stmt -> ;
Rule 51    expr_stmt -> expr ;
Rule 52    while_stmt -> WHILE ( expr ) stmt
Rule 53    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 54    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=5]
Rule 55    if_stmt -> IF ( expr ) stmt  [precedence=left, level=4]
Rule 56    return_stmt -> RETURN expr ;
Rule 57    return_stmt -> RETURN ;
Rule 58    break_stmt -> CONTINUE ;
Rule 59    break_stmt -> BREAK ;
Rule 60    expr -> IDENT DIVEQ expr  [precedence=right, level=9]
Rule 61    expr -> IDENT MULEQ expr  [precedence=right, level=8]
Rule 62    expr -> IDENT MINUSEQ expr  [precedence=right, level=7]
Rule 63    expr -> IDENT PLUSEQ expr  [precedence=right, level=6]
Rule 64    expr -> MINUSMINUS expr  [precedence=left, level=2]
Rule 65    expr -> PLUSPLUS expr  [precedence=left, level=1]
Rule 66    expr -> expr MINUSMINUS  [precedence=left, level=2]
Rule 67    expr -> expr PLUSPLUS  [precedence=left, level=1]
Rule 68    expr -> NEW type_spec [ expr ]
Rule 69    expr -> STRING
Rule 70    expr -> FLOAT_LIT
Rule 71    expr -> INT_LIT
Rule 72    expr -> BOOL_LIT
Rule 73    expr -> IDENT . SIZE ;
Rule 74    expr -> IDENT ( args )
Rule 75    expr -> IDENT [ expr ]
Rule 76    expr -> IDENT
Rule 77    expr -> ( expr )
Rule 78    expr -> + expr  [precedence=right, level=17]
Rule 79    expr -> - expr  [precedence=right, level=17]
Rule 80    expr -> ! expr  [precedence=right, level=17]
Rule 81    expr -> expr AND expr  [precedence=left, level=12]
Rule 82    expr -> expr OR expr  [precedence=left, level=11]
Rule 83    expr -> expr % expr  [precedence=left, level=16]
Rule 84    expr -> expr / expr  [precedence=left, level=16]
Rule 85    expr -> expr * expr  [precedence=left, level=16]
Rule 86    expr -> expr - expr  [precedence=left, level=15]
Rule 87    expr -> expr + expr  [precedence=left, level=15]
Rule 88    expr -> expr > expr  [precedence=left, level=14]
Rule 89    expr -> expr GE expr  [precedence=left, level=14]
Rule 90    expr -> expr < expr  [precedence=left, level=14]
Rule 91    expr -> expr LE expr  [precedence=left, level=14]
Rule 92    expr -> expr NE expr  [precedence=left, level=13]
Rule 93    expr -> expr EQ expr  [precedence=left, level=13]
Rule 94    expr -> expr POINT IDENT = expr ;
Rule 95    expr -> expr POINT IDENT ;
Rule 96    expr -> SUPER POINT IDENT ;
Rule 97    expr -> THIS
Rule 98    expr -> IDENT [ expr ] = expr  [precedence=right, level=10]
Rule 99    expr -> IDENT = expr  [precedence=right, level=10]
Rule 100   args -> empty
Rule 101   args -> arg_list
Rule 102   arg_list -> expr
Rule 103   arg_list -> arg_list , expr
Rule 104   printf_stmt -> PRINTF ( STRING , arg_list ) ;
Rule 105   printf_stmt -> PRINTF ( STRING ) ;
Rule 106   scanf_stmt -> SCANF ( STRING , arg_list ) ;
Rule 107   sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ;
Rule 108   empty -> <empty>

Terminals, with rules where they appear:

!                    : 80
%                    : 83
(                    : 13 22 52 53 54 55 74 77 104 105 106 107
)                    : 13 22 52 53 54 55 74 77 104 105 106 107
*                    : 85
+                    : 78 87
,                    : 28 103 104 106 107 107
-                    : 79 86
.                    : 73
/                    : 84
;                    : 7 16 17 36 37 50 51 53 53 56 57 58 59 73 94 95 96 104 105 106 107
<                    : 90
=                    : 94 98 99
>                    : 88
AND                  : 81
BOOL                 : 20
BOOL_LIT             : 72
BREAK                : 59
CLASS                : 7
CONTINUE             : 58
DIVEQ                : 60
ELSE                 : 54
EQ                   : 93
FLOAT                : 18
FLOAT_LIT            : 70
FOR                  : 53
GE                   : 89
IDENT                : 7 13 16 17 22 29 30 36 37 60 61 62 63 73 74 75 76 94 95 96 98 99 107
IF                   : 54 55
INT                  : 19
INT_LIT              : 71
LE                   : 91
MINUSEQ              : 62
MINUSMINUS           : 64 66
MULEQ                : 61
NE                   : 92
NEW                  : 68
OR                   : 82
PLUSEQ               : 63
PLUSPLUS             : 65 67
POINT                : 94 95 96
PRINTF               : 104 105
RETURN               : 56 57
SCANF                : 106
SIZE                 : 73
SPRINTF              : 107
STRING               : 69 104 105 106 107
SUPER                : 96
THIS                 : 97
VOID                 : 21 25
WHILE                : 52
[                    : 16 29 36 68 75 98
]                    : 16 29 36 68 75 98
error                : 
{                    : 7 31
}                    : 7 31

Nonterminals, with rules where they appear:

_1_params_optional   : 13
_2_params_optional   : 22
arg_list             : 101 103 104 106 107
args                 : 74
break_stmt           : 44
class_body           : 7
class_decl           : 4
class_member         : 9 10
class_member_list    : 8 10
compound_stmt        : 13 22 48
decl                 : 2 3
decl_list            : 1 3
empty                : 32 100
expr                 : 51 52 53 53 53 54 55 56 60 61 62 63 64 65 66 67 68 75 77 78 79 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 98 98 99 102 103
expr_stmt            : 49
for_stmt             : 43
func_decl            : 5
if_stmt              : 47
local_decl           : 34 35
local_decl_list      : 33 35
local_decls          : 31
method_decl          : 12
param                : 27 28
param_list           : 26 28
params               : 14 23
printf_stmt          : 42
program              : 0
return_stmt          : 45
scanf_stmt           : 41
sprintf_stmt         : 40
stmt                 : 38 39 52 53 54 54 55
stmt_list            : 31 39
type_spec            : 13 16 17 22 29 30 36 37 68
var_decl             : 6 11
while_stmt           : 46


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (22) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (16) var_decl -> . type_spec IDENT [ ] ;
    (17) var_decl -> . type_spec IDENT ;
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (22) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (16) var_decl -> . type_spec IDENT [ ] ;
    (17) var_decl -> . type_spec IDENT ;
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) class_decl -> CLASS . IDENT { class_body } ;
    IDENT           shift and go to state 14


state 8

    (22) func_decl -> type_spec . IDENT ( _2_params_optional ) compound_stmt
    (16) var_decl -> type_spec . IDENT [ ] ;
    (17) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 15


state 9

    (18) type_spec -> FLOAT .
    IDENT           reduce using rule 18 (type_spec -> FLOAT .)
    [               reduce using rule 18 (type_spec -> FLOAT .)


state 10

    (19) type_spec -> INT .
    IDENT           reduce using rule 19 (type_spec -> INT .)
    [               reduce using rule 19 (type_spec -> INT .)


state 11

    (20) type_spec -> BOOL .
    IDENT           reduce using rule 20 (type_spec -> BOOL .)
    [               reduce using rule 20 (type_spec -> BOOL .)


state 12

    (21) type_spec -> VOID .
    IDENT           reduce using rule 21 (type_spec -> VOID .)
    [               reduce using rule 21 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (7) class_decl -> CLASS IDENT . { class_body } ;
    {               shift and go to state 16


state 15

    (22) func_decl -> type_spec IDENT . ( _2_params_optional ) compound_stmt
    (16) var_decl -> type_spec IDENT . [ ] ;
    (17) var_decl -> type_spec IDENT . ;
    (               shift and go to state 17
    [               shift and go to state 18
    ;               shift and go to state 19


state 16

    (7) class_decl -> CLASS IDENT { . class_body } ;
    (8) class_body -> . class_member_list
    (9) class_member_list -> . class_member
    (10) class_member_list -> . class_member_list class_member
    (11) class_member -> . var_decl
    (12) class_member -> . method_decl
    (16) var_decl -> . type_spec IDENT [ ] ;
    (17) var_decl -> . type_spec IDENT ;
    (13) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_body                     shift and go to state 20
    class_member_list              shift and go to state 21
    class_member                   shift and go to state 22
    var_decl                       shift and go to state 23
    method_decl                    shift and go to state 24
    type_spec                      shift and go to state 25

state 17

    (22) func_decl -> type_spec IDENT ( . _2_params_optional ) compound_stmt
    (23) _2_params_optional -> . params
    (24) _2_params_optional -> .
    (25) params -> . VOID
    (26) params -> . param_list
    (27) param_list -> . param
    (28) param_list -> . param_list , param
    (29) param -> . type_spec IDENT [ ]
    (30) param -> . type_spec IDENT
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    )               reduce using rule 24 (_2_params_optional -> .)
    VOID            shift and go to state 29
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 26
    _2_params_optional             shift and go to state 27
    params                         shift and go to state 28
    param_list                     shift and go to state 30
    param                          shift and go to state 31

state 18

    (16) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 32


state 19

    (17) var_decl -> type_spec IDENT ; .
    CLASS           reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 17 (var_decl -> type_spec IDENT ; .)
    }               reduce using rule 17 (var_decl -> type_spec IDENT ; .)


state 20

    (7) class_decl -> CLASS IDENT { class_body . } ;
    }               shift and go to state 33


state 21

    (8) class_body -> class_member_list .
    (10) class_member_list -> class_member_list . class_member
    (11) class_member -> . var_decl
    (12) class_member -> . method_decl
    (16) var_decl -> . type_spec IDENT [ ] ;
    (17) var_decl -> . type_spec IDENT ;
    (13) method_decl -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    }               reduce using rule 8 (class_body -> class_member_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_member                   shift and go to state 34
    var_decl                       shift and go to state 23
    method_decl                    shift and go to state 24
    type_spec                      shift and go to state 25

state 22

    (9) class_member_list -> class_member .
    FLOAT           reduce using rule 9 (class_member_list -> class_member .)
    INT             reduce using rule 9 (class_member_list -> class_member .)
    BOOL            reduce using rule 9 (class_member_list -> class_member .)
    VOID            reduce using rule 9 (class_member_list -> class_member .)
    }               reduce using rule 9 (class_member_list -> class_member .)


state 23

    (11) class_member -> var_decl .
    FLOAT           reduce using rule 11 (class_member -> var_decl .)
    INT             reduce using rule 11 (class_member -> var_decl .)
    BOOL            reduce using rule 11 (class_member -> var_decl .)
    VOID            reduce using rule 11 (class_member -> var_decl .)
    }               reduce using rule 11 (class_member -> var_decl .)


state 24

    (12) class_member -> method_decl .
    FLOAT           reduce using rule 12 (class_member -> method_decl .)
    INT             reduce using rule 12 (class_member -> method_decl .)
    BOOL            reduce using rule 12 (class_member -> method_decl .)
    VOID            reduce using rule 12 (class_member -> method_decl .)
    }               reduce using rule 12 (class_member -> method_decl .)


state 25

    (16) var_decl -> type_spec . IDENT [ ] ;
    (17) var_decl -> type_spec . IDENT ;
    (13) method_decl -> type_spec . IDENT ( _1_params_optional ) compound_stmt
    IDENT           shift and go to state 35


state 26

    (29) param -> type_spec . IDENT [ ]
    (30) param -> type_spec . IDENT
    IDENT           shift and go to state 36


state 27

    (22) func_decl -> type_spec IDENT ( _2_params_optional . ) compound_stmt
    )               shift and go to state 37


state 28

    (23) _2_params_optional -> params .
    )               reduce using rule 23 (_2_params_optional -> params .)


state 29

    (25) params -> VOID .
    (21) type_spec -> VOID .
    )               reduce using rule 25 (params -> VOID .)
    IDENT           reduce using rule 21 (type_spec -> VOID .)


state 30

    (26) params -> param_list .
    (28) param_list -> param_list . , param
    )               reduce using rule 26 (params -> param_list .)
    ,               shift and go to state 38


state 31

    (27) param_list -> param .
    ,               reduce using rule 27 (param_list -> param .)
    )               reduce using rule 27 (param_list -> param .)


state 32

    (16) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 39


state 33

    (7) class_decl -> CLASS IDENT { class_body } . ;
    ;               shift and go to state 40


state 34

    (10) class_member_list -> class_member_list class_member .
    FLOAT           reduce using rule 10 (class_member_list -> class_member_list class_member .)
    INT             reduce using rule 10 (class_member_list -> class_member_list class_member .)
    BOOL            reduce using rule 10 (class_member_list -> class_member_list class_member .)
    VOID            reduce using rule 10 (class_member_list -> class_member_list class_member .)
    }               reduce using rule 10 (class_member_list -> class_member_list class_member .)


state 35

    (16) var_decl -> type_spec IDENT . [ ] ;
    (17) var_decl -> type_spec IDENT . ;
    (13) method_decl -> type_spec IDENT . ( _1_params_optional ) compound_stmt
    [               shift and go to state 18
    ;               shift and go to state 19
    (               shift and go to state 41


state 36

    (29) param -> type_spec IDENT . [ ]
    (30) param -> type_spec IDENT .
    [               shift and go to state 42
    ,               reduce using rule 30 (param -> type_spec IDENT .)
    )               reduce using rule 30 (param -> type_spec IDENT .)


state 37

    (22) func_decl -> type_spec IDENT ( _2_params_optional ) . compound_stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 44

    compound_stmt                  shift and go to state 43

state 38

    (28) param_list -> param_list , . param
    (29) param -> . type_spec IDENT [ ]
    (30) param -> . type_spec IDENT
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 45
    type_spec                      shift and go to state 26

state 39

    (16) var_decl -> type_spec IDENT [ ] ; .
    CLASS           reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)
    }               reduce using rule 16 (var_decl -> type_spec IDENT [ ] ; .)


state 40

    (7) class_decl -> CLASS IDENT { class_body } ; .
    CLASS           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    FLOAT           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    INT             reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    BOOL            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    VOID            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    $end            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)


state 41

    (13) method_decl -> type_spec IDENT ( . _1_params_optional ) compound_stmt
    (14) _1_params_optional -> . params
    (15) _1_params_optional -> .
    (25) params -> . VOID
    (26) params -> . param_list
    (27) param_list -> . param
    (28) param_list -> . param_list , param
    (29) param -> . type_spec IDENT [ ]
    (30) param -> . type_spec IDENT
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    )               reduce using rule 15 (_1_params_optional -> .)
    VOID            shift and go to state 29
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 26
    _1_params_optional             shift and go to state 46
    params                         shift and go to state 47
    param_list                     shift and go to state 30
    param                          shift and go to state 31

state 42

    (29) param -> type_spec IDENT [ . ]
    ]               shift and go to state 48


state 43

    (22) func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .
    CLASS           reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    FLOAT           reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    INT             reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    BOOL            reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    VOID            reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    $end            reduce using rule 22 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)


state 44

    (31) compound_stmt -> { . local_decls stmt_list }
    (32) local_decls -> . empty
    (33) local_decls -> . local_decl_list
    (108) empty -> .
    (34) local_decl_list -> . local_decl
    (35) local_decl_list -> . local_decl_list local_decl
    (36) local_decl -> . type_spec IDENT [ ] ;
    (37) local_decl -> . type_spec IDENT ;
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    SPRINTF         reduce using rule 108 (empty -> .)
    SCANF           reduce using rule 108 (empty -> .)
    PRINTF          reduce using rule 108 (empty -> .)
    FOR             reduce using rule 108 (empty -> .)
    CONTINUE        reduce using rule 108 (empty -> .)
    BREAK           reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    {               reduce using rule 108 (empty -> .)
    ;               reduce using rule 108 (empty -> .)
    IDENT           reduce using rule 108 (empty -> .)
    MINUSMINUS      reduce using rule 108 (empty -> .)
    PLUSPLUS        reduce using rule 108 (empty -> .)
    NEW             reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    FLOAT_LIT       reduce using rule 108 (empty -> .)
    INT_LIT         reduce using rule 108 (empty -> .)
    BOOL_LIT        reduce using rule 108 (empty -> .)
    (               reduce using rule 108 (empty -> .)
    +               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    !               reduce using rule 108 (empty -> .)
    SUPER           reduce using rule 108 (empty -> .)
    THIS            reduce using rule 108 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 49
    empty                          shift and go to state 50
    local_decl_list                shift and go to state 51
    local_decl                     shift and go to state 52
    type_spec                      shift and go to state 53

state 45

    (28) param_list -> param_list , param .
    ,               reduce using rule 28 (param_list -> param_list , param .)
    )               reduce using rule 28 (param_list -> param_list , param .)


state 46

    (13) method_decl -> type_spec IDENT ( _1_params_optional . ) compound_stmt
    )               shift and go to state 54


state 47

    (14) _1_params_optional -> params .
    )               reduce using rule 14 (_1_params_optional -> params .)


state 48

    (29) param -> type_spec IDENT [ ] .
    ,               reduce using rule 29 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 29 (param -> type_spec IDENT [ ] .)


state 49

    (31) compound_stmt -> { local_decls . stmt_list }
    (38) stmt_list -> . stmt
    (39) stmt_list -> . stmt_list stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    stmt_list                      shift and go to state 55
    stmt                           shift and go to state 56
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66
    expr                           shift and go to state 75

state 50

    (32) local_decls -> empty .
    SPRINTF         reduce using rule 32 (local_decls -> empty .)
    SCANF           reduce using rule 32 (local_decls -> empty .)
    PRINTF          reduce using rule 32 (local_decls -> empty .)
    FOR             reduce using rule 32 (local_decls -> empty .)
    CONTINUE        reduce using rule 32 (local_decls -> empty .)
    BREAK           reduce using rule 32 (local_decls -> empty .)
    RETURN          reduce using rule 32 (local_decls -> empty .)
    WHILE           reduce using rule 32 (local_decls -> empty .)
    IF              reduce using rule 32 (local_decls -> empty .)
    {               reduce using rule 32 (local_decls -> empty .)
    ;               reduce using rule 32 (local_decls -> empty .)
    IDENT           reduce using rule 32 (local_decls -> empty .)
    MINUSMINUS      reduce using rule 32 (local_decls -> empty .)
    PLUSPLUS        reduce using rule 32 (local_decls -> empty .)
    NEW             reduce using rule 32 (local_decls -> empty .)
    STRING          reduce using rule 32 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 32 (local_decls -> empty .)
    INT_LIT         reduce using rule 32 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 32 (local_decls -> empty .)
    (               reduce using rule 32 (local_decls -> empty .)
    +               reduce using rule 32 (local_decls -> empty .)
    -               reduce using rule 32 (local_decls -> empty .)
    !               reduce using rule 32 (local_decls -> empty .)
    SUPER           reduce using rule 32 (local_decls -> empty .)
    THIS            reduce using rule 32 (local_decls -> empty .)


state 51

    (33) local_decls -> local_decl_list .
    (35) local_decl_list -> local_decl_list . local_decl
    (36) local_decl -> . type_spec IDENT [ ] ;
    (37) local_decl -> . type_spec IDENT ;
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    SPRINTF         reduce using rule 33 (local_decls -> local_decl_list .)
    SCANF           reduce using rule 33 (local_decls -> local_decl_list .)
    PRINTF          reduce using rule 33 (local_decls -> local_decl_list .)
    FOR             reduce using rule 33 (local_decls -> local_decl_list .)
    CONTINUE        reduce using rule 33 (local_decls -> local_decl_list .)
    BREAK           reduce using rule 33 (local_decls -> local_decl_list .)
    RETURN          reduce using rule 33 (local_decls -> local_decl_list .)
    WHILE           reduce using rule 33 (local_decls -> local_decl_list .)
    IF              reduce using rule 33 (local_decls -> local_decl_list .)
    {               reduce using rule 33 (local_decls -> local_decl_list .)
    ;               reduce using rule 33 (local_decls -> local_decl_list .)
    IDENT           reduce using rule 33 (local_decls -> local_decl_list .)
    MINUSMINUS      reduce using rule 33 (local_decls -> local_decl_list .)
    PLUSPLUS        reduce using rule 33 (local_decls -> local_decl_list .)
    NEW             reduce using rule 33 (local_decls -> local_decl_list .)
    STRING          reduce using rule 33 (local_decls -> local_decl_list .)
    FLOAT_LIT       reduce using rule 33 (local_decls -> local_decl_list .)
    INT_LIT         reduce using rule 33 (local_decls -> local_decl_list .)
    BOOL_LIT        reduce using rule 33 (local_decls -> local_decl_list .)
    (               reduce using rule 33 (local_decls -> local_decl_list .)
    +               reduce using rule 33 (local_decls -> local_decl_list .)
    -               reduce using rule 33 (local_decls -> local_decl_list .)
    !               reduce using rule 33 (local_decls -> local_decl_list .)
    SUPER           reduce using rule 33 (local_decls -> local_decl_list .)
    THIS            reduce using rule 33 (local_decls -> local_decl_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 92
    type_spec                      shift and go to state 53

state 52

    (34) local_decl_list -> local_decl .
    FLOAT           reduce using rule 34 (local_decl_list -> local_decl .)
    INT             reduce using rule 34 (local_decl_list -> local_decl .)
    BOOL            reduce using rule 34 (local_decl_list -> local_decl .)
    VOID            reduce using rule 34 (local_decl_list -> local_decl .)
    SPRINTF         reduce using rule 34 (local_decl_list -> local_decl .)
    SCANF           reduce using rule 34 (local_decl_list -> local_decl .)
    PRINTF          reduce using rule 34 (local_decl_list -> local_decl .)
    FOR             reduce using rule 34 (local_decl_list -> local_decl .)
    CONTINUE        reduce using rule 34 (local_decl_list -> local_decl .)
    BREAK           reduce using rule 34 (local_decl_list -> local_decl .)
    RETURN          reduce using rule 34 (local_decl_list -> local_decl .)
    WHILE           reduce using rule 34 (local_decl_list -> local_decl .)
    IF              reduce using rule 34 (local_decl_list -> local_decl .)
    {               reduce using rule 34 (local_decl_list -> local_decl .)
    ;               reduce using rule 34 (local_decl_list -> local_decl .)
    IDENT           reduce using rule 34 (local_decl_list -> local_decl .)
    MINUSMINUS      reduce using rule 34 (local_decl_list -> local_decl .)
    PLUSPLUS        reduce using rule 34 (local_decl_list -> local_decl .)
    NEW             reduce using rule 34 (local_decl_list -> local_decl .)
    STRING          reduce using rule 34 (local_decl_list -> local_decl .)
    FLOAT_LIT       reduce using rule 34 (local_decl_list -> local_decl .)
    INT_LIT         reduce using rule 34 (local_decl_list -> local_decl .)
    BOOL_LIT        reduce using rule 34 (local_decl_list -> local_decl .)
    (               reduce using rule 34 (local_decl_list -> local_decl .)
    +               reduce using rule 34 (local_decl_list -> local_decl .)
    -               reduce using rule 34 (local_decl_list -> local_decl .)
    !               reduce using rule 34 (local_decl_list -> local_decl .)
    SUPER           reduce using rule 34 (local_decl_list -> local_decl .)
    THIS            reduce using rule 34 (local_decl_list -> local_decl .)


state 53

    (36) local_decl -> type_spec . IDENT [ ] ;
    (37) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 93


state 54

    (13) method_decl -> type_spec IDENT ( _1_params_optional ) . compound_stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 44

    compound_stmt                  shift and go to state 94

state 55

    (31) compound_stmt -> { local_decls stmt_list . }
    (39) stmt_list -> stmt_list . stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    }               shift and go to state 95
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    stmt                           shift and go to state 96
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66
    expr                           shift and go to state 75

state 56

    (38) stmt_list -> stmt .
    }               reduce using rule 38 (stmt_list -> stmt .)
    SPRINTF         reduce using rule 38 (stmt_list -> stmt .)
    SCANF           reduce using rule 38 (stmt_list -> stmt .)
    PRINTF          reduce using rule 38 (stmt_list -> stmt .)
    FOR             reduce using rule 38 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 38 (stmt_list -> stmt .)
    BREAK           reduce using rule 38 (stmt_list -> stmt .)
    RETURN          reduce using rule 38 (stmt_list -> stmt .)
    WHILE           reduce using rule 38 (stmt_list -> stmt .)
    IF              reduce using rule 38 (stmt_list -> stmt .)
    {               reduce using rule 38 (stmt_list -> stmt .)
    ;               reduce using rule 38 (stmt_list -> stmt .)
    IDENT           reduce using rule 38 (stmt_list -> stmt .)
    MINUSMINUS      reduce using rule 38 (stmt_list -> stmt .)
    PLUSPLUS        reduce using rule 38 (stmt_list -> stmt .)
    NEW             reduce using rule 38 (stmt_list -> stmt .)
    STRING          reduce using rule 38 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 38 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 38 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 38 (stmt_list -> stmt .)
    (               reduce using rule 38 (stmt_list -> stmt .)
    +               reduce using rule 38 (stmt_list -> stmt .)
    -               reduce using rule 38 (stmt_list -> stmt .)
    !               reduce using rule 38 (stmt_list -> stmt .)
    SUPER           reduce using rule 38 (stmt_list -> stmt .)
    THIS            reduce using rule 38 (stmt_list -> stmt .)


state 57

    (40) stmt -> sprintf_stmt .
    }               reduce using rule 40 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 40 (stmt -> sprintf_stmt .)
    SCANF           reduce using rule 40 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 40 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 40 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 40 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 40 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 40 (stmt -> sprintf_stmt .)
    IF              reduce using rule 40 (stmt -> sprintf_stmt .)
    {               reduce using rule 40 (stmt -> sprintf_stmt .)
    ;               reduce using rule 40 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 40 (stmt -> sprintf_stmt .)
    MINUSMINUS      reduce using rule 40 (stmt -> sprintf_stmt .)
    PLUSPLUS        reduce using rule 40 (stmt -> sprintf_stmt .)
    NEW             reduce using rule 40 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 40 (stmt -> sprintf_stmt .)
    FLOAT_LIT       reduce using rule 40 (stmt -> sprintf_stmt .)
    INT_LIT         reduce using rule 40 (stmt -> sprintf_stmt .)
    BOOL_LIT        reduce using rule 40 (stmt -> sprintf_stmt .)
    (               reduce using rule 40 (stmt -> sprintf_stmt .)
    +               reduce using rule 40 (stmt -> sprintf_stmt .)
    -               reduce using rule 40 (stmt -> sprintf_stmt .)
    !               reduce using rule 40 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 40 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 40 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 40 (stmt -> sprintf_stmt .)


state 58

    (41) stmt -> scanf_stmt .
    }               reduce using rule 41 (stmt -> scanf_stmt .)
    SPRINTF         reduce using rule 41 (stmt -> scanf_stmt .)
    SCANF           reduce using rule 41 (stmt -> scanf_stmt .)
    PRINTF          reduce using rule 41 (stmt -> scanf_stmt .)
    FOR             reduce using rule 41 (stmt -> scanf_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> scanf_stmt .)
    BREAK           reduce using rule 41 (stmt -> scanf_stmt .)
    RETURN          reduce using rule 41 (stmt -> scanf_stmt .)
    WHILE           reduce using rule 41 (stmt -> scanf_stmt .)
    IF              reduce using rule 41 (stmt -> scanf_stmt .)
    {               reduce using rule 41 (stmt -> scanf_stmt .)
    ;               reduce using rule 41 (stmt -> scanf_stmt .)
    IDENT           reduce using rule 41 (stmt -> scanf_stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> scanf_stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> scanf_stmt .)
    NEW             reduce using rule 41 (stmt -> scanf_stmt .)
    STRING          reduce using rule 41 (stmt -> scanf_stmt .)
    FLOAT_LIT       reduce using rule 41 (stmt -> scanf_stmt .)
    INT_LIT         reduce using rule 41 (stmt -> scanf_stmt .)
    BOOL_LIT        reduce using rule 41 (stmt -> scanf_stmt .)
    (               reduce using rule 41 (stmt -> scanf_stmt .)
    +               reduce using rule 41 (stmt -> scanf_stmt .)
    -               reduce using rule 41 (stmt -> scanf_stmt .)
    !               reduce using rule 41 (stmt -> scanf_stmt .)
    SUPER           reduce using rule 41 (stmt -> scanf_stmt .)
    THIS            reduce using rule 41 (stmt -> scanf_stmt .)
    ELSE            reduce using rule 41 (stmt -> scanf_stmt .)


state 59

    (42) stmt -> printf_stmt .
    }               reduce using rule 42 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 42 (stmt -> printf_stmt .)
    SCANF           reduce using rule 42 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 42 (stmt -> printf_stmt .)
    FOR             reduce using rule 42 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> printf_stmt .)
    BREAK           reduce using rule 42 (stmt -> printf_stmt .)
    RETURN          reduce using rule 42 (stmt -> printf_stmt .)
    WHILE           reduce using rule 42 (stmt -> printf_stmt .)
    IF              reduce using rule 42 (stmt -> printf_stmt .)
    {               reduce using rule 42 (stmt -> printf_stmt .)
    ;               reduce using rule 42 (stmt -> printf_stmt .)
    IDENT           reduce using rule 42 (stmt -> printf_stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> printf_stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> printf_stmt .)
    NEW             reduce using rule 42 (stmt -> printf_stmt .)
    STRING          reduce using rule 42 (stmt -> printf_stmt .)
    FLOAT_LIT       reduce using rule 42 (stmt -> printf_stmt .)
    INT_LIT         reduce using rule 42 (stmt -> printf_stmt .)
    BOOL_LIT        reduce using rule 42 (stmt -> printf_stmt .)
    (               reduce using rule 42 (stmt -> printf_stmt .)
    +               reduce using rule 42 (stmt -> printf_stmt .)
    -               reduce using rule 42 (stmt -> printf_stmt .)
    !               reduce using rule 42 (stmt -> printf_stmt .)
    SUPER           reduce using rule 42 (stmt -> printf_stmt .)
    THIS            reduce using rule 42 (stmt -> printf_stmt .)
    ELSE            reduce using rule 42 (stmt -> printf_stmt .)


state 60

    (43) stmt -> for_stmt .
    }               reduce using rule 43 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 43 (stmt -> for_stmt .)
    SCANF           reduce using rule 43 (stmt -> for_stmt .)
    PRINTF          reduce using rule 43 (stmt -> for_stmt .)
    FOR             reduce using rule 43 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> for_stmt .)
    BREAK           reduce using rule 43 (stmt -> for_stmt .)
    RETURN          reduce using rule 43 (stmt -> for_stmt .)
    WHILE           reduce using rule 43 (stmt -> for_stmt .)
    IF              reduce using rule 43 (stmt -> for_stmt .)
    {               reduce using rule 43 (stmt -> for_stmt .)
    ;               reduce using rule 43 (stmt -> for_stmt .)
    IDENT           reduce using rule 43 (stmt -> for_stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> for_stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> for_stmt .)
    NEW             reduce using rule 43 (stmt -> for_stmt .)
    STRING          reduce using rule 43 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 43 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 43 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 43 (stmt -> for_stmt .)
    (               reduce using rule 43 (stmt -> for_stmt .)
    +               reduce using rule 43 (stmt -> for_stmt .)
    -               reduce using rule 43 (stmt -> for_stmt .)
    !               reduce using rule 43 (stmt -> for_stmt .)
    SUPER           reduce using rule 43 (stmt -> for_stmt .)
    THIS            reduce using rule 43 (stmt -> for_stmt .)
    ELSE            reduce using rule 43 (stmt -> for_stmt .)


state 61

    (44) stmt -> break_stmt .
    }               reduce using rule 44 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 44 (stmt -> break_stmt .)
    SCANF           reduce using rule 44 (stmt -> break_stmt .)
    PRINTF          reduce using rule 44 (stmt -> break_stmt .)
    FOR             reduce using rule 44 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 44 (stmt -> break_stmt .)
    BREAK           reduce using rule 44 (stmt -> break_stmt .)
    RETURN          reduce using rule 44 (stmt -> break_stmt .)
    WHILE           reduce using rule 44 (stmt -> break_stmt .)
    IF              reduce using rule 44 (stmt -> break_stmt .)
    {               reduce using rule 44 (stmt -> break_stmt .)
    ;               reduce using rule 44 (stmt -> break_stmt .)
    IDENT           reduce using rule 44 (stmt -> break_stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> break_stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> break_stmt .)
    NEW             reduce using rule 44 (stmt -> break_stmt .)
    STRING          reduce using rule 44 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 44 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 44 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 44 (stmt -> break_stmt .)
    (               reduce using rule 44 (stmt -> break_stmt .)
    +               reduce using rule 44 (stmt -> break_stmt .)
    -               reduce using rule 44 (stmt -> break_stmt .)
    !               reduce using rule 44 (stmt -> break_stmt .)
    SUPER           reduce using rule 44 (stmt -> break_stmt .)
    THIS            reduce using rule 44 (stmt -> break_stmt .)
    ELSE            reduce using rule 44 (stmt -> break_stmt .)


state 62

    (45) stmt -> return_stmt .
    }               reduce using rule 45 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 45 (stmt -> return_stmt .)
    SCANF           reduce using rule 45 (stmt -> return_stmt .)
    PRINTF          reduce using rule 45 (stmt -> return_stmt .)
    FOR             reduce using rule 45 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> return_stmt .)
    BREAK           reduce using rule 45 (stmt -> return_stmt .)
    RETURN          reduce using rule 45 (stmt -> return_stmt .)
    WHILE           reduce using rule 45 (stmt -> return_stmt .)
    IF              reduce using rule 45 (stmt -> return_stmt .)
    {               reduce using rule 45 (stmt -> return_stmt .)
    ;               reduce using rule 45 (stmt -> return_stmt .)
    IDENT           reduce using rule 45 (stmt -> return_stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> return_stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> return_stmt .)
    NEW             reduce using rule 45 (stmt -> return_stmt .)
    STRING          reduce using rule 45 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 45 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 45 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 45 (stmt -> return_stmt .)
    (               reduce using rule 45 (stmt -> return_stmt .)
    +               reduce using rule 45 (stmt -> return_stmt .)
    -               reduce using rule 45 (stmt -> return_stmt .)
    !               reduce using rule 45 (stmt -> return_stmt .)
    SUPER           reduce using rule 45 (stmt -> return_stmt .)
    THIS            reduce using rule 45 (stmt -> return_stmt .)
    ELSE            reduce using rule 45 (stmt -> return_stmt .)


state 63

    (46) stmt -> while_stmt .
    }               reduce using rule 46 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 46 (stmt -> while_stmt .)
    SCANF           reduce using rule 46 (stmt -> while_stmt .)
    PRINTF          reduce using rule 46 (stmt -> while_stmt .)
    FOR             reduce using rule 46 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 46 (stmt -> while_stmt .)
    BREAK           reduce using rule 46 (stmt -> while_stmt .)
    RETURN          reduce using rule 46 (stmt -> while_stmt .)
    WHILE           reduce using rule 46 (stmt -> while_stmt .)
    IF              reduce using rule 46 (stmt -> while_stmt .)
    {               reduce using rule 46 (stmt -> while_stmt .)
    ;               reduce using rule 46 (stmt -> while_stmt .)
    IDENT           reduce using rule 46 (stmt -> while_stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> while_stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> while_stmt .)
    NEW             reduce using rule 46 (stmt -> while_stmt .)
    STRING          reduce using rule 46 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 46 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 46 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 46 (stmt -> while_stmt .)
    (               reduce using rule 46 (stmt -> while_stmt .)
    +               reduce using rule 46 (stmt -> while_stmt .)
    -               reduce using rule 46 (stmt -> while_stmt .)
    !               reduce using rule 46 (stmt -> while_stmt .)
    SUPER           reduce using rule 46 (stmt -> while_stmt .)
    THIS            reduce using rule 46 (stmt -> while_stmt .)
    ELSE            reduce using rule 46 (stmt -> while_stmt .)


state 64

    (47) stmt -> if_stmt .
    }               reduce using rule 47 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 47 (stmt -> if_stmt .)
    SCANF           reduce using rule 47 (stmt -> if_stmt .)
    PRINTF          reduce using rule 47 (stmt -> if_stmt .)
    FOR             reduce using rule 47 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 47 (stmt -> if_stmt .)
    BREAK           reduce using rule 47 (stmt -> if_stmt .)
    RETURN          reduce using rule 47 (stmt -> if_stmt .)
    WHILE           reduce using rule 47 (stmt -> if_stmt .)
    IF              reduce using rule 47 (stmt -> if_stmt .)
    {               reduce using rule 47 (stmt -> if_stmt .)
    ;               reduce using rule 47 (stmt -> if_stmt .)
    IDENT           reduce using rule 47 (stmt -> if_stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> if_stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> if_stmt .)
    NEW             reduce using rule 47 (stmt -> if_stmt .)
    STRING          reduce using rule 47 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 47 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 47 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 47 (stmt -> if_stmt .)
    (               reduce using rule 47 (stmt -> if_stmt .)
    +               reduce using rule 47 (stmt -> if_stmt .)
    -               reduce using rule 47 (stmt -> if_stmt .)
    !               reduce using rule 47 (stmt -> if_stmt .)
    SUPER           reduce using rule 47 (stmt -> if_stmt .)
    THIS            reduce using rule 47 (stmt -> if_stmt .)
    ELSE            reduce using rule 47 (stmt -> if_stmt .)


state 65

    (48) stmt -> compound_stmt .
    }               reduce using rule 48 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 48 (stmt -> compound_stmt .)
    SCANF           reduce using rule 48 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 48 (stmt -> compound_stmt .)
    FOR             reduce using rule 48 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 48 (stmt -> compound_stmt .)
    BREAK           reduce using rule 48 (stmt -> compound_stmt .)
    RETURN          reduce using rule 48 (stmt -> compound_stmt .)
    WHILE           reduce using rule 48 (stmt -> compound_stmt .)
    IF              reduce using rule 48 (stmt -> compound_stmt .)
    {               reduce using rule 48 (stmt -> compound_stmt .)
    ;               reduce using rule 48 (stmt -> compound_stmt .)
    IDENT           reduce using rule 48 (stmt -> compound_stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> compound_stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> compound_stmt .)
    NEW             reduce using rule 48 (stmt -> compound_stmt .)
    STRING          reduce using rule 48 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 48 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 48 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 48 (stmt -> compound_stmt .)
    (               reduce using rule 48 (stmt -> compound_stmt .)
    +               reduce using rule 48 (stmt -> compound_stmt .)
    -               reduce using rule 48 (stmt -> compound_stmt .)
    !               reduce using rule 48 (stmt -> compound_stmt .)
    SUPER           reduce using rule 48 (stmt -> compound_stmt .)
    THIS            reduce using rule 48 (stmt -> compound_stmt .)
    ELSE            reduce using rule 48 (stmt -> compound_stmt .)


state 66

    (49) stmt -> expr_stmt .
    }               reduce using rule 49 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 49 (stmt -> expr_stmt .)
    SCANF           reduce using rule 49 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 49 (stmt -> expr_stmt .)
    FOR             reduce using rule 49 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 49 (stmt -> expr_stmt .)
    BREAK           reduce using rule 49 (stmt -> expr_stmt .)
    RETURN          reduce using rule 49 (stmt -> expr_stmt .)
    WHILE           reduce using rule 49 (stmt -> expr_stmt .)
    IF              reduce using rule 49 (stmt -> expr_stmt .)
    {               reduce using rule 49 (stmt -> expr_stmt .)
    ;               reduce using rule 49 (stmt -> expr_stmt .)
    IDENT           reduce using rule 49 (stmt -> expr_stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> expr_stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> expr_stmt .)
    NEW             reduce using rule 49 (stmt -> expr_stmt .)
    STRING          reduce using rule 49 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 49 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 49 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 49 (stmt -> expr_stmt .)
    (               reduce using rule 49 (stmt -> expr_stmt .)
    +               reduce using rule 49 (stmt -> expr_stmt .)
    -               reduce using rule 49 (stmt -> expr_stmt .)
    !               reduce using rule 49 (stmt -> expr_stmt .)
    SUPER           reduce using rule 49 (stmt -> expr_stmt .)
    THIS            reduce using rule 49 (stmt -> expr_stmt .)
    ELSE            reduce using rule 49 (stmt -> expr_stmt .)


state 67

    (107) sprintf_stmt -> SPRINTF . ( IDENT , STRING , arg_list ) ;
    (               shift and go to state 97


state 68

    (77) expr -> ( . expr )
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 98

state 69

    (60) expr -> IDENT . DIVEQ expr
    (61) expr -> IDENT . MULEQ expr
    (62) expr -> IDENT . MINUSEQ expr
    (63) expr -> IDENT . PLUSEQ expr
    (73) expr -> IDENT . . SIZE ;
    (74) expr -> IDENT . ( args )
    (75) expr -> IDENT . [ expr ]
    (76) expr -> IDENT .
    (98) expr -> IDENT . [ expr ] = expr
    (99) expr -> IDENT . = expr
    DIVEQ           shift and go to state 99
    MULEQ           shift and go to state 100
    MINUSEQ         shift and go to state 101
    PLUSEQ          shift and go to state 102
    .               shift and go to state 103
    (               shift and go to state 104
    [               shift and go to state 105
    ;               reduce using rule 76 (expr -> IDENT .)
    MINUSMINUS      reduce using rule 76 (expr -> IDENT .)
    PLUSPLUS        reduce using rule 76 (expr -> IDENT .)
    AND             reduce using rule 76 (expr -> IDENT .)
    OR              reduce using rule 76 (expr -> IDENT .)
    %               reduce using rule 76 (expr -> IDENT .)
    /               reduce using rule 76 (expr -> IDENT .)
    *               reduce using rule 76 (expr -> IDENT .)
    -               reduce using rule 76 (expr -> IDENT .)
    +               reduce using rule 76 (expr -> IDENT .)
    >               reduce using rule 76 (expr -> IDENT .)
    GE              reduce using rule 76 (expr -> IDENT .)
    <               reduce using rule 76 (expr -> IDENT .)
    LE              reduce using rule 76 (expr -> IDENT .)
    NE              reduce using rule 76 (expr -> IDENT .)
    EQ              reduce using rule 76 (expr -> IDENT .)
    POINT           reduce using rule 76 (expr -> IDENT .)
    )               reduce using rule 76 (expr -> IDENT .)
    ,               reduce using rule 76 (expr -> IDENT .)
    ]               reduce using rule 76 (expr -> IDENT .)
    =               shift and go to state 106


state 70

    (69) expr -> STRING .
    ;               reduce using rule 69 (expr -> STRING .)
    MINUSMINUS      reduce using rule 69 (expr -> STRING .)
    PLUSPLUS        reduce using rule 69 (expr -> STRING .)
    AND             reduce using rule 69 (expr -> STRING .)
    OR              reduce using rule 69 (expr -> STRING .)
    %               reduce using rule 69 (expr -> STRING .)
    /               reduce using rule 69 (expr -> STRING .)
    *               reduce using rule 69 (expr -> STRING .)
    -               reduce using rule 69 (expr -> STRING .)
    +               reduce using rule 69 (expr -> STRING .)
    >               reduce using rule 69 (expr -> STRING .)
    GE              reduce using rule 69 (expr -> STRING .)
    <               reduce using rule 69 (expr -> STRING .)
    LE              reduce using rule 69 (expr -> STRING .)
    NE              reduce using rule 69 (expr -> STRING .)
    EQ              reduce using rule 69 (expr -> STRING .)
    POINT           reduce using rule 69 (expr -> STRING .)
    )               reduce using rule 69 (expr -> STRING .)
    ,               reduce using rule 69 (expr -> STRING .)
    ]               reduce using rule 69 (expr -> STRING .)


state 71

    (50) expr_stmt -> ; .
    }               reduce using rule 50 (expr_stmt -> ; .)
    SPRINTF         reduce using rule 50 (expr_stmt -> ; .)
    SCANF           reduce using rule 50 (expr_stmt -> ; .)
    PRINTF          reduce using rule 50 (expr_stmt -> ; .)
    FOR             reduce using rule 50 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 50 (expr_stmt -> ; .)
    BREAK           reduce using rule 50 (expr_stmt -> ; .)
    RETURN          reduce using rule 50 (expr_stmt -> ; .)
    WHILE           reduce using rule 50 (expr_stmt -> ; .)
    IF              reduce using rule 50 (expr_stmt -> ; .)
    {               reduce using rule 50 (expr_stmt -> ; .)
    ;               reduce using rule 50 (expr_stmt -> ; .)
    IDENT           reduce using rule 50 (expr_stmt -> ; .)
    MINUSMINUS      reduce using rule 50 (expr_stmt -> ; .)
    PLUSPLUS        reduce using rule 50 (expr_stmt -> ; .)
    NEW             reduce using rule 50 (expr_stmt -> ; .)
    STRING          reduce using rule 50 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 50 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 50 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 50 (expr_stmt -> ; .)
    (               reduce using rule 50 (expr_stmt -> ; .)
    +               reduce using rule 50 (expr_stmt -> ; .)
    -               reduce using rule 50 (expr_stmt -> ; .)
    !               reduce using rule 50 (expr_stmt -> ; .)
    SUPER           reduce using rule 50 (expr_stmt -> ; .)
    THIS            reduce using rule 50 (expr_stmt -> ; .)
    ELSE            reduce using rule 50 (expr_stmt -> ; .)


state 72

    (106) scanf_stmt -> SCANF . ( STRING , arg_list ) ;
    (               shift and go to state 107


state 73

    (104) printf_stmt -> PRINTF . ( STRING , arg_list ) ;
    (105) printf_stmt -> PRINTF . ( STRING ) ;
    (               shift and go to state 108


state 74

    (53) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 109


state 75

    (51) expr_stmt -> expr . ;
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               shift and go to state 110
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 76

    (58) break_stmt -> CONTINUE . ;
    ;               shift and go to state 127


state 77

    (59) break_stmt -> BREAK . ;
    ;               shift and go to state 128


state 78

    (56) return_stmt -> RETURN . expr ;
    (57) return_stmt -> RETURN . ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    ;               shift and go to state 130
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 129

state 79

    (52) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 131


state 80

    (54) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (55) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 132


state 81

    (64) expr -> MINUSMINUS . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 133

state 82

    (65) expr -> PLUSPLUS . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 134

state 83

    (68) expr -> NEW . type_spec [ expr ]
    (18) type_spec -> . FLOAT
    (19) type_spec -> . INT
    (20) type_spec -> . BOOL
    (21) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 135

state 84

    (70) expr -> FLOAT_LIT .
    ;               reduce using rule 70 (expr -> FLOAT_LIT .)
    MINUSMINUS      reduce using rule 70 (expr -> FLOAT_LIT .)
    PLUSPLUS        reduce using rule 70 (expr -> FLOAT_LIT .)
    AND             reduce using rule 70 (expr -> FLOAT_LIT .)
    OR              reduce using rule 70 (expr -> FLOAT_LIT .)
    %               reduce using rule 70 (expr -> FLOAT_LIT .)
    /               reduce using rule 70 (expr -> FLOAT_LIT .)
    *               reduce using rule 70 (expr -> FLOAT_LIT .)
    -               reduce using rule 70 (expr -> FLOAT_LIT .)
    +               reduce using rule 70 (expr -> FLOAT_LIT .)
    >               reduce using rule 70 (expr -> FLOAT_LIT .)
    GE              reduce using rule 70 (expr -> FLOAT_LIT .)
    <               reduce using rule 70 (expr -> FLOAT_LIT .)
    LE              reduce using rule 70 (expr -> FLOAT_LIT .)
    NE              reduce using rule 70 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 70 (expr -> FLOAT_LIT .)
    POINT           reduce using rule 70 (expr -> FLOAT_LIT .)
    )               reduce using rule 70 (expr -> FLOAT_LIT .)
    ,               reduce using rule 70 (expr -> FLOAT_LIT .)
    ]               reduce using rule 70 (expr -> FLOAT_LIT .)


state 85

    (71) expr -> INT_LIT .
    ;               reduce using rule 71 (expr -> INT_LIT .)
    MINUSMINUS      reduce using rule 71 (expr -> INT_LIT .)
    PLUSPLUS        reduce using rule 71 (expr -> INT_LIT .)
    AND             reduce using rule 71 (expr -> INT_LIT .)
    OR              reduce using rule 71 (expr -> INT_LIT .)
    %               reduce using rule 71 (expr -> INT_LIT .)
    /               reduce using rule 71 (expr -> INT_LIT .)
    *               reduce using rule 71 (expr -> INT_LIT .)
    -               reduce using rule 71 (expr -> INT_LIT .)
    +               reduce using rule 71 (expr -> INT_LIT .)
    >               reduce using rule 71 (expr -> INT_LIT .)
    GE              reduce using rule 71 (expr -> INT_LIT .)
    <               reduce using rule 71 (expr -> INT_LIT .)
    LE              reduce using rule 71 (expr -> INT_LIT .)
    NE              reduce using rule 71 (expr -> INT_LIT .)
    EQ              reduce using rule 71 (expr -> INT_LIT .)
    POINT           reduce using rule 71 (expr -> INT_LIT .)
    )               reduce using rule 71 (expr -> INT_LIT .)
    ,               reduce using rule 71 (expr -> INT_LIT .)
    ]               reduce using rule 71 (expr -> INT_LIT .)


state 86

    (72) expr -> BOOL_LIT .
    ;               reduce using rule 72 (expr -> BOOL_LIT .)
    MINUSMINUS      reduce using rule 72 (expr -> BOOL_LIT .)
    PLUSPLUS        reduce using rule 72 (expr -> BOOL_LIT .)
    AND             reduce using rule 72 (expr -> BOOL_LIT .)
    OR              reduce using rule 72 (expr -> BOOL_LIT .)
    %               reduce using rule 72 (expr -> BOOL_LIT .)
    /               reduce using rule 72 (expr -> BOOL_LIT .)
    *               reduce using rule 72 (expr -> BOOL_LIT .)
    -               reduce using rule 72 (expr -> BOOL_LIT .)
    +               reduce using rule 72 (expr -> BOOL_LIT .)
    >               reduce using rule 72 (expr -> BOOL_LIT .)
    GE              reduce using rule 72 (expr -> BOOL_LIT .)
    <               reduce using rule 72 (expr -> BOOL_LIT .)
    LE              reduce using rule 72 (expr -> BOOL_LIT .)
    NE              reduce using rule 72 (expr -> BOOL_LIT .)
    EQ              reduce using rule 72 (expr -> BOOL_LIT .)
    POINT           reduce using rule 72 (expr -> BOOL_LIT .)
    )               reduce using rule 72 (expr -> BOOL_LIT .)
    ,               reduce using rule 72 (expr -> BOOL_LIT .)
    ]               reduce using rule 72 (expr -> BOOL_LIT .)


state 87

    (78) expr -> + . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 136

state 88

    (79) expr -> - . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 137

state 89

    (80) expr -> ! . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 138

state 90

    (96) expr -> SUPER . POINT IDENT ;
    POINT           shift and go to state 139


state 91

    (97) expr -> THIS .
    ;               reduce using rule 97 (expr -> THIS .)
    MINUSMINUS      reduce using rule 97 (expr -> THIS .)
    PLUSPLUS        reduce using rule 97 (expr -> THIS .)
    AND             reduce using rule 97 (expr -> THIS .)
    OR              reduce using rule 97 (expr -> THIS .)
    %               reduce using rule 97 (expr -> THIS .)
    /               reduce using rule 97 (expr -> THIS .)
    *               reduce using rule 97 (expr -> THIS .)
    -               reduce using rule 97 (expr -> THIS .)
    +               reduce using rule 97 (expr -> THIS .)
    >               reduce using rule 97 (expr -> THIS .)
    GE              reduce using rule 97 (expr -> THIS .)
    <               reduce using rule 97 (expr -> THIS .)
    LE              reduce using rule 97 (expr -> THIS .)
    NE              reduce using rule 97 (expr -> THIS .)
    EQ              reduce using rule 97 (expr -> THIS .)
    POINT           reduce using rule 97 (expr -> THIS .)
    )               reduce using rule 97 (expr -> THIS .)
    ,               reduce using rule 97 (expr -> THIS .)
    ]               reduce using rule 97 (expr -> THIS .)


state 92

    (35) local_decl_list -> local_decl_list local_decl .
    FLOAT           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    INT             reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    BOOL            reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    VOID            reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    SPRINTF         reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    SCANF           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    PRINTF          reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    FOR             reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    CONTINUE        reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    BREAK           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    RETURN          reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    WHILE           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    IF              reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    {               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    ;               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    IDENT           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    MINUSMINUS      reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    PLUSPLUS        reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    NEW             reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    STRING          reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    FLOAT_LIT       reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    INT_LIT         reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    BOOL_LIT        reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    (               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    +               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    -               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    !               reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    SUPER           reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)
    THIS            reduce using rule 35 (local_decl_list -> local_decl_list local_decl .)


state 93

    (36) local_decl -> type_spec IDENT . [ ] ;
    (37) local_decl -> type_spec IDENT . ;
    [               shift and go to state 140
    ;               shift and go to state 141


state 94

    (13) method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .
    FLOAT           reduce using rule 13 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    INT             reduce using rule 13 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    BOOL            reduce using rule 13 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    VOID            reduce using rule 13 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    }               reduce using rule 13 (method_decl -> type_spec IDENT ( _1_params_optional ) compound_stmt .)


state 95

    (31) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    MINUSMINUS      reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    PLUSPLUS        reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 31 (compound_stmt -> { local_decls stmt_list } .)


state 96

    (39) stmt_list -> stmt_list stmt .
    }               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    SPRINTF         reduce using rule 39 (stmt_list -> stmt_list stmt .)
    SCANF           reduce using rule 39 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 39 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 39 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 39 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 39 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 39 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 39 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 39 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 39 (stmt_list -> stmt_list stmt .)
    MINUSMINUS      reduce using rule 39 (stmt_list -> stmt_list stmt .)
    PLUSPLUS        reduce using rule 39 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 39 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 39 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 39 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 39 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 39 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 39 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 39 (stmt_list -> stmt_list stmt .)


state 97

    (107) sprintf_stmt -> SPRINTF ( . IDENT , STRING , arg_list ) ;
    IDENT           shift and go to state 142


state 98

    (77) expr -> ( expr . )
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    )               shift and go to state 143
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 99

    (60) expr -> IDENT DIVEQ . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 144

state 100

    (61) expr -> IDENT MULEQ . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 145

state 101

    (62) expr -> IDENT MINUSEQ . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 146

state 102

    (63) expr -> IDENT PLUSEQ . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 147

state 103

    (73) expr -> IDENT . . SIZE ;
    SIZE            shift and go to state 148


state 104

    (74) expr -> IDENT ( . args )
    (100) args -> . empty
    (101) args -> . arg_list
    (108) empty -> .
    (102) arg_list -> . expr
    (103) arg_list -> . arg_list , expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    )               reduce using rule 108 (empty -> .)
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    args                           shift and go to state 149
    empty                          shift and go to state 150
    arg_list                       shift and go to state 151
    expr                           shift and go to state 152

state 105

    (75) expr -> IDENT [ . expr ]
    (98) expr -> IDENT [ . expr ] = expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 153

state 106

    (99) expr -> IDENT = . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 154

state 107

    (106) scanf_stmt -> SCANF ( . STRING , arg_list ) ;
    STRING          shift and go to state 155


state 108

    (104) printf_stmt -> PRINTF ( . STRING , arg_list ) ;
    (105) printf_stmt -> PRINTF ( . STRING ) ;
    STRING          shift and go to state 156


state 109

    (53) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 157

state 110

    (51) expr_stmt -> expr ; .
    }               reduce using rule 51 (expr_stmt -> expr ; .)
    SPRINTF         reduce using rule 51 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 51 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 51 (expr_stmt -> expr ; .)
    FOR             reduce using rule 51 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 51 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 51 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 51 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 51 (expr_stmt -> expr ; .)
    IF              reduce using rule 51 (expr_stmt -> expr ; .)
    {               reduce using rule 51 (expr_stmt -> expr ; .)
    ;               reduce using rule 51 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 51 (expr_stmt -> expr ; .)
    MINUSMINUS      reduce using rule 51 (expr_stmt -> expr ; .)
    PLUSPLUS        reduce using rule 51 (expr_stmt -> expr ; .)
    NEW             reduce using rule 51 (expr_stmt -> expr ; .)
    STRING          reduce using rule 51 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 51 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 51 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 51 (expr_stmt -> expr ; .)
    (               reduce using rule 51 (expr_stmt -> expr ; .)
    +               reduce using rule 51 (expr_stmt -> expr ; .)
    -               reduce using rule 51 (expr_stmt -> expr ; .)
    !               reduce using rule 51 (expr_stmt -> expr ; .)
    SUPER           reduce using rule 51 (expr_stmt -> expr ; .)
    THIS            reduce using rule 51 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 51 (expr_stmt -> expr ; .)


state 111

    (66) expr -> expr MINUSMINUS .
    ;               reduce using rule 66 (expr -> expr MINUSMINUS .)
    MINUSMINUS      reduce using rule 66 (expr -> expr MINUSMINUS .)
    PLUSPLUS        reduce using rule 66 (expr -> expr MINUSMINUS .)
    AND             reduce using rule 66 (expr -> expr MINUSMINUS .)
    OR              reduce using rule 66 (expr -> expr MINUSMINUS .)
    %               reduce using rule 66 (expr -> expr MINUSMINUS .)
    /               reduce using rule 66 (expr -> expr MINUSMINUS .)
    *               reduce using rule 66 (expr -> expr MINUSMINUS .)
    -               reduce using rule 66 (expr -> expr MINUSMINUS .)
    +               reduce using rule 66 (expr -> expr MINUSMINUS .)
    >               reduce using rule 66 (expr -> expr MINUSMINUS .)
    GE              reduce using rule 66 (expr -> expr MINUSMINUS .)
    <               reduce using rule 66 (expr -> expr MINUSMINUS .)
    LE              reduce using rule 66 (expr -> expr MINUSMINUS .)
    NE              reduce using rule 66 (expr -> expr MINUSMINUS .)
    EQ              reduce using rule 66 (expr -> expr MINUSMINUS .)
    POINT           reduce using rule 66 (expr -> expr MINUSMINUS .)
    )               reduce using rule 66 (expr -> expr MINUSMINUS .)
    ,               reduce using rule 66 (expr -> expr MINUSMINUS .)
    ]               reduce using rule 66 (expr -> expr MINUSMINUS .)


state 112

    (67) expr -> expr PLUSPLUS .
    ;               reduce using rule 67 (expr -> expr PLUSPLUS .)
    MINUSMINUS      reduce using rule 67 (expr -> expr PLUSPLUS .)
    PLUSPLUS        reduce using rule 67 (expr -> expr PLUSPLUS .)
    AND             reduce using rule 67 (expr -> expr PLUSPLUS .)
    OR              reduce using rule 67 (expr -> expr PLUSPLUS .)
    %               reduce using rule 67 (expr -> expr PLUSPLUS .)
    /               reduce using rule 67 (expr -> expr PLUSPLUS .)
    *               reduce using rule 67 (expr -> expr PLUSPLUS .)
    -               reduce using rule 67 (expr -> expr PLUSPLUS .)
    +               reduce using rule 67 (expr -> expr PLUSPLUS .)
    >               reduce using rule 67 (expr -> expr PLUSPLUS .)
    GE              reduce using rule 67 (expr -> expr PLUSPLUS .)
    <               reduce using rule 67 (expr -> expr PLUSPLUS .)
    LE              reduce using rule 67 (expr -> expr PLUSPLUS .)
    NE              reduce using rule 67 (expr -> expr PLUSPLUS .)
    EQ              reduce using rule 67 (expr -> expr PLUSPLUS .)
    POINT           reduce using rule 67 (expr -> expr PLUSPLUS .)
    )               reduce using rule 67 (expr -> expr PLUSPLUS .)
    ,               reduce using rule 67 (expr -> expr PLUSPLUS .)
    ]               reduce using rule 67 (expr -> expr PLUSPLUS .)


state 113

    (81) expr -> expr AND . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 158

state 114

    (82) expr -> expr OR . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 159

state 115

    (83) expr -> expr % . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 160

state 116

    (84) expr -> expr / . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 161

state 117

    (85) expr -> expr * . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 162

state 118

    (86) expr -> expr - . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 163

state 119

    (87) expr -> expr + . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 164

state 120

    (88) expr -> expr > . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 165

state 121

    (89) expr -> expr GE . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 166

state 122

    (90) expr -> expr < . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 167

state 123

    (91) expr -> expr LE . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 168

state 124

    (92) expr -> expr NE . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 169

state 125

    (93) expr -> expr EQ . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 170

state 126

    (94) expr -> expr POINT . IDENT = expr ;
    (95) expr -> expr POINT . IDENT ;
    IDENT           shift and go to state 171


state 127

    (58) break_stmt -> CONTINUE ; .
    }               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 58 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 58 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 58 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 58 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 58 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 58 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 58 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 58 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 58 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 58 (break_stmt -> CONTINUE ; .)
    MINUSMINUS      reduce using rule 58 (break_stmt -> CONTINUE ; .)
    PLUSPLUS        reduce using rule 58 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 58 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 58 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 58 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 58 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 58 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 58 (break_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 58 (break_stmt -> CONTINUE ; .)
    THIS            reduce using rule 58 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 58 (break_stmt -> CONTINUE ; .)


state 128

    (59) break_stmt -> BREAK ; .
    }               reduce using rule 59 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 59 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 59 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 59 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 59 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 59 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 59 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 59 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 59 (break_stmt -> BREAK ; .)
    IF              reduce using rule 59 (break_stmt -> BREAK ; .)
    {               reduce using rule 59 (break_stmt -> BREAK ; .)
    ;               reduce using rule 59 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 59 (break_stmt -> BREAK ; .)
    MINUSMINUS      reduce using rule 59 (break_stmt -> BREAK ; .)
    PLUSPLUS        reduce using rule 59 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 59 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 59 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 59 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 59 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 59 (break_stmt -> BREAK ; .)
    (               reduce using rule 59 (break_stmt -> BREAK ; .)
    +               reduce using rule 59 (break_stmt -> BREAK ; .)
    -               reduce using rule 59 (break_stmt -> BREAK ; .)
    !               reduce using rule 59 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 59 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 59 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 59 (break_stmt -> BREAK ; .)


state 129

    (56) return_stmt -> RETURN expr . ;
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               shift and go to state 172
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 130

    (57) return_stmt -> RETURN ; .
    }               reduce using rule 57 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 57 (return_stmt -> RETURN ; .)
    SCANF           reduce using rule 57 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 57 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 57 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 57 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 57 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 57 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 57 (return_stmt -> RETURN ; .)
    IF              reduce using rule 57 (return_stmt -> RETURN ; .)
    {               reduce using rule 57 (return_stmt -> RETURN ; .)
    ;               reduce using rule 57 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 57 (return_stmt -> RETURN ; .)
    MINUSMINUS      reduce using rule 57 (return_stmt -> RETURN ; .)
    PLUSPLUS        reduce using rule 57 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 57 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 57 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 57 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 57 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 57 (return_stmt -> RETURN ; .)
    (               reduce using rule 57 (return_stmt -> RETURN ; .)
    +               reduce using rule 57 (return_stmt -> RETURN ; .)
    -               reduce using rule 57 (return_stmt -> RETURN ; .)
    !               reduce using rule 57 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 57 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 57 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 57 (return_stmt -> RETURN ; .)


state 131

    (52) while_stmt -> WHILE ( . expr ) stmt
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 173

state 132

    (54) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (55) if_stmt -> IF ( . expr ) stmt
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 174

state 133

    (64) expr -> MINUSMINUS expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 64 (expr -> MINUSMINUS expr .)
    MINUSMINUS      reduce using rule 64 (expr -> MINUSMINUS expr .)
    PLUSPLUS        reduce using rule 64 (expr -> MINUSMINUS expr .)
    POINT           reduce using rule 64 (expr -> MINUSMINUS expr .)
    )               reduce using rule 64 (expr -> MINUSMINUS expr .)
    ,               reduce using rule 64 (expr -> MINUSMINUS expr .)
    ]               reduce using rule 64 (expr -> MINUSMINUS expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 134

    (65) expr -> PLUSPLUS expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 65 (expr -> PLUSPLUS expr .)
    PLUSPLUS        reduce using rule 65 (expr -> PLUSPLUS expr .)
    POINT           reduce using rule 65 (expr -> PLUSPLUS expr .)
    )               reduce using rule 65 (expr -> PLUSPLUS expr .)
    ,               reduce using rule 65 (expr -> PLUSPLUS expr .)
    ]               reduce using rule 65 (expr -> PLUSPLUS expr .)
    MINUSMINUS      shift and go to state 111
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 135

    (68) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 175


state 136

    (78) expr -> + expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 78 (expr -> + expr .)
    MINUSMINUS      reduce using rule 78 (expr -> + expr .)
    PLUSPLUS        reduce using rule 78 (expr -> + expr .)
    AND             reduce using rule 78 (expr -> + expr .)
    OR              reduce using rule 78 (expr -> + expr .)
    %               reduce using rule 78 (expr -> + expr .)
    /               reduce using rule 78 (expr -> + expr .)
    *               reduce using rule 78 (expr -> + expr .)
    -               reduce using rule 78 (expr -> + expr .)
    +               reduce using rule 78 (expr -> + expr .)
    >               reduce using rule 78 (expr -> + expr .)
    GE              reduce using rule 78 (expr -> + expr .)
    <               reduce using rule 78 (expr -> + expr .)
    LE              reduce using rule 78 (expr -> + expr .)
    NE              reduce using rule 78 (expr -> + expr .)
    EQ              reduce using rule 78 (expr -> + expr .)
    POINT           reduce using rule 78 (expr -> + expr .)
    )               reduce using rule 78 (expr -> + expr .)
    ,               reduce using rule 78 (expr -> + expr .)
    ]               reduce using rule 78 (expr -> + expr .)


state 137

    (79) expr -> - expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 79 (expr -> - expr .)
    MINUSMINUS      reduce using rule 79 (expr -> - expr .)
    PLUSPLUS        reduce using rule 79 (expr -> - expr .)
    AND             reduce using rule 79 (expr -> - expr .)
    OR              reduce using rule 79 (expr -> - expr .)
    %               reduce using rule 79 (expr -> - expr .)
    /               reduce using rule 79 (expr -> - expr .)
    *               reduce using rule 79 (expr -> - expr .)
    -               reduce using rule 79 (expr -> - expr .)
    +               reduce using rule 79 (expr -> - expr .)
    >               reduce using rule 79 (expr -> - expr .)
    GE              reduce using rule 79 (expr -> - expr .)
    <               reduce using rule 79 (expr -> - expr .)
    LE              reduce using rule 79 (expr -> - expr .)
    NE              reduce using rule 79 (expr -> - expr .)
    EQ              reduce using rule 79 (expr -> - expr .)
    POINT           reduce using rule 79 (expr -> - expr .)
    )               reduce using rule 79 (expr -> - expr .)
    ,               reduce using rule 79 (expr -> - expr .)
    ]               reduce using rule 79 (expr -> - expr .)


state 138

    (80) expr -> ! expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 80 (expr -> ! expr .)
    MINUSMINUS      reduce using rule 80 (expr -> ! expr .)
    PLUSPLUS        reduce using rule 80 (expr -> ! expr .)
    AND             reduce using rule 80 (expr -> ! expr .)
    OR              reduce using rule 80 (expr -> ! expr .)
    %               reduce using rule 80 (expr -> ! expr .)
    /               reduce using rule 80 (expr -> ! expr .)
    *               reduce using rule 80 (expr -> ! expr .)
    -               reduce using rule 80 (expr -> ! expr .)
    +               reduce using rule 80 (expr -> ! expr .)
    >               reduce using rule 80 (expr -> ! expr .)
    GE              reduce using rule 80 (expr -> ! expr .)
    <               reduce using rule 80 (expr -> ! expr .)
    LE              reduce using rule 80 (expr -> ! expr .)
    NE              reduce using rule 80 (expr -> ! expr .)
    EQ              reduce using rule 80 (expr -> ! expr .)
    POINT           reduce using rule 80 (expr -> ! expr .)
    )               reduce using rule 80 (expr -> ! expr .)
    ,               reduce using rule 80 (expr -> ! expr .)
    ]               reduce using rule 80 (expr -> ! expr .)


state 139

    (96) expr -> SUPER POINT . IDENT ;
    IDENT           shift and go to state 176


state 140

    (36) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 177


state 141

    (37) local_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    SCANF           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    MINUSMINUS      reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    PLUSPLUS        reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 37 (local_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 37 (local_decl -> type_spec IDENT ; .)


state 142

    (107) sprintf_stmt -> SPRINTF ( IDENT . , STRING , arg_list ) ;
    ,               shift and go to state 178


state 143

    (77) expr -> ( expr ) .
    ;               reduce using rule 77 (expr -> ( expr ) .)
    MINUSMINUS      reduce using rule 77 (expr -> ( expr ) .)
    PLUSPLUS        reduce using rule 77 (expr -> ( expr ) .)
    AND             reduce using rule 77 (expr -> ( expr ) .)
    OR              reduce using rule 77 (expr -> ( expr ) .)
    %               reduce using rule 77 (expr -> ( expr ) .)
    /               reduce using rule 77 (expr -> ( expr ) .)
    *               reduce using rule 77 (expr -> ( expr ) .)
    -               reduce using rule 77 (expr -> ( expr ) .)
    +               reduce using rule 77 (expr -> ( expr ) .)
    >               reduce using rule 77 (expr -> ( expr ) .)
    GE              reduce using rule 77 (expr -> ( expr ) .)
    <               reduce using rule 77 (expr -> ( expr ) .)
    LE              reduce using rule 77 (expr -> ( expr ) .)
    NE              reduce using rule 77 (expr -> ( expr ) .)
    EQ              reduce using rule 77 (expr -> ( expr ) .)
    POINT           reduce using rule 77 (expr -> ( expr ) .)
    )               reduce using rule 77 (expr -> ( expr ) .)
    ,               reduce using rule 77 (expr -> ( expr ) .)
    ]               reduce using rule 77 (expr -> ( expr ) .)


state 144

    (60) expr -> IDENT DIVEQ expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    MINUSMINUS      reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    PLUSPLUS        reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    POINT           reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    )               reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    ,               reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    ]               reduce using rule 60 (expr -> IDENT DIVEQ expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 145

    (61) expr -> IDENT MULEQ expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 61 (expr -> IDENT MULEQ expr .)
    MINUSMINUS      reduce using rule 61 (expr -> IDENT MULEQ expr .)
    PLUSPLUS        reduce using rule 61 (expr -> IDENT MULEQ expr .)
    POINT           reduce using rule 61 (expr -> IDENT MULEQ expr .)
    )               reduce using rule 61 (expr -> IDENT MULEQ expr .)
    ,               reduce using rule 61 (expr -> IDENT MULEQ expr .)
    ]               reduce using rule 61 (expr -> IDENT MULEQ expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 146

    (62) expr -> IDENT MINUSEQ expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    MINUSMINUS      reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    PLUSPLUS        reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    POINT           reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    )               reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    ,               reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    ]               reduce using rule 62 (expr -> IDENT MINUSEQ expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 147

    (63) expr -> IDENT PLUSEQ expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    MINUSMINUS      reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    PLUSPLUS        reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    POINT           reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    )               reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    ,               reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    ]               reduce using rule 63 (expr -> IDENT PLUSEQ expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 148

    (73) expr -> IDENT . SIZE . ;
    ;               shift and go to state 179


state 149

    (74) expr -> IDENT ( args . )
    )               shift and go to state 180


state 150

    (100) args -> empty .
    )               reduce using rule 100 (args -> empty .)


state 151

    (101) args -> arg_list .
    (103) arg_list -> arg_list . , expr
    )               reduce using rule 101 (args -> arg_list .)
    ,               shift and go to state 181


state 152

    (102) arg_list -> expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ,               reduce using rule 102 (arg_list -> expr .)
    )               reduce using rule 102 (arg_list -> expr .)
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 153

    (75) expr -> IDENT [ expr . ]
    (98) expr -> IDENT [ expr . ] = expr
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ]               shift and go to state 182
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 154

    (99) expr -> IDENT = expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 99 (expr -> IDENT = expr .)
    MINUSMINUS      reduce using rule 99 (expr -> IDENT = expr .)
    PLUSPLUS        reduce using rule 99 (expr -> IDENT = expr .)
    POINT           reduce using rule 99 (expr -> IDENT = expr .)
    )               reduce using rule 99 (expr -> IDENT = expr .)
    ,               reduce using rule 99 (expr -> IDENT = expr .)
    ]               reduce using rule 99 (expr -> IDENT = expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 155

    (106) scanf_stmt -> SCANF ( STRING . , arg_list ) ;
    ,               shift and go to state 183


state 156

    (104) printf_stmt -> PRINTF ( STRING . , arg_list ) ;
    (105) printf_stmt -> PRINTF ( STRING . ) ;
    ,               shift and go to state 184
    )               shift and go to state 185


state 157

    (53) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               shift and go to state 186
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 158

    (81) expr -> expr AND expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 81 (expr -> expr AND expr .)
    MINUSMINUS      reduce using rule 81 (expr -> expr AND expr .)
    PLUSPLUS        reduce using rule 81 (expr -> expr AND expr .)
    AND             reduce using rule 81 (expr -> expr AND expr .)
    OR              reduce using rule 81 (expr -> expr AND expr .)
    POINT           reduce using rule 81 (expr -> expr AND expr .)
    )               reduce using rule 81 (expr -> expr AND expr .)
    ,               reduce using rule 81 (expr -> expr AND expr .)
    ]               reduce using rule 81 (expr -> expr AND expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 159

    (82) expr -> expr OR expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 82 (expr -> expr OR expr .)
    MINUSMINUS      reduce using rule 82 (expr -> expr OR expr .)
    PLUSPLUS        reduce using rule 82 (expr -> expr OR expr .)
    OR              reduce using rule 82 (expr -> expr OR expr .)
    POINT           reduce using rule 82 (expr -> expr OR expr .)
    )               reduce using rule 82 (expr -> expr OR expr .)
    ,               reduce using rule 82 (expr -> expr OR expr .)
    ]               reduce using rule 82 (expr -> expr OR expr .)
    AND             shift and go to state 113
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 160

    (83) expr -> expr % expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 83 (expr -> expr % expr .)
    MINUSMINUS      reduce using rule 83 (expr -> expr % expr .)
    PLUSPLUS        reduce using rule 83 (expr -> expr % expr .)
    AND             reduce using rule 83 (expr -> expr % expr .)
    OR              reduce using rule 83 (expr -> expr % expr .)
    %               reduce using rule 83 (expr -> expr % expr .)
    /               reduce using rule 83 (expr -> expr % expr .)
    *               reduce using rule 83 (expr -> expr % expr .)
    -               reduce using rule 83 (expr -> expr % expr .)
    +               reduce using rule 83 (expr -> expr % expr .)
    >               reduce using rule 83 (expr -> expr % expr .)
    GE              reduce using rule 83 (expr -> expr % expr .)
    <               reduce using rule 83 (expr -> expr % expr .)
    LE              reduce using rule 83 (expr -> expr % expr .)
    NE              reduce using rule 83 (expr -> expr % expr .)
    EQ              reduce using rule 83 (expr -> expr % expr .)
    POINT           reduce using rule 83 (expr -> expr % expr .)
    )               reduce using rule 83 (expr -> expr % expr .)
    ,               reduce using rule 83 (expr -> expr % expr .)
    ]               reduce using rule 83 (expr -> expr % expr .)


state 161

    (84) expr -> expr / expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 84 (expr -> expr / expr .)
    MINUSMINUS      reduce using rule 84 (expr -> expr / expr .)
    PLUSPLUS        reduce using rule 84 (expr -> expr / expr .)
    AND             reduce using rule 84 (expr -> expr / expr .)
    OR              reduce using rule 84 (expr -> expr / expr .)
    %               reduce using rule 84 (expr -> expr / expr .)
    /               reduce using rule 84 (expr -> expr / expr .)
    *               reduce using rule 84 (expr -> expr / expr .)
    -               reduce using rule 84 (expr -> expr / expr .)
    +               reduce using rule 84 (expr -> expr / expr .)
    >               reduce using rule 84 (expr -> expr / expr .)
    GE              reduce using rule 84 (expr -> expr / expr .)
    <               reduce using rule 84 (expr -> expr / expr .)
    LE              reduce using rule 84 (expr -> expr / expr .)
    NE              reduce using rule 84 (expr -> expr / expr .)
    EQ              reduce using rule 84 (expr -> expr / expr .)
    POINT           reduce using rule 84 (expr -> expr / expr .)
    )               reduce using rule 84 (expr -> expr / expr .)
    ,               reduce using rule 84 (expr -> expr / expr .)
    ]               reduce using rule 84 (expr -> expr / expr .)


state 162

    (85) expr -> expr * expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 85 (expr -> expr * expr .)
    MINUSMINUS      reduce using rule 85 (expr -> expr * expr .)
    PLUSPLUS        reduce using rule 85 (expr -> expr * expr .)
    AND             reduce using rule 85 (expr -> expr * expr .)
    OR              reduce using rule 85 (expr -> expr * expr .)
    %               reduce using rule 85 (expr -> expr * expr .)
    /               reduce using rule 85 (expr -> expr * expr .)
    *               reduce using rule 85 (expr -> expr * expr .)
    -               reduce using rule 85 (expr -> expr * expr .)
    +               reduce using rule 85 (expr -> expr * expr .)
    >               reduce using rule 85 (expr -> expr * expr .)
    GE              reduce using rule 85 (expr -> expr * expr .)
    <               reduce using rule 85 (expr -> expr * expr .)
    LE              reduce using rule 85 (expr -> expr * expr .)
    NE              reduce using rule 85 (expr -> expr * expr .)
    EQ              reduce using rule 85 (expr -> expr * expr .)
    POINT           reduce using rule 85 (expr -> expr * expr .)
    )               reduce using rule 85 (expr -> expr * expr .)
    ,               reduce using rule 85 (expr -> expr * expr .)
    ]               reduce using rule 85 (expr -> expr * expr .)


state 163

    (86) expr -> expr - expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 86 (expr -> expr - expr .)
    MINUSMINUS      reduce using rule 86 (expr -> expr - expr .)
    PLUSPLUS        reduce using rule 86 (expr -> expr - expr .)
    AND             reduce using rule 86 (expr -> expr - expr .)
    OR              reduce using rule 86 (expr -> expr - expr .)
    -               reduce using rule 86 (expr -> expr - expr .)
    +               reduce using rule 86 (expr -> expr - expr .)
    >               reduce using rule 86 (expr -> expr - expr .)
    GE              reduce using rule 86 (expr -> expr - expr .)
    <               reduce using rule 86 (expr -> expr - expr .)
    LE              reduce using rule 86 (expr -> expr - expr .)
    NE              reduce using rule 86 (expr -> expr - expr .)
    EQ              reduce using rule 86 (expr -> expr - expr .)
    POINT           reduce using rule 86 (expr -> expr - expr .)
    )               reduce using rule 86 (expr -> expr - expr .)
    ,               reduce using rule 86 (expr -> expr - expr .)
    ]               reduce using rule 86 (expr -> expr - expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117


state 164

    (87) expr -> expr + expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 87 (expr -> expr + expr .)
    MINUSMINUS      reduce using rule 87 (expr -> expr + expr .)
    PLUSPLUS        reduce using rule 87 (expr -> expr + expr .)
    AND             reduce using rule 87 (expr -> expr + expr .)
    OR              reduce using rule 87 (expr -> expr + expr .)
    -               reduce using rule 87 (expr -> expr + expr .)
    +               reduce using rule 87 (expr -> expr + expr .)
    >               reduce using rule 87 (expr -> expr + expr .)
    GE              reduce using rule 87 (expr -> expr + expr .)
    <               reduce using rule 87 (expr -> expr + expr .)
    LE              reduce using rule 87 (expr -> expr + expr .)
    NE              reduce using rule 87 (expr -> expr + expr .)
    EQ              reduce using rule 87 (expr -> expr + expr .)
    POINT           reduce using rule 87 (expr -> expr + expr .)
    )               reduce using rule 87 (expr -> expr + expr .)
    ,               reduce using rule 87 (expr -> expr + expr .)
    ]               reduce using rule 87 (expr -> expr + expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117


state 165

    (88) expr -> expr > expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 88 (expr -> expr > expr .)
    MINUSMINUS      reduce using rule 88 (expr -> expr > expr .)
    PLUSPLUS        reduce using rule 88 (expr -> expr > expr .)
    AND             reduce using rule 88 (expr -> expr > expr .)
    OR              reduce using rule 88 (expr -> expr > expr .)
    >               reduce using rule 88 (expr -> expr > expr .)
    GE              reduce using rule 88 (expr -> expr > expr .)
    <               reduce using rule 88 (expr -> expr > expr .)
    LE              reduce using rule 88 (expr -> expr > expr .)
    NE              reduce using rule 88 (expr -> expr > expr .)
    EQ              reduce using rule 88 (expr -> expr > expr .)
    POINT           reduce using rule 88 (expr -> expr > expr .)
    )               reduce using rule 88 (expr -> expr > expr .)
    ,               reduce using rule 88 (expr -> expr > expr .)
    ]               reduce using rule 88 (expr -> expr > expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119


state 166

    (89) expr -> expr GE expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 89 (expr -> expr GE expr .)
    MINUSMINUS      reduce using rule 89 (expr -> expr GE expr .)
    PLUSPLUS        reduce using rule 89 (expr -> expr GE expr .)
    AND             reduce using rule 89 (expr -> expr GE expr .)
    OR              reduce using rule 89 (expr -> expr GE expr .)
    >               reduce using rule 89 (expr -> expr GE expr .)
    GE              reduce using rule 89 (expr -> expr GE expr .)
    <               reduce using rule 89 (expr -> expr GE expr .)
    LE              reduce using rule 89 (expr -> expr GE expr .)
    NE              reduce using rule 89 (expr -> expr GE expr .)
    EQ              reduce using rule 89 (expr -> expr GE expr .)
    POINT           reduce using rule 89 (expr -> expr GE expr .)
    )               reduce using rule 89 (expr -> expr GE expr .)
    ,               reduce using rule 89 (expr -> expr GE expr .)
    ]               reduce using rule 89 (expr -> expr GE expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119


state 167

    (90) expr -> expr < expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 90 (expr -> expr < expr .)
    MINUSMINUS      reduce using rule 90 (expr -> expr < expr .)
    PLUSPLUS        reduce using rule 90 (expr -> expr < expr .)
    AND             reduce using rule 90 (expr -> expr < expr .)
    OR              reduce using rule 90 (expr -> expr < expr .)
    >               reduce using rule 90 (expr -> expr < expr .)
    GE              reduce using rule 90 (expr -> expr < expr .)
    <               reduce using rule 90 (expr -> expr < expr .)
    LE              reduce using rule 90 (expr -> expr < expr .)
    NE              reduce using rule 90 (expr -> expr < expr .)
    EQ              reduce using rule 90 (expr -> expr < expr .)
    POINT           reduce using rule 90 (expr -> expr < expr .)
    )               reduce using rule 90 (expr -> expr < expr .)
    ,               reduce using rule 90 (expr -> expr < expr .)
    ]               reduce using rule 90 (expr -> expr < expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119


state 168

    (91) expr -> expr LE expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 91 (expr -> expr LE expr .)
    MINUSMINUS      reduce using rule 91 (expr -> expr LE expr .)
    PLUSPLUS        reduce using rule 91 (expr -> expr LE expr .)
    AND             reduce using rule 91 (expr -> expr LE expr .)
    OR              reduce using rule 91 (expr -> expr LE expr .)
    >               reduce using rule 91 (expr -> expr LE expr .)
    GE              reduce using rule 91 (expr -> expr LE expr .)
    <               reduce using rule 91 (expr -> expr LE expr .)
    LE              reduce using rule 91 (expr -> expr LE expr .)
    NE              reduce using rule 91 (expr -> expr LE expr .)
    EQ              reduce using rule 91 (expr -> expr LE expr .)
    POINT           reduce using rule 91 (expr -> expr LE expr .)
    )               reduce using rule 91 (expr -> expr LE expr .)
    ,               reduce using rule 91 (expr -> expr LE expr .)
    ]               reduce using rule 91 (expr -> expr LE expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119


state 169

    (92) expr -> expr NE expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 92 (expr -> expr NE expr .)
    MINUSMINUS      reduce using rule 92 (expr -> expr NE expr .)
    PLUSPLUS        reduce using rule 92 (expr -> expr NE expr .)
    AND             reduce using rule 92 (expr -> expr NE expr .)
    OR              reduce using rule 92 (expr -> expr NE expr .)
    NE              reduce using rule 92 (expr -> expr NE expr .)
    EQ              reduce using rule 92 (expr -> expr NE expr .)
    POINT           reduce using rule 92 (expr -> expr NE expr .)
    )               reduce using rule 92 (expr -> expr NE expr .)
    ,               reduce using rule 92 (expr -> expr NE expr .)
    ]               reduce using rule 92 (expr -> expr NE expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123


state 170

    (93) expr -> expr EQ expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 93 (expr -> expr EQ expr .)
    MINUSMINUS      reduce using rule 93 (expr -> expr EQ expr .)
    PLUSPLUS        reduce using rule 93 (expr -> expr EQ expr .)
    AND             reduce using rule 93 (expr -> expr EQ expr .)
    OR              reduce using rule 93 (expr -> expr EQ expr .)
    NE              reduce using rule 93 (expr -> expr EQ expr .)
    EQ              reduce using rule 93 (expr -> expr EQ expr .)
    POINT           reduce using rule 93 (expr -> expr EQ expr .)
    )               reduce using rule 93 (expr -> expr EQ expr .)
    ,               reduce using rule 93 (expr -> expr EQ expr .)
    ]               reduce using rule 93 (expr -> expr EQ expr .)
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123


state 171

    (94) expr -> expr POINT IDENT . = expr ;
    (95) expr -> expr POINT IDENT . ;
    =               shift and go to state 187
    ;               shift and go to state 188


state 172

    (56) return_stmt -> RETURN expr ; .
    }               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 56 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 56 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 56 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 56 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 56 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 56 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 56 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 56 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 56 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 56 (return_stmt -> RETURN expr ; .)
    MINUSMINUS      reduce using rule 56 (return_stmt -> RETURN expr ; .)
    PLUSPLUS        reduce using rule 56 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 56 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 56 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 56 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 56 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 56 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 56 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 56 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 56 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 56 (return_stmt -> RETURN expr ; .)


state 173

    (52) while_stmt -> WHILE ( expr . ) stmt
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    )               shift and go to state 189
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 174

    (54) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (55) if_stmt -> IF ( expr . ) stmt
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    )               shift and go to state 190
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 175

    (68) expr -> NEW type_spec [ . expr ]
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 191

state 176

    (96) expr -> SUPER POINT IDENT . ;
    ;               shift and go to state 192


state 177

    (36) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 193


state 178

    (107) sprintf_stmt -> SPRINTF ( IDENT , . STRING , arg_list ) ;
    STRING          shift and go to state 194


state 179

    (73) expr -> IDENT . SIZE ; .
    ;               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    MINUSMINUS      reduce using rule 73 (expr -> IDENT . SIZE ; .)
    PLUSPLUS        reduce using rule 73 (expr -> IDENT . SIZE ; .)
    AND             reduce using rule 73 (expr -> IDENT . SIZE ; .)
    OR              reduce using rule 73 (expr -> IDENT . SIZE ; .)
    %               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    /               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    *               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    -               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    +               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    >               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    GE              reduce using rule 73 (expr -> IDENT . SIZE ; .)
    <               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    LE              reduce using rule 73 (expr -> IDENT . SIZE ; .)
    NE              reduce using rule 73 (expr -> IDENT . SIZE ; .)
    EQ              reduce using rule 73 (expr -> IDENT . SIZE ; .)
    POINT           reduce using rule 73 (expr -> IDENT . SIZE ; .)
    )               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    ,               reduce using rule 73 (expr -> IDENT . SIZE ; .)
    ]               reduce using rule 73 (expr -> IDENT . SIZE ; .)


state 180

    (74) expr -> IDENT ( args ) .
    ;               reduce using rule 74 (expr -> IDENT ( args ) .)
    MINUSMINUS      reduce using rule 74 (expr -> IDENT ( args ) .)
    PLUSPLUS        reduce using rule 74 (expr -> IDENT ( args ) .)
    AND             reduce using rule 74 (expr -> IDENT ( args ) .)
    OR              reduce using rule 74 (expr -> IDENT ( args ) .)
    %               reduce using rule 74 (expr -> IDENT ( args ) .)
    /               reduce using rule 74 (expr -> IDENT ( args ) .)
    *               reduce using rule 74 (expr -> IDENT ( args ) .)
    -               reduce using rule 74 (expr -> IDENT ( args ) .)
    +               reduce using rule 74 (expr -> IDENT ( args ) .)
    >               reduce using rule 74 (expr -> IDENT ( args ) .)
    GE              reduce using rule 74 (expr -> IDENT ( args ) .)
    <               reduce using rule 74 (expr -> IDENT ( args ) .)
    LE              reduce using rule 74 (expr -> IDENT ( args ) .)
    NE              reduce using rule 74 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 74 (expr -> IDENT ( args ) .)
    POINT           reduce using rule 74 (expr -> IDENT ( args ) .)
    )               reduce using rule 74 (expr -> IDENT ( args ) .)
    ,               reduce using rule 74 (expr -> IDENT ( args ) .)
    ]               reduce using rule 74 (expr -> IDENT ( args ) .)


state 181

    (103) arg_list -> arg_list , . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 195

state 182

    (75) expr -> IDENT [ expr ] .
    (98) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 75 (expr -> IDENT [ expr ] .)
    MINUSMINUS      reduce using rule 75 (expr -> IDENT [ expr ] .)
    PLUSPLUS        reduce using rule 75 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 75 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 75 (expr -> IDENT [ expr ] .)
    %               reduce using rule 75 (expr -> IDENT [ expr ] .)
    /               reduce using rule 75 (expr -> IDENT [ expr ] .)
    *               reduce using rule 75 (expr -> IDENT [ expr ] .)
    -               reduce using rule 75 (expr -> IDENT [ expr ] .)
    +               reduce using rule 75 (expr -> IDENT [ expr ] .)
    >               reduce using rule 75 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 75 (expr -> IDENT [ expr ] .)
    <               reduce using rule 75 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 75 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 75 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 75 (expr -> IDENT [ expr ] .)
    POINT           reduce using rule 75 (expr -> IDENT [ expr ] .)
    )               reduce using rule 75 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 75 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 75 (expr -> IDENT [ expr ] .)
    =               shift and go to state 196


state 183

    (106) scanf_stmt -> SCANF ( STRING , . arg_list ) ;
    (102) arg_list -> . expr
    (103) arg_list -> . arg_list , expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    arg_list                       shift and go to state 197
    expr                           shift and go to state 152

state 184

    (104) printf_stmt -> PRINTF ( STRING , . arg_list ) ;
    (102) arg_list -> . expr
    (103) arg_list -> . arg_list , expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    arg_list                       shift and go to state 198
    expr                           shift and go to state 152

state 185

    (105) printf_stmt -> PRINTF ( STRING ) . ;
    ;               shift and go to state 199


state 186

    (53) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 200

state 187

    (94) expr -> expr POINT IDENT = . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 201

state 188

    (95) expr -> expr POINT IDENT ; .
    ;               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    MINUSMINUS      reduce using rule 95 (expr -> expr POINT IDENT ; .)
    PLUSPLUS        reduce using rule 95 (expr -> expr POINT IDENT ; .)
    AND             reduce using rule 95 (expr -> expr POINT IDENT ; .)
    OR              reduce using rule 95 (expr -> expr POINT IDENT ; .)
    %               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    /               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    *               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    -               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    +               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    >               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    GE              reduce using rule 95 (expr -> expr POINT IDENT ; .)
    <               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    LE              reduce using rule 95 (expr -> expr POINT IDENT ; .)
    NE              reduce using rule 95 (expr -> expr POINT IDENT ; .)
    EQ              reduce using rule 95 (expr -> expr POINT IDENT ; .)
    POINT           reduce using rule 95 (expr -> expr POINT IDENT ; .)
    )               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    ,               reduce using rule 95 (expr -> expr POINT IDENT ; .)
    ]               reduce using rule 95 (expr -> expr POINT IDENT ; .)


state 189

    (52) while_stmt -> WHILE ( expr ) . stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 75
    stmt                           shift and go to state 202
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66

state 190

    (54) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (55) if_stmt -> IF ( expr ) . stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 75
    stmt                           shift and go to state 203
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66

state 191

    (68) expr -> NEW type_spec [ expr . ]
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ]               shift and go to state 204
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 192

    (96) expr -> SUPER POINT IDENT ; .
    ;               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    MINUSMINUS      reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    PLUSPLUS        reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    AND             reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    OR              reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    %               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    /               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    *               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    -               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    +               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    >               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    GE              reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    <               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    LE              reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    NE              reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    EQ              reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    POINT           reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    )               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    ,               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)
    ]               reduce using rule 96 (expr -> SUPER POINT IDENT ; .)


state 193

    (36) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    SPRINTF         reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    SCANF           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    PRINTF          reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    MINUSMINUS      reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    PLUSPLUS        reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    SUPER           reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)
    THIS            reduce using rule 36 (local_decl -> type_spec IDENT [ ] ; .)


state 194

    (107) sprintf_stmt -> SPRINTF ( IDENT , STRING . , arg_list ) ;
    ,               shift and go to state 205


state 195

    (103) arg_list -> arg_list , expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ,               reduce using rule 103 (arg_list -> arg_list , expr .)
    )               reduce using rule 103 (arg_list -> arg_list , expr .)
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 196

    (98) expr -> IDENT [ expr ] = . expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 206

state 197

    (106) scanf_stmt -> SCANF ( STRING , arg_list . ) ;
    (103) arg_list -> arg_list . , expr
    )               shift and go to state 207
    ,               shift and go to state 181


state 198

    (104) printf_stmt -> PRINTF ( STRING , arg_list . ) ;
    (103) arg_list -> arg_list . , expr
    )               shift and go to state 208
    ,               shift and go to state 181


state 199

    (105) printf_stmt -> PRINTF ( STRING ) ; .
    }               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    SPRINTF         reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    SCANF           reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    CONTINUE        reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    BREAK           reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    WHILE           reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    {               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    ;               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    IDENT           reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    MINUSMINUS      reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    PLUSPLUS        reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    NEW             reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    STRING          reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    FLOAT_LIT       reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    INT_LIT         reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    BOOL_LIT        reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    (               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    +               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    -               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    !               reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    SUPER           reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    THIS            reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)
    ELSE            reduce using rule 105 (printf_stmt -> PRINTF ( STRING ) ; .)


state 200

    (53) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               shift and go to state 209
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 201

    (94) expr -> expr POINT IDENT = expr . ;
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               shift and go to state 210
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 202

    (52) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    MINUSMINUS      reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    PLUSPLUS        reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 52 (while_stmt -> WHILE ( expr ) stmt .)


state 203

    (54) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (55) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 211
    }               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    MINUSMINUS      reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    PLUSPLUS        reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 55 (if_stmt -> IF ( expr ) stmt .)


state 204

    (68) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    MINUSMINUS      reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    PLUSPLUS        reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    POINT           reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 68 (expr -> NEW type_spec [ expr ] .)


state 205

    (107) sprintf_stmt -> SPRINTF ( IDENT , STRING , . arg_list ) ;
    (102) arg_list -> . expr
    (103) arg_list -> . arg_list , expr
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    arg_list                       shift and go to state 212
    expr                           shift and go to state 152

state 206

    (98) expr -> IDENT [ expr ] = expr .
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    ;               reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    MINUSMINUS      reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    PLUSPLUS        reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    POINT           reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 98 (expr -> IDENT [ expr ] = expr .)
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125


state 207

    (106) scanf_stmt -> SCANF ( STRING , arg_list ) . ;
    ;               shift and go to state 213


state 208

    (104) printf_stmt -> PRINTF ( STRING , arg_list ) . ;
    ;               shift and go to state 214


state 209

    (53) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 215

state 210

    (94) expr -> expr POINT IDENT = expr ; .
    ;               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    MINUSMINUS      reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    PLUSPLUS        reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    AND             reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    OR              reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    %               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    /               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    *               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    -               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    +               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    >               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    GE              reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    <               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    LE              reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    NE              reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    EQ              reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    POINT           reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    )               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    ,               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)
    ]               reduce using rule 94 (expr -> expr POINT IDENT = expr ; .)


state 211

    (54) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 75
    stmt                           shift and go to state 216
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66

state 212

    (107) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list . ) ;
    (103) arg_list -> arg_list . , expr
    )               shift and go to state 217
    ,               shift and go to state 181


state 213

    (106) scanf_stmt -> SCANF ( STRING , arg_list ) ; .
    }               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IF              reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    {               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ;               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    (               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    +               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    -               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    !               reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 106 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)


state 214

    (104) printf_stmt -> PRINTF ( STRING , arg_list ) ; .
    }               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IF              reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    {               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ;               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    (               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    +               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    -               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    !               reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 104 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)


state 215

    (53) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (66) expr -> expr . MINUSMINUS
    (67) expr -> expr . PLUSPLUS
    (81) expr -> expr . AND expr
    (82) expr -> expr . OR expr
    (83) expr -> expr . % expr
    (84) expr -> expr . / expr
    (85) expr -> expr . * expr
    (86) expr -> expr . - expr
    (87) expr -> expr . + expr
    (88) expr -> expr . > expr
    (89) expr -> expr . GE expr
    (90) expr -> expr . < expr
    (91) expr -> expr . LE expr
    (92) expr -> expr . NE expr
    (93) expr -> expr . EQ expr
    (94) expr -> expr . POINT IDENT = expr ;
    (95) expr -> expr . POINT IDENT ;
    )               shift and go to state 218
    MINUSMINUS      shift and go to state 111
    PLUSPLUS        shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    %               shift and go to state 115
    /               shift and go to state 116
    *               shift and go to state 117
    -               shift and go to state 118
    +               shift and go to state 119
    >               shift and go to state 120
    GE              shift and go to state 121
    <               shift and go to state 122
    LE              shift and go to state 123
    NE              shift and go to state 124
    EQ              shift and go to state 125
    POINT           shift and go to state 126


state 216

    (54) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 54 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 217

    (107) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) . ;
    ;               shift and go to state 219


state 218

    (53) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (40) stmt -> . sprintf_stmt
    (41) stmt -> . scanf_stmt
    (42) stmt -> . printf_stmt
    (43) stmt -> . for_stmt
    (44) stmt -> . break_stmt
    (45) stmt -> . return_stmt
    (46) stmt -> . while_stmt
    (47) stmt -> . if_stmt
    (48) stmt -> . compound_stmt
    (49) stmt -> . expr_stmt
    (107) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (106) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (105) printf_stmt -> . PRINTF ( STRING ) ;
    (53) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (58) break_stmt -> . CONTINUE ;
    (59) break_stmt -> . BREAK ;
    (56) return_stmt -> . RETURN expr ;
    (57) return_stmt -> . RETURN ;
    (52) while_stmt -> . WHILE ( expr ) stmt
    (54) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (55) if_stmt -> . IF ( expr ) stmt
    (31) compound_stmt -> . { local_decls stmt_list }
    (50) expr_stmt -> . ;
    (51) expr_stmt -> . expr ;
    (60) expr -> . IDENT DIVEQ expr
    (61) expr -> . IDENT MULEQ expr
    (62) expr -> . IDENT MINUSEQ expr
    (63) expr -> . IDENT PLUSEQ expr
    (64) expr -> . MINUSMINUS expr
    (65) expr -> . PLUSPLUS expr
    (66) expr -> . expr MINUSMINUS
    (67) expr -> . expr PLUSPLUS
    (68) expr -> . NEW type_spec [ expr ]
    (69) expr -> . STRING
    (70) expr -> . FLOAT_LIT
    (71) expr -> . INT_LIT
    (72) expr -> . BOOL_LIT
    (73) expr -> . IDENT . SIZE ;
    (74) expr -> . IDENT ( args )
    (75) expr -> . IDENT [ expr ]
    (76) expr -> . IDENT
    (77) expr -> . ( expr )
    (78) expr -> . + expr
    (79) expr -> . - expr
    (80) expr -> . ! expr
    (81) expr -> . expr AND expr
    (82) expr -> . expr OR expr
    (83) expr -> . expr % expr
    (84) expr -> . expr / expr
    (85) expr -> . expr * expr
    (86) expr -> . expr - expr
    (87) expr -> . expr + expr
    (88) expr -> . expr > expr
    (89) expr -> . expr GE expr
    (90) expr -> . expr < expr
    (91) expr -> . expr LE expr
    (92) expr -> . expr NE expr
    (93) expr -> . expr EQ expr
    (94) expr -> . expr POINT IDENT = expr ;
    (95) expr -> . expr POINT IDENT ;
    (96) expr -> . SUPER POINT IDENT ;
    (97) expr -> . THIS
    (98) expr -> . IDENT [ expr ] = expr
    (99) expr -> . IDENT = expr
    SPRINTF         shift and go to state 67
    SCANF           shift and go to state 72
    PRINTF          shift and go to state 73
    FOR             shift and go to state 74
    CONTINUE        shift and go to state 76
    BREAK           shift and go to state 77
    RETURN          shift and go to state 78
    WHILE           shift and go to state 79
    IF              shift and go to state 80
    {               shift and go to state 44
    ;               shift and go to state 71
    IDENT           shift and go to state 69
    MINUSMINUS      shift and go to state 81
    PLUSPLUS        shift and go to state 82
    NEW             shift and go to state 83
    STRING          shift and go to state 70
    FLOAT_LIT       shift and go to state 84
    INT_LIT         shift and go to state 85
    BOOL_LIT        shift and go to state 86
    (               shift and go to state 68
    +               shift and go to state 87
    -               shift and go to state 88
    !               shift and go to state 89
    SUPER           shift and go to state 90
    THIS            shift and go to state 91

    expr                           shift and go to state 75
    stmt                           shift and go to state 220
    sprintf_stmt                   shift and go to state 57
    scanf_stmt                     shift and go to state 58
    printf_stmt                    shift and go to state 59
    for_stmt                       shift and go to state 60
    break_stmt                     shift and go to state 61
    return_stmt                    shift and go to state 62
    while_stmt                     shift and go to state 63
    if_stmt                        shift and go to state 64
    compound_stmt                  shift and go to state 65
    expr_stmt                      shift and go to state 66

state 219

    (107) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .
    }               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SCANF           reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PRINTF          reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FOR             reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BREAK           reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    RETURN          reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    WHILE           reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IF              reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    {               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ;               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IDENT           reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    NEW             reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    STRING          reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    (               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    +               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    -               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    !               reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SUPER           reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    THIS            reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ELSE            reduce using rule 107 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)


state 220

    (53) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    }               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SPRINTF         reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CONTINUE        reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING          reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SUPER           reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    THIS            reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 53 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
