Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     class_decl -> CLASS IDENT { class_body } ;
Rule 8     class_body -> empty
Rule 9     class_body -> class_member_list
Rule 10    class_member_list -> class_member
Rule 11    class_member_list -> class_member_list class_member
Rule 12    class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt
Rule 13    _1_params_optional -> params
Rule 14    _1_params_optional -> <empty>
Rule 15    var_decl -> type_spec IDENT [ ] ;
Rule 16    var_decl -> type_spec IDENT ;
Rule 17    type_spec -> FLOAT
Rule 18    type_spec -> INT
Rule 19    type_spec -> BOOL
Rule 20    type_spec -> VOID
Rule 21    func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt
Rule 22    _2_params_optional -> params
Rule 23    _2_params_optional -> <empty>
Rule 24    params -> VOID
Rule 25    params -> param_list
Rule 26    param_list -> param
Rule 27    param_list -> param_list , param
Rule 28    param -> type_spec IDENT [ ]
Rule 29    param -> type_spec IDENT
Rule 30    compound_stmt -> { local_decls stmt_list }
Rule 31    local_decls -> empty
Rule 32    local_decls -> local_decl_list
Rule 33    local_decl_list -> local_decl
Rule 34    local_decl_list -> local_decl_list local_decl
Rule 35    local_decl -> type_spec IDENT [ ] ;
Rule 36    local_decl -> type_spec IDENT ;
Rule 37    stmt_list -> stmt
Rule 38    stmt_list -> stmt_list stmt
Rule 39    stmt -> sprintf_stmt
Rule 40    stmt -> scanf_stmt
Rule 41    stmt -> printf_stmt
Rule 42    stmt -> for_stmt
Rule 43    stmt -> break_stmt
Rule 44    stmt -> return_stmt
Rule 45    stmt -> while_stmt
Rule 46    stmt -> if_stmt
Rule 47    stmt -> compound_stmt
Rule 48    stmt -> expr_stmt
Rule 49    expr_stmt -> ;
Rule 50    expr_stmt -> expr ;
Rule 51    while_stmt -> WHILE ( expr ) stmt
Rule 52    for_stmt -> FOR ( expr ; expr ; expr ) stmt
Rule 53    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=3]
Rule 54    if_stmt -> IF ( expr ) stmt  [precedence=left, level=2]
Rule 55    return_stmt -> RETURN expr ;
Rule 56    return_stmt -> RETURN ;
Rule 57    break_stmt -> CONTINUE ;
Rule 58    break_stmt -> BREAK ;
Rule 59    expr -> expr DIVEQ expr ;
Rule 60    expr -> expr MULEQ expr ;
Rule 61    expr -> expr MINUSEQ expr ;
Rule 62    expr -> expr PLUSEQ expr ;
Rule 63    expr -> MINUSMINUS expr ;
Rule 64    expr -> PLUSPLUS expr ;
Rule 65    expr -> expr MINUSMINUS ;
Rule 66    expr -> expr PLUSPLUS ;
Rule 67    expr -> NEW type_spec [ expr ]
Rule 68    expr -> STRING
Rule 69    expr -> FLOAT_LIT
Rule 70    expr -> INT_LIT
Rule 71    expr -> BOOL_LIT
Rule 72    expr -> IDENT . SIZE ;
Rule 73    expr -> IDENT ( args )
Rule 74    expr -> IDENT [ expr ]
Rule 75    expr -> IDENT
Rule 76    expr -> ( expr )
Rule 77    expr -> + expr  [precedence=right, level=11]
Rule 78    expr -> - expr  [precedence=right, level=11]
Rule 79    expr -> ! expr  [precedence=right, level=11]
Rule 80    expr -> expr AND expr  [precedence=left, level=6]
Rule 81    expr -> expr OR expr  [precedence=left, level=5]
Rule 82    expr -> expr % expr  [precedence=left, level=10]
Rule 83    expr -> expr / expr  [precedence=left, level=10]
Rule 84    expr -> expr * expr  [precedence=left, level=10]
Rule 85    expr -> expr - expr  [precedence=left, level=9]
Rule 86    expr -> expr + expr  [precedence=left, level=9]
Rule 87    expr -> expr > expr  [precedence=left, level=8]
Rule 88    expr -> expr GE expr  [precedence=left, level=8]
Rule 89    expr -> expr < expr  [precedence=left, level=8]
Rule 90    expr -> expr LE expr  [precedence=left, level=8]
Rule 91    expr -> expr NE expr  [precedence=left, level=7]
Rule 92    expr -> expr EQ expr  [precedence=left, level=7]
Rule 93    expr -> expr POINT IDENT = expr ;
Rule 94    expr -> expr POINT IDENT ;
Rule 95    expr -> SUPER POINT IDENT ;
Rule 96    expr -> THIS
Rule 97    expr -> IDENT [ expr ] = expr  [precedence=right, level=4]
Rule 98    expr -> IDENT = expr  [precedence=right, level=4]
Rule 99    args -> empty
Rule 100   args -> arg_list
Rule 101   arg_list -> expr
Rule 102   arg_list -> arg_list , expr
Rule 103   printf_stmt -> PRINTF ( STRING , arg_list ) ;
Rule 104   printf_stmt -> PRINTF ( STRING ) ;
Rule 105   scanf_stmt -> SCANF ( STRING , arg_list ) ;
Rule 106   sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ;
Rule 107   empty -> <empty>

Terminals, with rules where they appear:

!                    : 79
%                    : 82
(                    : 12 21 51 52 53 54 73 76 103 104 105 106
)                    : 12 21 51 52 53 54 73 76 103 104 105 106
*                    : 84
+                    : 77 86
,                    : 27 102 103 105 106 106
-                    : 78 85
.                    : 72
/                    : 83
;                    : 7 15 16 35 36 49 50 52 52 55 56 57 58 59 60 61 62 63 64 65 66 72 93 94 95 103 104 105 106
<                    : 89
=                    : 93 97 98
>                    : 87
AND                  : 80
BOOL                 : 19
BOOL_LIT             : 71
BREAK                : 58
CLASS                : 7
CONTINUE             : 57
DIVEQ                : 59
ELSE                 : 53
EQ                   : 92
FLOAT                : 17
FLOAT_LIT            : 69
FOR                  : 52
GE                   : 88
IDENT                : 7 12 15 16 21 28 29 35 36 72 73 74 75 93 94 95 97 98 106
IF                   : 53 54
INT                  : 18
INT_LIT              : 70
LE                   : 90
MINUSEQ              : 61
MINUSMINUS           : 63 65
MULEQ                : 60
NE                   : 91
NEW                  : 67
OR                   : 81
PLUSEQ               : 62
PLUSPLUS             : 64 66
POINT                : 93 94 95
PRINTF               : 103 104
RETURN               : 55 56
SCANF                : 105
SIZE                 : 72
SPRINTF              : 106
STRING               : 68 103 104 105 106
SUPER                : 95
THIS                 : 96
VOID                 : 20 24
WHILE                : 51
[                    : 15 28 35 67 74 97
]                    : 15 28 35 67 74 97
error                : 
{                    : 7 30
}                    : 7 30

Nonterminals, with rules where they appear:

_1_params_optional   : 12
_2_params_optional   : 21
arg_list             : 100 102 103 105 106
args                 : 73
break_stmt           : 43
class_body           : 7
class_decl           : 4
class_member         : 10 11
class_member_list    : 9 11
compound_stmt        : 12 21 47
decl                 : 2 3
decl_list            : 1 3
empty                : 8 31 99
expr                 : 50 51 52 52 52 53 54 55 59 59 60 60 61 61 62 62 63 64 65 66 67 74 76 77 78 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 97 97 98 101 102
expr_stmt            : 48
for_stmt             : 42
func_decl            : 5
if_stmt              : 46
local_decl           : 33 34
local_decl_list      : 32 34
local_decls          : 30
param                : 26 27
param_list           : 25 27
params               : 13 22
printf_stmt          : 41
program              : 0
return_stmt          : 44
scanf_stmt           : 40
sprintf_stmt         : 39
stmt                 : 37 38 51 52 53 53 54
stmt_list            : 30 38
type_spec            : 12 15 16 21 28 29 35 36 67
var_decl             : 6
while_stmt           : 45


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (21) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (15) var_decl -> . type_spec IDENT [ ] ;
    (16) var_decl -> . type_spec IDENT ;
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (7) class_decl -> . CLASS IDENT { class_body } ;
    (21) func_decl -> . type_spec IDENT ( _2_params_optional ) compound_stmt
    (15) var_decl -> . type_spec IDENT [ ] ;
    (16) var_decl -> . type_spec IDENT ;
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    FLOAT           reduce using rule 4 (decl -> class_decl .)
    INT             reduce using rule 4 (decl -> class_decl .)
    BOOL            reduce using rule 4 (decl -> class_decl .)
    VOID            reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) class_decl -> CLASS . IDENT { class_body } ;
    IDENT           shift and go to state 14


state 8

    (21) func_decl -> type_spec . IDENT ( _2_params_optional ) compound_stmt
    (15) var_decl -> type_spec . IDENT [ ] ;
    (16) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 15


state 9

    (17) type_spec -> FLOAT .
    IDENT           reduce using rule 17 (type_spec -> FLOAT .)
    [               reduce using rule 17 (type_spec -> FLOAT .)


state 10

    (18) type_spec -> INT .
    IDENT           reduce using rule 18 (type_spec -> INT .)
    [               reduce using rule 18 (type_spec -> INT .)


state 11

    (19) type_spec -> BOOL .
    IDENT           reduce using rule 19 (type_spec -> BOOL .)
    [               reduce using rule 19 (type_spec -> BOOL .)


state 12

    (20) type_spec -> VOID .
    IDENT           reduce using rule 20 (type_spec -> VOID .)
    [               reduce using rule 20 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (7) class_decl -> CLASS IDENT . { class_body } ;
    {               shift and go to state 16


state 15

    (21) func_decl -> type_spec IDENT . ( _2_params_optional ) compound_stmt
    (15) var_decl -> type_spec IDENT . [ ] ;
    (16) var_decl -> type_spec IDENT . ;
    (               shift and go to state 17
    [               shift and go to state 18
    ;               shift and go to state 19


state 16

    (7) class_decl -> CLASS IDENT { . class_body } ;
    (8) class_body -> . empty
    (9) class_body -> . class_member_list
    (107) empty -> .
    (10) class_member_list -> . class_member
    (11) class_member_list -> . class_member_list class_member
    (12) class_member -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    }               reduce using rule 107 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_body                     shift and go to state 20
    empty                          shift and go to state 21
    class_member_list              shift and go to state 22
    class_member                   shift and go to state 23
    type_spec                      shift and go to state 24

state 17

    (21) func_decl -> type_spec IDENT ( . _2_params_optional ) compound_stmt
    (22) _2_params_optional -> . params
    (23) _2_params_optional -> .
    (24) params -> . VOID
    (25) params -> . param_list
    (26) param_list -> . param
    (27) param_list -> . param_list , param
    (28) param -> . type_spec IDENT [ ]
    (29) param -> . type_spec IDENT
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    )               reduce using rule 23 (_2_params_optional -> .)
    VOID            shift and go to state 28
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 25
    _2_params_optional             shift and go to state 26
    params                         shift and go to state 27
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 18

    (15) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 31


state 19

    (16) var_decl -> type_spec IDENT ; .
    CLASS           reduce using rule 16 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 16 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 16 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 16 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 16 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 16 (var_decl -> type_spec IDENT ; .)


state 20

    (7) class_decl -> CLASS IDENT { class_body . } ;
    }               shift and go to state 32


state 21

    (8) class_body -> empty .
    }               reduce using rule 8 (class_body -> empty .)


state 22

    (9) class_body -> class_member_list .
    (11) class_member_list -> class_member_list . class_member
    (12) class_member -> . type_spec IDENT ( _1_params_optional ) compound_stmt
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    }               reduce using rule 9 (class_body -> class_member_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    class_member                   shift and go to state 33
    type_spec                      shift and go to state 24

state 23

    (10) class_member_list -> class_member .
    FLOAT           reduce using rule 10 (class_member_list -> class_member .)
    INT             reduce using rule 10 (class_member_list -> class_member .)
    BOOL            reduce using rule 10 (class_member_list -> class_member .)
    VOID            reduce using rule 10 (class_member_list -> class_member .)
    }               reduce using rule 10 (class_member_list -> class_member .)


state 24

    (12) class_member -> type_spec . IDENT ( _1_params_optional ) compound_stmt
    IDENT           shift and go to state 34


state 25

    (28) param -> type_spec . IDENT [ ]
    (29) param -> type_spec . IDENT
    IDENT           shift and go to state 35


state 26

    (21) func_decl -> type_spec IDENT ( _2_params_optional . ) compound_stmt
    )               shift and go to state 36


state 27

    (22) _2_params_optional -> params .
    )               reduce using rule 22 (_2_params_optional -> params .)


state 28

    (24) params -> VOID .
    (20) type_spec -> VOID .
    )               reduce using rule 24 (params -> VOID .)
    IDENT           reduce using rule 20 (type_spec -> VOID .)


state 29

    (25) params -> param_list .
    (27) param_list -> param_list . , param
    )               reduce using rule 25 (params -> param_list .)
    ,               shift and go to state 37


state 30

    (26) param_list -> param .
    ,               reduce using rule 26 (param_list -> param .)
    )               reduce using rule 26 (param_list -> param .)


state 31

    (15) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 38


state 32

    (7) class_decl -> CLASS IDENT { class_body } . ;
    ;               shift and go to state 39


state 33

    (11) class_member_list -> class_member_list class_member .
    FLOAT           reduce using rule 11 (class_member_list -> class_member_list class_member .)
    INT             reduce using rule 11 (class_member_list -> class_member_list class_member .)
    BOOL            reduce using rule 11 (class_member_list -> class_member_list class_member .)
    VOID            reduce using rule 11 (class_member_list -> class_member_list class_member .)
    }               reduce using rule 11 (class_member_list -> class_member_list class_member .)


state 34

    (12) class_member -> type_spec IDENT . ( _1_params_optional ) compound_stmt
    (               shift and go to state 40


state 35

    (28) param -> type_spec IDENT . [ ]
    (29) param -> type_spec IDENT .
    [               shift and go to state 41
    ,               reduce using rule 29 (param -> type_spec IDENT .)
    )               reduce using rule 29 (param -> type_spec IDENT .)


state 36

    (21) func_decl -> type_spec IDENT ( _2_params_optional ) . compound_stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 43

    compound_stmt                  shift and go to state 42

state 37

    (27) param_list -> param_list , . param
    (28) param -> . type_spec IDENT [ ]
    (29) param -> . type_spec IDENT
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 44
    type_spec                      shift and go to state 25

state 38

    (15) var_decl -> type_spec IDENT [ ] ; .
    CLASS           reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 15 (var_decl -> type_spec IDENT [ ] ; .)


state 39

    (7) class_decl -> CLASS IDENT { class_body } ; .
    CLASS           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    FLOAT           reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    INT             reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    BOOL            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    VOID            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)
    $end            reduce using rule 7 (class_decl -> CLASS IDENT { class_body } ; .)


state 40

    (12) class_member -> type_spec IDENT ( . _1_params_optional ) compound_stmt
    (13) _1_params_optional -> . params
    (14) _1_params_optional -> .
    (24) params -> . VOID
    (25) params -> . param_list
    (26) param_list -> . param
    (27) param_list -> . param_list , param
    (28) param -> . type_spec IDENT [ ]
    (29) param -> . type_spec IDENT
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    )               reduce using rule 14 (_1_params_optional -> .)
    VOID            shift and go to state 28
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 25
    _1_params_optional             shift and go to state 45
    params                         shift and go to state 46
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 41

    (28) param -> type_spec IDENT [ . ]
    ]               shift and go to state 47


state 42

    (21) func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .
    CLASS           reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    FLOAT           reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    INT             reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    BOOL            reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    VOID            reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)
    $end            reduce using rule 21 (func_decl -> type_spec IDENT ( _2_params_optional ) compound_stmt .)


state 43

    (30) compound_stmt -> { . local_decls stmt_list }
    (31) local_decls -> . empty
    (32) local_decls -> . local_decl_list
    (107) empty -> .
    (33) local_decl_list -> . local_decl
    (34) local_decl_list -> . local_decl_list local_decl
    (35) local_decl -> . type_spec IDENT [ ] ;
    (36) local_decl -> . type_spec IDENT ;
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    SPRINTF         reduce using rule 107 (empty -> .)
    SCANF           reduce using rule 107 (empty -> .)
    PRINTF          reduce using rule 107 (empty -> .)
    FOR             reduce using rule 107 (empty -> .)
    CONTINUE        reduce using rule 107 (empty -> .)
    BREAK           reduce using rule 107 (empty -> .)
    RETURN          reduce using rule 107 (empty -> .)
    WHILE           reduce using rule 107 (empty -> .)
    IF              reduce using rule 107 (empty -> .)
    {               reduce using rule 107 (empty -> .)
    ;               reduce using rule 107 (empty -> .)
    MINUSMINUS      reduce using rule 107 (empty -> .)
    PLUSPLUS        reduce using rule 107 (empty -> .)
    NEW             reduce using rule 107 (empty -> .)
    STRING          reduce using rule 107 (empty -> .)
    FLOAT_LIT       reduce using rule 107 (empty -> .)
    INT_LIT         reduce using rule 107 (empty -> .)
    BOOL_LIT        reduce using rule 107 (empty -> .)
    IDENT           reduce using rule 107 (empty -> .)
    (               reduce using rule 107 (empty -> .)
    +               reduce using rule 107 (empty -> .)
    -               reduce using rule 107 (empty -> .)
    !               reduce using rule 107 (empty -> .)
    SUPER           reduce using rule 107 (empty -> .)
    THIS            reduce using rule 107 (empty -> .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 48
    empty                          shift and go to state 49
    local_decl_list                shift and go to state 50
    local_decl                     shift and go to state 51
    type_spec                      shift and go to state 52

state 44

    (27) param_list -> param_list , param .
    ,               reduce using rule 27 (param_list -> param_list , param .)
    )               reduce using rule 27 (param_list -> param_list , param .)


state 45

    (12) class_member -> type_spec IDENT ( _1_params_optional . ) compound_stmt
    )               shift and go to state 53


state 46

    (13) _1_params_optional -> params .
    )               reduce using rule 13 (_1_params_optional -> params .)


state 47

    (28) param -> type_spec IDENT [ ] .
    ,               reduce using rule 28 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 28 (param -> type_spec IDENT [ ] .)


state 48

    (30) compound_stmt -> { local_decls . stmt_list }
    (37) stmt_list -> . stmt
    (38) stmt_list -> . stmt_list stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    stmt_list                      shift and go to state 54
    stmt                           shift and go to state 55
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65
    expr                           shift and go to state 74

state 49

    (31) local_decls -> empty .
    SPRINTF         reduce using rule 31 (local_decls -> empty .)
    SCANF           reduce using rule 31 (local_decls -> empty .)
    PRINTF          reduce using rule 31 (local_decls -> empty .)
    FOR             reduce using rule 31 (local_decls -> empty .)
    CONTINUE        reduce using rule 31 (local_decls -> empty .)
    BREAK           reduce using rule 31 (local_decls -> empty .)
    RETURN          reduce using rule 31 (local_decls -> empty .)
    WHILE           reduce using rule 31 (local_decls -> empty .)
    IF              reduce using rule 31 (local_decls -> empty .)
    {               reduce using rule 31 (local_decls -> empty .)
    ;               reduce using rule 31 (local_decls -> empty .)
    MINUSMINUS      reduce using rule 31 (local_decls -> empty .)
    PLUSPLUS        reduce using rule 31 (local_decls -> empty .)
    NEW             reduce using rule 31 (local_decls -> empty .)
    STRING          reduce using rule 31 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 31 (local_decls -> empty .)
    INT_LIT         reduce using rule 31 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 31 (local_decls -> empty .)
    IDENT           reduce using rule 31 (local_decls -> empty .)
    (               reduce using rule 31 (local_decls -> empty .)
    +               reduce using rule 31 (local_decls -> empty .)
    -               reduce using rule 31 (local_decls -> empty .)
    !               reduce using rule 31 (local_decls -> empty .)
    SUPER           reduce using rule 31 (local_decls -> empty .)
    THIS            reduce using rule 31 (local_decls -> empty .)


state 50

    (32) local_decls -> local_decl_list .
    (34) local_decl_list -> local_decl_list . local_decl
    (35) local_decl -> . type_spec IDENT [ ] ;
    (36) local_decl -> . type_spec IDENT ;
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    SPRINTF         reduce using rule 32 (local_decls -> local_decl_list .)
    SCANF           reduce using rule 32 (local_decls -> local_decl_list .)
    PRINTF          reduce using rule 32 (local_decls -> local_decl_list .)
    FOR             reduce using rule 32 (local_decls -> local_decl_list .)
    CONTINUE        reduce using rule 32 (local_decls -> local_decl_list .)
    BREAK           reduce using rule 32 (local_decls -> local_decl_list .)
    RETURN          reduce using rule 32 (local_decls -> local_decl_list .)
    WHILE           reduce using rule 32 (local_decls -> local_decl_list .)
    IF              reduce using rule 32 (local_decls -> local_decl_list .)
    {               reduce using rule 32 (local_decls -> local_decl_list .)
    ;               reduce using rule 32 (local_decls -> local_decl_list .)
    MINUSMINUS      reduce using rule 32 (local_decls -> local_decl_list .)
    PLUSPLUS        reduce using rule 32 (local_decls -> local_decl_list .)
    NEW             reduce using rule 32 (local_decls -> local_decl_list .)
    STRING          reduce using rule 32 (local_decls -> local_decl_list .)
    FLOAT_LIT       reduce using rule 32 (local_decls -> local_decl_list .)
    INT_LIT         reduce using rule 32 (local_decls -> local_decl_list .)
    BOOL_LIT        reduce using rule 32 (local_decls -> local_decl_list .)
    IDENT           reduce using rule 32 (local_decls -> local_decl_list .)
    (               reduce using rule 32 (local_decls -> local_decl_list .)
    +               reduce using rule 32 (local_decls -> local_decl_list .)
    -               reduce using rule 32 (local_decls -> local_decl_list .)
    !               reduce using rule 32 (local_decls -> local_decl_list .)
    SUPER           reduce using rule 32 (local_decls -> local_decl_list .)
    THIS            reduce using rule 32 (local_decls -> local_decl_list .)
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decl                     shift and go to state 91
    type_spec                      shift and go to state 52

state 51

    (33) local_decl_list -> local_decl .
    FLOAT           reduce using rule 33 (local_decl_list -> local_decl .)
    INT             reduce using rule 33 (local_decl_list -> local_decl .)
    BOOL            reduce using rule 33 (local_decl_list -> local_decl .)
    VOID            reduce using rule 33 (local_decl_list -> local_decl .)
    SPRINTF         reduce using rule 33 (local_decl_list -> local_decl .)
    SCANF           reduce using rule 33 (local_decl_list -> local_decl .)
    PRINTF          reduce using rule 33 (local_decl_list -> local_decl .)
    FOR             reduce using rule 33 (local_decl_list -> local_decl .)
    CONTINUE        reduce using rule 33 (local_decl_list -> local_decl .)
    BREAK           reduce using rule 33 (local_decl_list -> local_decl .)
    RETURN          reduce using rule 33 (local_decl_list -> local_decl .)
    WHILE           reduce using rule 33 (local_decl_list -> local_decl .)
    IF              reduce using rule 33 (local_decl_list -> local_decl .)
    {               reduce using rule 33 (local_decl_list -> local_decl .)
    ;               reduce using rule 33 (local_decl_list -> local_decl .)
    MINUSMINUS      reduce using rule 33 (local_decl_list -> local_decl .)
    PLUSPLUS        reduce using rule 33 (local_decl_list -> local_decl .)
    NEW             reduce using rule 33 (local_decl_list -> local_decl .)
    STRING          reduce using rule 33 (local_decl_list -> local_decl .)
    FLOAT_LIT       reduce using rule 33 (local_decl_list -> local_decl .)
    INT_LIT         reduce using rule 33 (local_decl_list -> local_decl .)
    BOOL_LIT        reduce using rule 33 (local_decl_list -> local_decl .)
    IDENT           reduce using rule 33 (local_decl_list -> local_decl .)
    (               reduce using rule 33 (local_decl_list -> local_decl .)
    +               reduce using rule 33 (local_decl_list -> local_decl .)
    -               reduce using rule 33 (local_decl_list -> local_decl .)
    !               reduce using rule 33 (local_decl_list -> local_decl .)
    SUPER           reduce using rule 33 (local_decl_list -> local_decl .)
    THIS            reduce using rule 33 (local_decl_list -> local_decl .)


state 52

    (35) local_decl -> type_spec . IDENT [ ] ;
    (36) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 92


state 53

    (12) class_member -> type_spec IDENT ( _1_params_optional ) . compound_stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 43

    compound_stmt                  shift and go to state 93

state 54

    (30) compound_stmt -> { local_decls stmt_list . }
    (38) stmt_list -> stmt_list . stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    }               shift and go to state 94
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    stmt                           shift and go to state 95
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65
    expr                           shift and go to state 74

state 55

    (37) stmt_list -> stmt .
    }               reduce using rule 37 (stmt_list -> stmt .)
    SPRINTF         reduce using rule 37 (stmt_list -> stmt .)
    SCANF           reduce using rule 37 (stmt_list -> stmt .)
    PRINTF          reduce using rule 37 (stmt_list -> stmt .)
    FOR             reduce using rule 37 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 37 (stmt_list -> stmt .)
    BREAK           reduce using rule 37 (stmt_list -> stmt .)
    RETURN          reduce using rule 37 (stmt_list -> stmt .)
    WHILE           reduce using rule 37 (stmt_list -> stmt .)
    IF              reduce using rule 37 (stmt_list -> stmt .)
    {               reduce using rule 37 (stmt_list -> stmt .)
    ;               reduce using rule 37 (stmt_list -> stmt .)
    MINUSMINUS      reduce using rule 37 (stmt_list -> stmt .)
    PLUSPLUS        reduce using rule 37 (stmt_list -> stmt .)
    NEW             reduce using rule 37 (stmt_list -> stmt .)
    STRING          reduce using rule 37 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 37 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 37 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 37 (stmt_list -> stmt .)
    IDENT           reduce using rule 37 (stmt_list -> stmt .)
    (               reduce using rule 37 (stmt_list -> stmt .)
    +               reduce using rule 37 (stmt_list -> stmt .)
    -               reduce using rule 37 (stmt_list -> stmt .)
    !               reduce using rule 37 (stmt_list -> stmt .)
    SUPER           reduce using rule 37 (stmt_list -> stmt .)
    THIS            reduce using rule 37 (stmt_list -> stmt .)


state 56

    (39) stmt -> sprintf_stmt .
    }               reduce using rule 39 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 39 (stmt -> sprintf_stmt .)
    SCANF           reduce using rule 39 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 39 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 39 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 39 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 39 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 39 (stmt -> sprintf_stmt .)
    IF              reduce using rule 39 (stmt -> sprintf_stmt .)
    {               reduce using rule 39 (stmt -> sprintf_stmt .)
    ;               reduce using rule 39 (stmt -> sprintf_stmt .)
    MINUSMINUS      reduce using rule 39 (stmt -> sprintf_stmt .)
    PLUSPLUS        reduce using rule 39 (stmt -> sprintf_stmt .)
    NEW             reduce using rule 39 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 39 (stmt -> sprintf_stmt .)
    FLOAT_LIT       reduce using rule 39 (stmt -> sprintf_stmt .)
    INT_LIT         reduce using rule 39 (stmt -> sprintf_stmt .)
    BOOL_LIT        reduce using rule 39 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 39 (stmt -> sprintf_stmt .)
    (               reduce using rule 39 (stmt -> sprintf_stmt .)
    +               reduce using rule 39 (stmt -> sprintf_stmt .)
    -               reduce using rule 39 (stmt -> sprintf_stmt .)
    !               reduce using rule 39 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 39 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 39 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 39 (stmt -> sprintf_stmt .)


state 57

    (40) stmt -> scanf_stmt .
    }               reduce using rule 40 (stmt -> scanf_stmt .)
    SPRINTF         reduce using rule 40 (stmt -> scanf_stmt .)
    SCANF           reduce using rule 40 (stmt -> scanf_stmt .)
    PRINTF          reduce using rule 40 (stmt -> scanf_stmt .)
    FOR             reduce using rule 40 (stmt -> scanf_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> scanf_stmt .)
    BREAK           reduce using rule 40 (stmt -> scanf_stmt .)
    RETURN          reduce using rule 40 (stmt -> scanf_stmt .)
    WHILE           reduce using rule 40 (stmt -> scanf_stmt .)
    IF              reduce using rule 40 (stmt -> scanf_stmt .)
    {               reduce using rule 40 (stmt -> scanf_stmt .)
    ;               reduce using rule 40 (stmt -> scanf_stmt .)
    MINUSMINUS      reduce using rule 40 (stmt -> scanf_stmt .)
    PLUSPLUS        reduce using rule 40 (stmt -> scanf_stmt .)
    NEW             reduce using rule 40 (stmt -> scanf_stmt .)
    STRING          reduce using rule 40 (stmt -> scanf_stmt .)
    FLOAT_LIT       reduce using rule 40 (stmt -> scanf_stmt .)
    INT_LIT         reduce using rule 40 (stmt -> scanf_stmt .)
    BOOL_LIT        reduce using rule 40 (stmt -> scanf_stmt .)
    IDENT           reduce using rule 40 (stmt -> scanf_stmt .)
    (               reduce using rule 40 (stmt -> scanf_stmt .)
    +               reduce using rule 40 (stmt -> scanf_stmt .)
    -               reduce using rule 40 (stmt -> scanf_stmt .)
    !               reduce using rule 40 (stmt -> scanf_stmt .)
    SUPER           reduce using rule 40 (stmt -> scanf_stmt .)
    THIS            reduce using rule 40 (stmt -> scanf_stmt .)
    ELSE            reduce using rule 40 (stmt -> scanf_stmt .)


state 58

    (41) stmt -> printf_stmt .
    }               reduce using rule 41 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 41 (stmt -> printf_stmt .)
    SCANF           reduce using rule 41 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 41 (stmt -> printf_stmt .)
    FOR             reduce using rule 41 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> printf_stmt .)
    BREAK           reduce using rule 41 (stmt -> printf_stmt .)
    RETURN          reduce using rule 41 (stmt -> printf_stmt .)
    WHILE           reduce using rule 41 (stmt -> printf_stmt .)
    IF              reduce using rule 41 (stmt -> printf_stmt .)
    {               reduce using rule 41 (stmt -> printf_stmt .)
    ;               reduce using rule 41 (stmt -> printf_stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> printf_stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> printf_stmt .)
    NEW             reduce using rule 41 (stmt -> printf_stmt .)
    STRING          reduce using rule 41 (stmt -> printf_stmt .)
    FLOAT_LIT       reduce using rule 41 (stmt -> printf_stmt .)
    INT_LIT         reduce using rule 41 (stmt -> printf_stmt .)
    BOOL_LIT        reduce using rule 41 (stmt -> printf_stmt .)
    IDENT           reduce using rule 41 (stmt -> printf_stmt .)
    (               reduce using rule 41 (stmt -> printf_stmt .)
    +               reduce using rule 41 (stmt -> printf_stmt .)
    -               reduce using rule 41 (stmt -> printf_stmt .)
    !               reduce using rule 41 (stmt -> printf_stmt .)
    SUPER           reduce using rule 41 (stmt -> printf_stmt .)
    THIS            reduce using rule 41 (stmt -> printf_stmt .)
    ELSE            reduce using rule 41 (stmt -> printf_stmt .)


state 59

    (42) stmt -> for_stmt .
    }               reduce using rule 42 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 42 (stmt -> for_stmt .)
    SCANF           reduce using rule 42 (stmt -> for_stmt .)
    PRINTF          reduce using rule 42 (stmt -> for_stmt .)
    FOR             reduce using rule 42 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> for_stmt .)
    BREAK           reduce using rule 42 (stmt -> for_stmt .)
    RETURN          reduce using rule 42 (stmt -> for_stmt .)
    WHILE           reduce using rule 42 (stmt -> for_stmt .)
    IF              reduce using rule 42 (stmt -> for_stmt .)
    {               reduce using rule 42 (stmt -> for_stmt .)
    ;               reduce using rule 42 (stmt -> for_stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> for_stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> for_stmt .)
    NEW             reduce using rule 42 (stmt -> for_stmt .)
    STRING          reduce using rule 42 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 42 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 42 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 42 (stmt -> for_stmt .)
    IDENT           reduce using rule 42 (stmt -> for_stmt .)
    (               reduce using rule 42 (stmt -> for_stmt .)
    +               reduce using rule 42 (stmt -> for_stmt .)
    -               reduce using rule 42 (stmt -> for_stmt .)
    !               reduce using rule 42 (stmt -> for_stmt .)
    SUPER           reduce using rule 42 (stmt -> for_stmt .)
    THIS            reduce using rule 42 (stmt -> for_stmt .)
    ELSE            reduce using rule 42 (stmt -> for_stmt .)


state 60

    (43) stmt -> break_stmt .
    }               reduce using rule 43 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 43 (stmt -> break_stmt .)
    SCANF           reduce using rule 43 (stmt -> break_stmt .)
    PRINTF          reduce using rule 43 (stmt -> break_stmt .)
    FOR             reduce using rule 43 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> break_stmt .)
    BREAK           reduce using rule 43 (stmt -> break_stmt .)
    RETURN          reduce using rule 43 (stmt -> break_stmt .)
    WHILE           reduce using rule 43 (stmt -> break_stmt .)
    IF              reduce using rule 43 (stmt -> break_stmt .)
    {               reduce using rule 43 (stmt -> break_stmt .)
    ;               reduce using rule 43 (stmt -> break_stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> break_stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> break_stmt .)
    NEW             reduce using rule 43 (stmt -> break_stmt .)
    STRING          reduce using rule 43 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 43 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 43 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 43 (stmt -> break_stmt .)
    IDENT           reduce using rule 43 (stmt -> break_stmt .)
    (               reduce using rule 43 (stmt -> break_stmt .)
    +               reduce using rule 43 (stmt -> break_stmt .)
    -               reduce using rule 43 (stmt -> break_stmt .)
    !               reduce using rule 43 (stmt -> break_stmt .)
    SUPER           reduce using rule 43 (stmt -> break_stmt .)
    THIS            reduce using rule 43 (stmt -> break_stmt .)
    ELSE            reduce using rule 43 (stmt -> break_stmt .)


state 61

    (44) stmt -> return_stmt .
    }               reduce using rule 44 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 44 (stmt -> return_stmt .)
    SCANF           reduce using rule 44 (stmt -> return_stmt .)
    PRINTF          reduce using rule 44 (stmt -> return_stmt .)
    FOR             reduce using rule 44 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 44 (stmt -> return_stmt .)
    BREAK           reduce using rule 44 (stmt -> return_stmt .)
    RETURN          reduce using rule 44 (stmt -> return_stmt .)
    WHILE           reduce using rule 44 (stmt -> return_stmt .)
    IF              reduce using rule 44 (stmt -> return_stmt .)
    {               reduce using rule 44 (stmt -> return_stmt .)
    ;               reduce using rule 44 (stmt -> return_stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> return_stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> return_stmt .)
    NEW             reduce using rule 44 (stmt -> return_stmt .)
    STRING          reduce using rule 44 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 44 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 44 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 44 (stmt -> return_stmt .)
    IDENT           reduce using rule 44 (stmt -> return_stmt .)
    (               reduce using rule 44 (stmt -> return_stmt .)
    +               reduce using rule 44 (stmt -> return_stmt .)
    -               reduce using rule 44 (stmt -> return_stmt .)
    !               reduce using rule 44 (stmt -> return_stmt .)
    SUPER           reduce using rule 44 (stmt -> return_stmt .)
    THIS            reduce using rule 44 (stmt -> return_stmt .)
    ELSE            reduce using rule 44 (stmt -> return_stmt .)


state 62

    (45) stmt -> while_stmt .
    }               reduce using rule 45 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 45 (stmt -> while_stmt .)
    SCANF           reduce using rule 45 (stmt -> while_stmt .)
    PRINTF          reduce using rule 45 (stmt -> while_stmt .)
    FOR             reduce using rule 45 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> while_stmt .)
    BREAK           reduce using rule 45 (stmt -> while_stmt .)
    RETURN          reduce using rule 45 (stmt -> while_stmt .)
    WHILE           reduce using rule 45 (stmt -> while_stmt .)
    IF              reduce using rule 45 (stmt -> while_stmt .)
    {               reduce using rule 45 (stmt -> while_stmt .)
    ;               reduce using rule 45 (stmt -> while_stmt .)
    MINUSMINUS      reduce using rule 45 (stmt -> while_stmt .)
    PLUSPLUS        reduce using rule 45 (stmt -> while_stmt .)
    NEW             reduce using rule 45 (stmt -> while_stmt .)
    STRING          reduce using rule 45 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 45 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 45 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 45 (stmt -> while_stmt .)
    IDENT           reduce using rule 45 (stmt -> while_stmt .)
    (               reduce using rule 45 (stmt -> while_stmt .)
    +               reduce using rule 45 (stmt -> while_stmt .)
    -               reduce using rule 45 (stmt -> while_stmt .)
    !               reduce using rule 45 (stmt -> while_stmt .)
    SUPER           reduce using rule 45 (stmt -> while_stmt .)
    THIS            reduce using rule 45 (stmt -> while_stmt .)
    ELSE            reduce using rule 45 (stmt -> while_stmt .)


state 63

    (46) stmt -> if_stmt .
    }               reduce using rule 46 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 46 (stmt -> if_stmt .)
    SCANF           reduce using rule 46 (stmt -> if_stmt .)
    PRINTF          reduce using rule 46 (stmt -> if_stmt .)
    FOR             reduce using rule 46 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 46 (stmt -> if_stmt .)
    BREAK           reduce using rule 46 (stmt -> if_stmt .)
    RETURN          reduce using rule 46 (stmt -> if_stmt .)
    WHILE           reduce using rule 46 (stmt -> if_stmt .)
    IF              reduce using rule 46 (stmt -> if_stmt .)
    {               reduce using rule 46 (stmt -> if_stmt .)
    ;               reduce using rule 46 (stmt -> if_stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> if_stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> if_stmt .)
    NEW             reduce using rule 46 (stmt -> if_stmt .)
    STRING          reduce using rule 46 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 46 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 46 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 46 (stmt -> if_stmt .)
    IDENT           reduce using rule 46 (stmt -> if_stmt .)
    (               reduce using rule 46 (stmt -> if_stmt .)
    +               reduce using rule 46 (stmt -> if_stmt .)
    -               reduce using rule 46 (stmt -> if_stmt .)
    !               reduce using rule 46 (stmt -> if_stmt .)
    SUPER           reduce using rule 46 (stmt -> if_stmt .)
    THIS            reduce using rule 46 (stmt -> if_stmt .)
    ELSE            reduce using rule 46 (stmt -> if_stmt .)


state 64

    (47) stmt -> compound_stmt .
    }               reduce using rule 47 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 47 (stmt -> compound_stmt .)
    SCANF           reduce using rule 47 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 47 (stmt -> compound_stmt .)
    FOR             reduce using rule 47 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 47 (stmt -> compound_stmt .)
    BREAK           reduce using rule 47 (stmt -> compound_stmt .)
    RETURN          reduce using rule 47 (stmt -> compound_stmt .)
    WHILE           reduce using rule 47 (stmt -> compound_stmt .)
    IF              reduce using rule 47 (stmt -> compound_stmt .)
    {               reduce using rule 47 (stmt -> compound_stmt .)
    ;               reduce using rule 47 (stmt -> compound_stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> compound_stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> compound_stmt .)
    NEW             reduce using rule 47 (stmt -> compound_stmt .)
    STRING          reduce using rule 47 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 47 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 47 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 47 (stmt -> compound_stmt .)
    IDENT           reduce using rule 47 (stmt -> compound_stmt .)
    (               reduce using rule 47 (stmt -> compound_stmt .)
    +               reduce using rule 47 (stmt -> compound_stmt .)
    -               reduce using rule 47 (stmt -> compound_stmt .)
    !               reduce using rule 47 (stmt -> compound_stmt .)
    SUPER           reduce using rule 47 (stmt -> compound_stmt .)
    THIS            reduce using rule 47 (stmt -> compound_stmt .)
    ELSE            reduce using rule 47 (stmt -> compound_stmt .)


state 65

    (48) stmt -> expr_stmt .
    }               reduce using rule 48 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 48 (stmt -> expr_stmt .)
    SCANF           reduce using rule 48 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 48 (stmt -> expr_stmt .)
    FOR             reduce using rule 48 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 48 (stmt -> expr_stmt .)
    BREAK           reduce using rule 48 (stmt -> expr_stmt .)
    RETURN          reduce using rule 48 (stmt -> expr_stmt .)
    WHILE           reduce using rule 48 (stmt -> expr_stmt .)
    IF              reduce using rule 48 (stmt -> expr_stmt .)
    {               reduce using rule 48 (stmt -> expr_stmt .)
    ;               reduce using rule 48 (stmt -> expr_stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> expr_stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> expr_stmt .)
    NEW             reduce using rule 48 (stmt -> expr_stmt .)
    STRING          reduce using rule 48 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 48 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 48 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 48 (stmt -> expr_stmt .)
    IDENT           reduce using rule 48 (stmt -> expr_stmt .)
    (               reduce using rule 48 (stmt -> expr_stmt .)
    +               reduce using rule 48 (stmt -> expr_stmt .)
    -               reduce using rule 48 (stmt -> expr_stmt .)
    !               reduce using rule 48 (stmt -> expr_stmt .)
    SUPER           reduce using rule 48 (stmt -> expr_stmt .)
    THIS            reduce using rule 48 (stmt -> expr_stmt .)
    ELSE            reduce using rule 48 (stmt -> expr_stmt .)


state 66

    (106) sprintf_stmt -> SPRINTF . ( IDENT , STRING , arg_list ) ;
    (               shift and go to state 96


state 67

    (76) expr -> ( . expr )
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 97

state 68

    (72) expr -> IDENT . . SIZE ;
    (73) expr -> IDENT . ( args )
    (74) expr -> IDENT . [ expr ]
    (75) expr -> IDENT .
    (97) expr -> IDENT . [ expr ] = expr
    (98) expr -> IDENT . = expr
    .               shift and go to state 98
    (               shift and go to state 99
    [               shift and go to state 100
    ;               reduce using rule 75 (expr -> IDENT .)
    DIVEQ           reduce using rule 75 (expr -> IDENT .)
    MULEQ           reduce using rule 75 (expr -> IDENT .)
    MINUSEQ         reduce using rule 75 (expr -> IDENT .)
    PLUSEQ          reduce using rule 75 (expr -> IDENT .)
    MINUSMINUS      reduce using rule 75 (expr -> IDENT .)
    PLUSPLUS        reduce using rule 75 (expr -> IDENT .)
    AND             reduce using rule 75 (expr -> IDENT .)
    OR              reduce using rule 75 (expr -> IDENT .)
    %               reduce using rule 75 (expr -> IDENT .)
    /               reduce using rule 75 (expr -> IDENT .)
    *               reduce using rule 75 (expr -> IDENT .)
    -               reduce using rule 75 (expr -> IDENT .)
    +               reduce using rule 75 (expr -> IDENT .)
    >               reduce using rule 75 (expr -> IDENT .)
    GE              reduce using rule 75 (expr -> IDENT .)
    <               reduce using rule 75 (expr -> IDENT .)
    LE              reduce using rule 75 (expr -> IDENT .)
    NE              reduce using rule 75 (expr -> IDENT .)
    EQ              reduce using rule 75 (expr -> IDENT .)
    POINT           reduce using rule 75 (expr -> IDENT .)
    )               reduce using rule 75 (expr -> IDENT .)
    ,               reduce using rule 75 (expr -> IDENT .)
    ]               reduce using rule 75 (expr -> IDENT .)
    =               shift and go to state 101


state 69

    (68) expr -> STRING .
    ;               reduce using rule 68 (expr -> STRING .)
    DIVEQ           reduce using rule 68 (expr -> STRING .)
    MULEQ           reduce using rule 68 (expr -> STRING .)
    MINUSEQ         reduce using rule 68 (expr -> STRING .)
    PLUSEQ          reduce using rule 68 (expr -> STRING .)
    MINUSMINUS      reduce using rule 68 (expr -> STRING .)
    PLUSPLUS        reduce using rule 68 (expr -> STRING .)
    AND             reduce using rule 68 (expr -> STRING .)
    OR              reduce using rule 68 (expr -> STRING .)
    %               reduce using rule 68 (expr -> STRING .)
    /               reduce using rule 68 (expr -> STRING .)
    *               reduce using rule 68 (expr -> STRING .)
    -               reduce using rule 68 (expr -> STRING .)
    +               reduce using rule 68 (expr -> STRING .)
    >               reduce using rule 68 (expr -> STRING .)
    GE              reduce using rule 68 (expr -> STRING .)
    <               reduce using rule 68 (expr -> STRING .)
    LE              reduce using rule 68 (expr -> STRING .)
    NE              reduce using rule 68 (expr -> STRING .)
    EQ              reduce using rule 68 (expr -> STRING .)
    POINT           reduce using rule 68 (expr -> STRING .)
    )               reduce using rule 68 (expr -> STRING .)
    ,               reduce using rule 68 (expr -> STRING .)
    ]               reduce using rule 68 (expr -> STRING .)


state 70

    (49) expr_stmt -> ; .
    }               reduce using rule 49 (expr_stmt -> ; .)
    SPRINTF         reduce using rule 49 (expr_stmt -> ; .)
    SCANF           reduce using rule 49 (expr_stmt -> ; .)
    PRINTF          reduce using rule 49 (expr_stmt -> ; .)
    FOR             reduce using rule 49 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 49 (expr_stmt -> ; .)
    BREAK           reduce using rule 49 (expr_stmt -> ; .)
    RETURN          reduce using rule 49 (expr_stmt -> ; .)
    WHILE           reduce using rule 49 (expr_stmt -> ; .)
    IF              reduce using rule 49 (expr_stmt -> ; .)
    {               reduce using rule 49 (expr_stmt -> ; .)
    ;               reduce using rule 49 (expr_stmt -> ; .)
    MINUSMINUS      reduce using rule 49 (expr_stmt -> ; .)
    PLUSPLUS        reduce using rule 49 (expr_stmt -> ; .)
    NEW             reduce using rule 49 (expr_stmt -> ; .)
    STRING          reduce using rule 49 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 49 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 49 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 49 (expr_stmt -> ; .)
    IDENT           reduce using rule 49 (expr_stmt -> ; .)
    (               reduce using rule 49 (expr_stmt -> ; .)
    +               reduce using rule 49 (expr_stmt -> ; .)
    -               reduce using rule 49 (expr_stmt -> ; .)
    !               reduce using rule 49 (expr_stmt -> ; .)
    SUPER           reduce using rule 49 (expr_stmt -> ; .)
    THIS            reduce using rule 49 (expr_stmt -> ; .)
    ELSE            reduce using rule 49 (expr_stmt -> ; .)


state 71

    (105) scanf_stmt -> SCANF . ( STRING , arg_list ) ;
    (               shift and go to state 102


state 72

    (103) printf_stmt -> PRINTF . ( STRING , arg_list ) ;
    (104) printf_stmt -> PRINTF . ( STRING ) ;
    (               shift and go to state 103


state 73

    (52) for_stmt -> FOR . ( expr ; expr ; expr ) stmt
    (               shift and go to state 104


state 74

    (50) expr_stmt -> expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 105
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 75

    (57) break_stmt -> CONTINUE . ;
    ;               shift and go to state 126


state 76

    (58) break_stmt -> BREAK . ;
    ;               shift and go to state 127


state 77

    (55) return_stmt -> RETURN . expr ;
    (56) return_stmt -> RETURN . ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    ;               shift and go to state 129
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 128

state 78

    (51) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 130


state 79

    (53) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (54) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 131


state 80

    (63) expr -> MINUSMINUS . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 132

state 81

    (64) expr -> PLUSPLUS . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 133

state 82

    (67) expr -> NEW . type_spec [ expr ]
    (17) type_spec -> . FLOAT
    (18) type_spec -> . INT
    (19) type_spec -> . BOOL
    (20) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 134

state 83

    (69) expr -> FLOAT_LIT .
    ;               reduce using rule 69 (expr -> FLOAT_LIT .)
    DIVEQ           reduce using rule 69 (expr -> FLOAT_LIT .)
    MULEQ           reduce using rule 69 (expr -> FLOAT_LIT .)
    MINUSEQ         reduce using rule 69 (expr -> FLOAT_LIT .)
    PLUSEQ          reduce using rule 69 (expr -> FLOAT_LIT .)
    MINUSMINUS      reduce using rule 69 (expr -> FLOAT_LIT .)
    PLUSPLUS        reduce using rule 69 (expr -> FLOAT_LIT .)
    AND             reduce using rule 69 (expr -> FLOAT_LIT .)
    OR              reduce using rule 69 (expr -> FLOAT_LIT .)
    %               reduce using rule 69 (expr -> FLOAT_LIT .)
    /               reduce using rule 69 (expr -> FLOAT_LIT .)
    *               reduce using rule 69 (expr -> FLOAT_LIT .)
    -               reduce using rule 69 (expr -> FLOAT_LIT .)
    +               reduce using rule 69 (expr -> FLOAT_LIT .)
    >               reduce using rule 69 (expr -> FLOAT_LIT .)
    GE              reduce using rule 69 (expr -> FLOAT_LIT .)
    <               reduce using rule 69 (expr -> FLOAT_LIT .)
    LE              reduce using rule 69 (expr -> FLOAT_LIT .)
    NE              reduce using rule 69 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 69 (expr -> FLOAT_LIT .)
    POINT           reduce using rule 69 (expr -> FLOAT_LIT .)
    )               reduce using rule 69 (expr -> FLOAT_LIT .)
    ,               reduce using rule 69 (expr -> FLOAT_LIT .)
    ]               reduce using rule 69 (expr -> FLOAT_LIT .)


state 84

    (70) expr -> INT_LIT .
    ;               reduce using rule 70 (expr -> INT_LIT .)
    DIVEQ           reduce using rule 70 (expr -> INT_LIT .)
    MULEQ           reduce using rule 70 (expr -> INT_LIT .)
    MINUSEQ         reduce using rule 70 (expr -> INT_LIT .)
    PLUSEQ          reduce using rule 70 (expr -> INT_LIT .)
    MINUSMINUS      reduce using rule 70 (expr -> INT_LIT .)
    PLUSPLUS        reduce using rule 70 (expr -> INT_LIT .)
    AND             reduce using rule 70 (expr -> INT_LIT .)
    OR              reduce using rule 70 (expr -> INT_LIT .)
    %               reduce using rule 70 (expr -> INT_LIT .)
    /               reduce using rule 70 (expr -> INT_LIT .)
    *               reduce using rule 70 (expr -> INT_LIT .)
    -               reduce using rule 70 (expr -> INT_LIT .)
    +               reduce using rule 70 (expr -> INT_LIT .)
    >               reduce using rule 70 (expr -> INT_LIT .)
    GE              reduce using rule 70 (expr -> INT_LIT .)
    <               reduce using rule 70 (expr -> INT_LIT .)
    LE              reduce using rule 70 (expr -> INT_LIT .)
    NE              reduce using rule 70 (expr -> INT_LIT .)
    EQ              reduce using rule 70 (expr -> INT_LIT .)
    POINT           reduce using rule 70 (expr -> INT_LIT .)
    )               reduce using rule 70 (expr -> INT_LIT .)
    ,               reduce using rule 70 (expr -> INT_LIT .)
    ]               reduce using rule 70 (expr -> INT_LIT .)


state 85

    (71) expr -> BOOL_LIT .
    ;               reduce using rule 71 (expr -> BOOL_LIT .)
    DIVEQ           reduce using rule 71 (expr -> BOOL_LIT .)
    MULEQ           reduce using rule 71 (expr -> BOOL_LIT .)
    MINUSEQ         reduce using rule 71 (expr -> BOOL_LIT .)
    PLUSEQ          reduce using rule 71 (expr -> BOOL_LIT .)
    MINUSMINUS      reduce using rule 71 (expr -> BOOL_LIT .)
    PLUSPLUS        reduce using rule 71 (expr -> BOOL_LIT .)
    AND             reduce using rule 71 (expr -> BOOL_LIT .)
    OR              reduce using rule 71 (expr -> BOOL_LIT .)
    %               reduce using rule 71 (expr -> BOOL_LIT .)
    /               reduce using rule 71 (expr -> BOOL_LIT .)
    *               reduce using rule 71 (expr -> BOOL_LIT .)
    -               reduce using rule 71 (expr -> BOOL_LIT .)
    +               reduce using rule 71 (expr -> BOOL_LIT .)
    >               reduce using rule 71 (expr -> BOOL_LIT .)
    GE              reduce using rule 71 (expr -> BOOL_LIT .)
    <               reduce using rule 71 (expr -> BOOL_LIT .)
    LE              reduce using rule 71 (expr -> BOOL_LIT .)
    NE              reduce using rule 71 (expr -> BOOL_LIT .)
    EQ              reduce using rule 71 (expr -> BOOL_LIT .)
    POINT           reduce using rule 71 (expr -> BOOL_LIT .)
    )               reduce using rule 71 (expr -> BOOL_LIT .)
    ,               reduce using rule 71 (expr -> BOOL_LIT .)
    ]               reduce using rule 71 (expr -> BOOL_LIT .)


state 86

    (77) expr -> + . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 135

state 87

    (78) expr -> - . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 136

state 88

    (79) expr -> ! . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 137

state 89

    (95) expr -> SUPER . POINT IDENT ;
    POINT           shift and go to state 138


state 90

    (96) expr -> THIS .
    ;               reduce using rule 96 (expr -> THIS .)
    DIVEQ           reduce using rule 96 (expr -> THIS .)
    MULEQ           reduce using rule 96 (expr -> THIS .)
    MINUSEQ         reduce using rule 96 (expr -> THIS .)
    PLUSEQ          reduce using rule 96 (expr -> THIS .)
    MINUSMINUS      reduce using rule 96 (expr -> THIS .)
    PLUSPLUS        reduce using rule 96 (expr -> THIS .)
    AND             reduce using rule 96 (expr -> THIS .)
    OR              reduce using rule 96 (expr -> THIS .)
    %               reduce using rule 96 (expr -> THIS .)
    /               reduce using rule 96 (expr -> THIS .)
    *               reduce using rule 96 (expr -> THIS .)
    -               reduce using rule 96 (expr -> THIS .)
    +               reduce using rule 96 (expr -> THIS .)
    >               reduce using rule 96 (expr -> THIS .)
    GE              reduce using rule 96 (expr -> THIS .)
    <               reduce using rule 96 (expr -> THIS .)
    LE              reduce using rule 96 (expr -> THIS .)
    NE              reduce using rule 96 (expr -> THIS .)
    EQ              reduce using rule 96 (expr -> THIS .)
    POINT           reduce using rule 96 (expr -> THIS .)
    )               reduce using rule 96 (expr -> THIS .)
    ,               reduce using rule 96 (expr -> THIS .)
    ]               reduce using rule 96 (expr -> THIS .)


state 91

    (34) local_decl_list -> local_decl_list local_decl .
    FLOAT           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    INT             reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    BOOL            reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    VOID            reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    SPRINTF         reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    SCANF           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    PRINTF          reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    FOR             reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    CONTINUE        reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    BREAK           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    RETURN          reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    WHILE           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    IF              reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    {               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    ;               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    MINUSMINUS      reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    PLUSPLUS        reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    NEW             reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    STRING          reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    FLOAT_LIT       reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    INT_LIT         reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    BOOL_LIT        reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    IDENT           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    (               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    +               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    -               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    !               reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    SUPER           reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)
    THIS            reduce using rule 34 (local_decl_list -> local_decl_list local_decl .)


state 92

    (35) local_decl -> type_spec IDENT . [ ] ;
    (36) local_decl -> type_spec IDENT . ;
    [               shift and go to state 139
    ;               shift and go to state 140


state 93

    (12) class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .
    FLOAT           reduce using rule 12 (class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    INT             reduce using rule 12 (class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    BOOL            reduce using rule 12 (class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    VOID            reduce using rule 12 (class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .)
    }               reduce using rule 12 (class_member -> type_spec IDENT ( _1_params_optional ) compound_stmt .)


state 94

    (30) compound_stmt -> { local_decls stmt_list } .
    CLASS           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    SCANF           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    MINUSMINUS      reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    PLUSPLUS        reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 30 (compound_stmt -> { local_decls stmt_list } .)


state 95

    (38) stmt_list -> stmt_list stmt .
    }               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    SPRINTF         reduce using rule 38 (stmt_list -> stmt_list stmt .)
    SCANF           reduce using rule 38 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 38 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 38 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 38 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 38 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 38 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 38 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 38 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    MINUSMINUS      reduce using rule 38 (stmt_list -> stmt_list stmt .)
    PLUSPLUS        reduce using rule 38 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 38 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 38 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 38 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 38 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 38 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 38 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 38 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 38 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 38 (stmt_list -> stmt_list stmt .)


state 96

    (106) sprintf_stmt -> SPRINTF ( . IDENT , STRING , arg_list ) ;
    IDENT           shift and go to state 141


state 97

    (76) expr -> ( expr . )
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    )               shift and go to state 142
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 98

    (72) expr -> IDENT . . SIZE ;
    SIZE            shift and go to state 143


state 99

    (73) expr -> IDENT ( . args )
    (99) args -> . empty
    (100) args -> . arg_list
    (107) empty -> .
    (101) arg_list -> . expr
    (102) arg_list -> . arg_list , expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    )               reduce using rule 107 (empty -> .)
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    args                           shift and go to state 144
    empty                          shift and go to state 145
    arg_list                       shift and go to state 146
    expr                           shift and go to state 147

state 100

    (74) expr -> IDENT [ . expr ]
    (97) expr -> IDENT [ . expr ] = expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 148

state 101

    (98) expr -> IDENT = . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 149

state 102

    (105) scanf_stmt -> SCANF ( . STRING , arg_list ) ;
    STRING          shift and go to state 150


state 103

    (103) printf_stmt -> PRINTF ( . STRING , arg_list ) ;
    (104) printf_stmt -> PRINTF ( . STRING ) ;
    STRING          shift and go to state 151


state 104

    (52) for_stmt -> FOR ( . expr ; expr ; expr ) stmt
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 152

state 105

    (50) expr_stmt -> expr ; .
    }               reduce using rule 50 (expr_stmt -> expr ; .)
    SPRINTF         reduce using rule 50 (expr_stmt -> expr ; .)
    SCANF           reduce using rule 50 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 50 (expr_stmt -> expr ; .)
    FOR             reduce using rule 50 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 50 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 50 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 50 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 50 (expr_stmt -> expr ; .)
    IF              reduce using rule 50 (expr_stmt -> expr ; .)
    {               reduce using rule 50 (expr_stmt -> expr ; .)
    ;               reduce using rule 50 (expr_stmt -> expr ; .)
    MINUSMINUS      reduce using rule 50 (expr_stmt -> expr ; .)
    PLUSPLUS        reduce using rule 50 (expr_stmt -> expr ; .)
    NEW             reduce using rule 50 (expr_stmt -> expr ; .)
    STRING          reduce using rule 50 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 50 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 50 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 50 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 50 (expr_stmt -> expr ; .)
    (               reduce using rule 50 (expr_stmt -> expr ; .)
    +               reduce using rule 50 (expr_stmt -> expr ; .)
    -               reduce using rule 50 (expr_stmt -> expr ; .)
    !               reduce using rule 50 (expr_stmt -> expr ; .)
    SUPER           reduce using rule 50 (expr_stmt -> expr ; .)
    THIS            reduce using rule 50 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 50 (expr_stmt -> expr ; .)


state 106

    (59) expr -> expr DIVEQ . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 153

state 107

    (60) expr -> expr MULEQ . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 154

state 108

    (61) expr -> expr MINUSEQ . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 155

state 109

    (62) expr -> expr PLUSEQ . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 156

state 110

    (65) expr -> expr MINUSMINUS . ;
    ;               shift and go to state 157


state 111

    (66) expr -> expr PLUSPLUS . ;
    ;               shift and go to state 158


state 112

    (80) expr -> expr AND . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 159

state 113

    (81) expr -> expr OR . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 160

state 114

    (82) expr -> expr % . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 161

state 115

    (83) expr -> expr / . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 162

state 116

    (84) expr -> expr * . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 163

state 117

    (85) expr -> expr - . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 164

state 118

    (86) expr -> expr + . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 165

state 119

    (87) expr -> expr > . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 166

state 120

    (88) expr -> expr GE . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 167

state 121

    (89) expr -> expr < . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 168

state 122

    (90) expr -> expr LE . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 169

state 123

    (91) expr -> expr NE . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 170

state 124

    (92) expr -> expr EQ . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 171

state 125

    (93) expr -> expr POINT . IDENT = expr ;
    (94) expr -> expr POINT . IDENT ;
    IDENT           shift and go to state 172


state 126

    (57) break_stmt -> CONTINUE ; .
    }               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 57 (break_stmt -> CONTINUE ; .)
    SCANF           reduce using rule 57 (break_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 57 (break_stmt -> CONTINUE ; .)
    FOR             reduce using rule 57 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 57 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 57 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 57 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 57 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 57 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    MINUSMINUS      reduce using rule 57 (break_stmt -> CONTINUE ; .)
    PLUSPLUS        reduce using rule 57 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 57 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 57 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 57 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 57 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 57 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 57 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 57 (break_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 57 (break_stmt -> CONTINUE ; .)
    THIS            reduce using rule 57 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 57 (break_stmt -> CONTINUE ; .)


state 127

    (58) break_stmt -> BREAK ; .
    }               reduce using rule 58 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 58 (break_stmt -> BREAK ; .)
    SCANF           reduce using rule 58 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 58 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 58 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 58 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 58 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 58 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 58 (break_stmt -> BREAK ; .)
    IF              reduce using rule 58 (break_stmt -> BREAK ; .)
    {               reduce using rule 58 (break_stmt -> BREAK ; .)
    ;               reduce using rule 58 (break_stmt -> BREAK ; .)
    MINUSMINUS      reduce using rule 58 (break_stmt -> BREAK ; .)
    PLUSPLUS        reduce using rule 58 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 58 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 58 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 58 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 58 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 58 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 58 (break_stmt -> BREAK ; .)
    (               reduce using rule 58 (break_stmt -> BREAK ; .)
    +               reduce using rule 58 (break_stmt -> BREAK ; .)
    -               reduce using rule 58 (break_stmt -> BREAK ; .)
    !               reduce using rule 58 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 58 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 58 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 58 (break_stmt -> BREAK ; .)


state 128

    (55) return_stmt -> RETURN expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 173
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 129

    (56) return_stmt -> RETURN ; .
    }               reduce using rule 56 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 56 (return_stmt -> RETURN ; .)
    SCANF           reduce using rule 56 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 56 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 56 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 56 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 56 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 56 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 56 (return_stmt -> RETURN ; .)
    IF              reduce using rule 56 (return_stmt -> RETURN ; .)
    {               reduce using rule 56 (return_stmt -> RETURN ; .)
    ;               reduce using rule 56 (return_stmt -> RETURN ; .)
    MINUSMINUS      reduce using rule 56 (return_stmt -> RETURN ; .)
    PLUSPLUS        reduce using rule 56 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 56 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 56 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 56 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 56 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 56 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 56 (return_stmt -> RETURN ; .)
    (               reduce using rule 56 (return_stmt -> RETURN ; .)
    +               reduce using rule 56 (return_stmt -> RETURN ; .)
    -               reduce using rule 56 (return_stmt -> RETURN ; .)
    !               reduce using rule 56 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 56 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 56 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 56 (return_stmt -> RETURN ; .)


state 130

    (51) while_stmt -> WHILE ( . expr ) stmt
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 174

state 131

    (53) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (54) if_stmt -> IF ( . expr ) stmt
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 175

state 132

    (63) expr -> MINUSMINUS expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 176
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 133

    (64) expr -> PLUSPLUS expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 177
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 134

    (67) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 178


state 135

    (77) expr -> + expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 77 (expr -> + expr .)
    DIVEQ           reduce using rule 77 (expr -> + expr .)
    MULEQ           reduce using rule 77 (expr -> + expr .)
    MINUSEQ         reduce using rule 77 (expr -> + expr .)
    PLUSEQ          reduce using rule 77 (expr -> + expr .)
    MINUSMINUS      reduce using rule 77 (expr -> + expr .)
    PLUSPLUS        reduce using rule 77 (expr -> + expr .)
    AND             reduce using rule 77 (expr -> + expr .)
    OR              reduce using rule 77 (expr -> + expr .)
    %               reduce using rule 77 (expr -> + expr .)
    /               reduce using rule 77 (expr -> + expr .)
    *               reduce using rule 77 (expr -> + expr .)
    -               reduce using rule 77 (expr -> + expr .)
    +               reduce using rule 77 (expr -> + expr .)
    >               reduce using rule 77 (expr -> + expr .)
    GE              reduce using rule 77 (expr -> + expr .)
    <               reduce using rule 77 (expr -> + expr .)
    LE              reduce using rule 77 (expr -> + expr .)
    NE              reduce using rule 77 (expr -> + expr .)
    EQ              reduce using rule 77 (expr -> + expr .)
    POINT           reduce using rule 77 (expr -> + expr .)
    )               reduce using rule 77 (expr -> + expr .)
    ,               reduce using rule 77 (expr -> + expr .)
    ]               reduce using rule 77 (expr -> + expr .)


state 136

    (78) expr -> - expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 78 (expr -> - expr .)
    DIVEQ           reduce using rule 78 (expr -> - expr .)
    MULEQ           reduce using rule 78 (expr -> - expr .)
    MINUSEQ         reduce using rule 78 (expr -> - expr .)
    PLUSEQ          reduce using rule 78 (expr -> - expr .)
    MINUSMINUS      reduce using rule 78 (expr -> - expr .)
    PLUSPLUS        reduce using rule 78 (expr -> - expr .)
    AND             reduce using rule 78 (expr -> - expr .)
    OR              reduce using rule 78 (expr -> - expr .)
    %               reduce using rule 78 (expr -> - expr .)
    /               reduce using rule 78 (expr -> - expr .)
    *               reduce using rule 78 (expr -> - expr .)
    -               reduce using rule 78 (expr -> - expr .)
    +               reduce using rule 78 (expr -> - expr .)
    >               reduce using rule 78 (expr -> - expr .)
    GE              reduce using rule 78 (expr -> - expr .)
    <               reduce using rule 78 (expr -> - expr .)
    LE              reduce using rule 78 (expr -> - expr .)
    NE              reduce using rule 78 (expr -> - expr .)
    EQ              reduce using rule 78 (expr -> - expr .)
    POINT           reduce using rule 78 (expr -> - expr .)
    )               reduce using rule 78 (expr -> - expr .)
    ,               reduce using rule 78 (expr -> - expr .)
    ]               reduce using rule 78 (expr -> - expr .)


state 137

    (79) expr -> ! expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 79 (expr -> ! expr .)
    DIVEQ           reduce using rule 79 (expr -> ! expr .)
    MULEQ           reduce using rule 79 (expr -> ! expr .)
    MINUSEQ         reduce using rule 79 (expr -> ! expr .)
    PLUSEQ          reduce using rule 79 (expr -> ! expr .)
    MINUSMINUS      reduce using rule 79 (expr -> ! expr .)
    PLUSPLUS        reduce using rule 79 (expr -> ! expr .)
    AND             reduce using rule 79 (expr -> ! expr .)
    OR              reduce using rule 79 (expr -> ! expr .)
    %               reduce using rule 79 (expr -> ! expr .)
    /               reduce using rule 79 (expr -> ! expr .)
    *               reduce using rule 79 (expr -> ! expr .)
    -               reduce using rule 79 (expr -> ! expr .)
    +               reduce using rule 79 (expr -> ! expr .)
    >               reduce using rule 79 (expr -> ! expr .)
    GE              reduce using rule 79 (expr -> ! expr .)
    <               reduce using rule 79 (expr -> ! expr .)
    LE              reduce using rule 79 (expr -> ! expr .)
    NE              reduce using rule 79 (expr -> ! expr .)
    EQ              reduce using rule 79 (expr -> ! expr .)
    POINT           reduce using rule 79 (expr -> ! expr .)
    )               reduce using rule 79 (expr -> ! expr .)
    ,               reduce using rule 79 (expr -> ! expr .)
    ]               reduce using rule 79 (expr -> ! expr .)


state 138

    (95) expr -> SUPER POINT . IDENT ;
    IDENT           shift and go to state 179


state 139

    (35) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 180


state 140

    (36) local_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    SCANF           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    MINUSMINUS      reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    PLUSPLUS        reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 36 (local_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 36 (local_decl -> type_spec IDENT ; .)


state 141

    (106) sprintf_stmt -> SPRINTF ( IDENT . , STRING , arg_list ) ;
    ,               shift and go to state 181


state 142

    (76) expr -> ( expr ) .
    ;               reduce using rule 76 (expr -> ( expr ) .)
    DIVEQ           reduce using rule 76 (expr -> ( expr ) .)
    MULEQ           reduce using rule 76 (expr -> ( expr ) .)
    MINUSEQ         reduce using rule 76 (expr -> ( expr ) .)
    PLUSEQ          reduce using rule 76 (expr -> ( expr ) .)
    MINUSMINUS      reduce using rule 76 (expr -> ( expr ) .)
    PLUSPLUS        reduce using rule 76 (expr -> ( expr ) .)
    AND             reduce using rule 76 (expr -> ( expr ) .)
    OR              reduce using rule 76 (expr -> ( expr ) .)
    %               reduce using rule 76 (expr -> ( expr ) .)
    /               reduce using rule 76 (expr -> ( expr ) .)
    *               reduce using rule 76 (expr -> ( expr ) .)
    -               reduce using rule 76 (expr -> ( expr ) .)
    +               reduce using rule 76 (expr -> ( expr ) .)
    >               reduce using rule 76 (expr -> ( expr ) .)
    GE              reduce using rule 76 (expr -> ( expr ) .)
    <               reduce using rule 76 (expr -> ( expr ) .)
    LE              reduce using rule 76 (expr -> ( expr ) .)
    NE              reduce using rule 76 (expr -> ( expr ) .)
    EQ              reduce using rule 76 (expr -> ( expr ) .)
    POINT           reduce using rule 76 (expr -> ( expr ) .)
    )               reduce using rule 76 (expr -> ( expr ) .)
    ,               reduce using rule 76 (expr -> ( expr ) .)
    ]               reduce using rule 76 (expr -> ( expr ) .)


state 143

    (72) expr -> IDENT . SIZE . ;
    ;               shift and go to state 182


state 144

    (73) expr -> IDENT ( args . )
    )               shift and go to state 183


state 145

    (99) args -> empty .
    )               reduce using rule 99 (args -> empty .)


state 146

    (100) args -> arg_list .
    (102) arg_list -> arg_list . , expr
    )               reduce using rule 100 (args -> arg_list .)
    ,               shift and go to state 184


state 147

    (101) arg_list -> expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ,               reduce using rule 101 (arg_list -> expr .)
    )               reduce using rule 101 (arg_list -> expr .)
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 148

    (74) expr -> IDENT [ expr . ]
    (97) expr -> IDENT [ expr . ] = expr
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ]               shift and go to state 185
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 149

    (98) expr -> IDENT = expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 98 (expr -> IDENT = expr .)
    DIVEQ           reduce using rule 98 (expr -> IDENT = expr .)
    MULEQ           reduce using rule 98 (expr -> IDENT = expr .)
    MINUSEQ         reduce using rule 98 (expr -> IDENT = expr .)
    PLUSEQ          reduce using rule 98 (expr -> IDENT = expr .)
    MINUSMINUS      reduce using rule 98 (expr -> IDENT = expr .)
    PLUSPLUS        reduce using rule 98 (expr -> IDENT = expr .)
    POINT           reduce using rule 98 (expr -> IDENT = expr .)
    )               reduce using rule 98 (expr -> IDENT = expr .)
    ,               reduce using rule 98 (expr -> IDENT = expr .)
    ]               reduce using rule 98 (expr -> IDENT = expr .)
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124


state 150

    (105) scanf_stmt -> SCANF ( STRING . , arg_list ) ;
    ,               shift and go to state 186


state 151

    (103) printf_stmt -> PRINTF ( STRING . , arg_list ) ;
    (104) printf_stmt -> PRINTF ( STRING . ) ;
    ,               shift and go to state 187
    )               shift and go to state 188


state 152

    (52) for_stmt -> FOR ( expr . ; expr ; expr ) stmt
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 189
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 153

    (59) expr -> expr DIVEQ expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 190
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 154

    (60) expr -> expr MULEQ expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 191
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 155

    (61) expr -> expr MINUSEQ expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 192
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 156

    (62) expr -> expr PLUSEQ expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 193
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 157

    (65) expr -> expr MINUSMINUS ; .
    ;               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    DIVEQ           reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    MULEQ           reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    MINUSEQ         reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    PLUSEQ          reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    MINUSMINUS      reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    PLUSPLUS        reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    AND             reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    OR              reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    %               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    /               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    *               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    -               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    +               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    >               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    GE              reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    <               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    LE              reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    NE              reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    EQ              reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    POINT           reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    )               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    ,               reduce using rule 65 (expr -> expr MINUSMINUS ; .)
    ]               reduce using rule 65 (expr -> expr MINUSMINUS ; .)


state 158

    (66) expr -> expr PLUSPLUS ; .
    ;               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    DIVEQ           reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    MULEQ           reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    MINUSEQ         reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    PLUSEQ          reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    MINUSMINUS      reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    PLUSPLUS        reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    AND             reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    OR              reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    %               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    /               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    *               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    -               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    +               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    >               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    GE              reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    <               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    LE              reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    NE              reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    EQ              reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    POINT           reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    )               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    ,               reduce using rule 66 (expr -> expr PLUSPLUS ; .)
    ]               reduce using rule 66 (expr -> expr PLUSPLUS ; .)


state 159

    (80) expr -> expr AND expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 80 (expr -> expr AND expr .)
    DIVEQ           reduce using rule 80 (expr -> expr AND expr .)
    MULEQ           reduce using rule 80 (expr -> expr AND expr .)
    MINUSEQ         reduce using rule 80 (expr -> expr AND expr .)
    PLUSEQ          reduce using rule 80 (expr -> expr AND expr .)
    MINUSMINUS      reduce using rule 80 (expr -> expr AND expr .)
    PLUSPLUS        reduce using rule 80 (expr -> expr AND expr .)
    AND             reduce using rule 80 (expr -> expr AND expr .)
    OR              reduce using rule 80 (expr -> expr AND expr .)
    POINT           reduce using rule 80 (expr -> expr AND expr .)
    )               reduce using rule 80 (expr -> expr AND expr .)
    ,               reduce using rule 80 (expr -> expr AND expr .)
    ]               reduce using rule 80 (expr -> expr AND expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124


state 160

    (81) expr -> expr OR expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 81 (expr -> expr OR expr .)
    DIVEQ           reduce using rule 81 (expr -> expr OR expr .)
    MULEQ           reduce using rule 81 (expr -> expr OR expr .)
    MINUSEQ         reduce using rule 81 (expr -> expr OR expr .)
    PLUSEQ          reduce using rule 81 (expr -> expr OR expr .)
    MINUSMINUS      reduce using rule 81 (expr -> expr OR expr .)
    PLUSPLUS        reduce using rule 81 (expr -> expr OR expr .)
    OR              reduce using rule 81 (expr -> expr OR expr .)
    POINT           reduce using rule 81 (expr -> expr OR expr .)
    )               reduce using rule 81 (expr -> expr OR expr .)
    ,               reduce using rule 81 (expr -> expr OR expr .)
    ]               reduce using rule 81 (expr -> expr OR expr .)
    AND             shift and go to state 112
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124


state 161

    (82) expr -> expr % expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 82 (expr -> expr % expr .)
    DIVEQ           reduce using rule 82 (expr -> expr % expr .)
    MULEQ           reduce using rule 82 (expr -> expr % expr .)
    MINUSEQ         reduce using rule 82 (expr -> expr % expr .)
    PLUSEQ          reduce using rule 82 (expr -> expr % expr .)
    MINUSMINUS      reduce using rule 82 (expr -> expr % expr .)
    PLUSPLUS        reduce using rule 82 (expr -> expr % expr .)
    AND             reduce using rule 82 (expr -> expr % expr .)
    OR              reduce using rule 82 (expr -> expr % expr .)
    %               reduce using rule 82 (expr -> expr % expr .)
    /               reduce using rule 82 (expr -> expr % expr .)
    *               reduce using rule 82 (expr -> expr % expr .)
    -               reduce using rule 82 (expr -> expr % expr .)
    +               reduce using rule 82 (expr -> expr % expr .)
    >               reduce using rule 82 (expr -> expr % expr .)
    GE              reduce using rule 82 (expr -> expr % expr .)
    <               reduce using rule 82 (expr -> expr % expr .)
    LE              reduce using rule 82 (expr -> expr % expr .)
    NE              reduce using rule 82 (expr -> expr % expr .)
    EQ              reduce using rule 82 (expr -> expr % expr .)
    POINT           reduce using rule 82 (expr -> expr % expr .)
    )               reduce using rule 82 (expr -> expr % expr .)
    ,               reduce using rule 82 (expr -> expr % expr .)
    ]               reduce using rule 82 (expr -> expr % expr .)


state 162

    (83) expr -> expr / expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 83 (expr -> expr / expr .)
    DIVEQ           reduce using rule 83 (expr -> expr / expr .)
    MULEQ           reduce using rule 83 (expr -> expr / expr .)
    MINUSEQ         reduce using rule 83 (expr -> expr / expr .)
    PLUSEQ          reduce using rule 83 (expr -> expr / expr .)
    MINUSMINUS      reduce using rule 83 (expr -> expr / expr .)
    PLUSPLUS        reduce using rule 83 (expr -> expr / expr .)
    AND             reduce using rule 83 (expr -> expr / expr .)
    OR              reduce using rule 83 (expr -> expr / expr .)
    %               reduce using rule 83 (expr -> expr / expr .)
    /               reduce using rule 83 (expr -> expr / expr .)
    *               reduce using rule 83 (expr -> expr / expr .)
    -               reduce using rule 83 (expr -> expr / expr .)
    +               reduce using rule 83 (expr -> expr / expr .)
    >               reduce using rule 83 (expr -> expr / expr .)
    GE              reduce using rule 83 (expr -> expr / expr .)
    <               reduce using rule 83 (expr -> expr / expr .)
    LE              reduce using rule 83 (expr -> expr / expr .)
    NE              reduce using rule 83 (expr -> expr / expr .)
    EQ              reduce using rule 83 (expr -> expr / expr .)
    POINT           reduce using rule 83 (expr -> expr / expr .)
    )               reduce using rule 83 (expr -> expr / expr .)
    ,               reduce using rule 83 (expr -> expr / expr .)
    ]               reduce using rule 83 (expr -> expr / expr .)


state 163

    (84) expr -> expr * expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 84 (expr -> expr * expr .)
    DIVEQ           reduce using rule 84 (expr -> expr * expr .)
    MULEQ           reduce using rule 84 (expr -> expr * expr .)
    MINUSEQ         reduce using rule 84 (expr -> expr * expr .)
    PLUSEQ          reduce using rule 84 (expr -> expr * expr .)
    MINUSMINUS      reduce using rule 84 (expr -> expr * expr .)
    PLUSPLUS        reduce using rule 84 (expr -> expr * expr .)
    AND             reduce using rule 84 (expr -> expr * expr .)
    OR              reduce using rule 84 (expr -> expr * expr .)
    %               reduce using rule 84 (expr -> expr * expr .)
    /               reduce using rule 84 (expr -> expr * expr .)
    *               reduce using rule 84 (expr -> expr * expr .)
    -               reduce using rule 84 (expr -> expr * expr .)
    +               reduce using rule 84 (expr -> expr * expr .)
    >               reduce using rule 84 (expr -> expr * expr .)
    GE              reduce using rule 84 (expr -> expr * expr .)
    <               reduce using rule 84 (expr -> expr * expr .)
    LE              reduce using rule 84 (expr -> expr * expr .)
    NE              reduce using rule 84 (expr -> expr * expr .)
    EQ              reduce using rule 84 (expr -> expr * expr .)
    POINT           reduce using rule 84 (expr -> expr * expr .)
    )               reduce using rule 84 (expr -> expr * expr .)
    ,               reduce using rule 84 (expr -> expr * expr .)
    ]               reduce using rule 84 (expr -> expr * expr .)


state 164

    (85) expr -> expr - expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 85 (expr -> expr - expr .)
    DIVEQ           reduce using rule 85 (expr -> expr - expr .)
    MULEQ           reduce using rule 85 (expr -> expr - expr .)
    MINUSEQ         reduce using rule 85 (expr -> expr - expr .)
    PLUSEQ          reduce using rule 85 (expr -> expr - expr .)
    MINUSMINUS      reduce using rule 85 (expr -> expr - expr .)
    PLUSPLUS        reduce using rule 85 (expr -> expr - expr .)
    AND             reduce using rule 85 (expr -> expr - expr .)
    OR              reduce using rule 85 (expr -> expr - expr .)
    -               reduce using rule 85 (expr -> expr - expr .)
    +               reduce using rule 85 (expr -> expr - expr .)
    >               reduce using rule 85 (expr -> expr - expr .)
    GE              reduce using rule 85 (expr -> expr - expr .)
    <               reduce using rule 85 (expr -> expr - expr .)
    LE              reduce using rule 85 (expr -> expr - expr .)
    NE              reduce using rule 85 (expr -> expr - expr .)
    EQ              reduce using rule 85 (expr -> expr - expr .)
    POINT           reduce using rule 85 (expr -> expr - expr .)
    )               reduce using rule 85 (expr -> expr - expr .)
    ,               reduce using rule 85 (expr -> expr - expr .)
    ]               reduce using rule 85 (expr -> expr - expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116


state 165

    (86) expr -> expr + expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 86 (expr -> expr + expr .)
    DIVEQ           reduce using rule 86 (expr -> expr + expr .)
    MULEQ           reduce using rule 86 (expr -> expr + expr .)
    MINUSEQ         reduce using rule 86 (expr -> expr + expr .)
    PLUSEQ          reduce using rule 86 (expr -> expr + expr .)
    MINUSMINUS      reduce using rule 86 (expr -> expr + expr .)
    PLUSPLUS        reduce using rule 86 (expr -> expr + expr .)
    AND             reduce using rule 86 (expr -> expr + expr .)
    OR              reduce using rule 86 (expr -> expr + expr .)
    -               reduce using rule 86 (expr -> expr + expr .)
    +               reduce using rule 86 (expr -> expr + expr .)
    >               reduce using rule 86 (expr -> expr + expr .)
    GE              reduce using rule 86 (expr -> expr + expr .)
    <               reduce using rule 86 (expr -> expr + expr .)
    LE              reduce using rule 86 (expr -> expr + expr .)
    NE              reduce using rule 86 (expr -> expr + expr .)
    EQ              reduce using rule 86 (expr -> expr + expr .)
    POINT           reduce using rule 86 (expr -> expr + expr .)
    )               reduce using rule 86 (expr -> expr + expr .)
    ,               reduce using rule 86 (expr -> expr + expr .)
    ]               reduce using rule 86 (expr -> expr + expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116


state 166

    (87) expr -> expr > expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 87 (expr -> expr > expr .)
    DIVEQ           reduce using rule 87 (expr -> expr > expr .)
    MULEQ           reduce using rule 87 (expr -> expr > expr .)
    MINUSEQ         reduce using rule 87 (expr -> expr > expr .)
    PLUSEQ          reduce using rule 87 (expr -> expr > expr .)
    MINUSMINUS      reduce using rule 87 (expr -> expr > expr .)
    PLUSPLUS        reduce using rule 87 (expr -> expr > expr .)
    AND             reduce using rule 87 (expr -> expr > expr .)
    OR              reduce using rule 87 (expr -> expr > expr .)
    >               reduce using rule 87 (expr -> expr > expr .)
    GE              reduce using rule 87 (expr -> expr > expr .)
    <               reduce using rule 87 (expr -> expr > expr .)
    LE              reduce using rule 87 (expr -> expr > expr .)
    NE              reduce using rule 87 (expr -> expr > expr .)
    EQ              reduce using rule 87 (expr -> expr > expr .)
    POINT           reduce using rule 87 (expr -> expr > expr .)
    )               reduce using rule 87 (expr -> expr > expr .)
    ,               reduce using rule 87 (expr -> expr > expr .)
    ]               reduce using rule 87 (expr -> expr > expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118


state 167

    (88) expr -> expr GE expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 88 (expr -> expr GE expr .)
    DIVEQ           reduce using rule 88 (expr -> expr GE expr .)
    MULEQ           reduce using rule 88 (expr -> expr GE expr .)
    MINUSEQ         reduce using rule 88 (expr -> expr GE expr .)
    PLUSEQ          reduce using rule 88 (expr -> expr GE expr .)
    MINUSMINUS      reduce using rule 88 (expr -> expr GE expr .)
    PLUSPLUS        reduce using rule 88 (expr -> expr GE expr .)
    AND             reduce using rule 88 (expr -> expr GE expr .)
    OR              reduce using rule 88 (expr -> expr GE expr .)
    >               reduce using rule 88 (expr -> expr GE expr .)
    GE              reduce using rule 88 (expr -> expr GE expr .)
    <               reduce using rule 88 (expr -> expr GE expr .)
    LE              reduce using rule 88 (expr -> expr GE expr .)
    NE              reduce using rule 88 (expr -> expr GE expr .)
    EQ              reduce using rule 88 (expr -> expr GE expr .)
    POINT           reduce using rule 88 (expr -> expr GE expr .)
    )               reduce using rule 88 (expr -> expr GE expr .)
    ,               reduce using rule 88 (expr -> expr GE expr .)
    ]               reduce using rule 88 (expr -> expr GE expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118


state 168

    (89) expr -> expr < expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 89 (expr -> expr < expr .)
    DIVEQ           reduce using rule 89 (expr -> expr < expr .)
    MULEQ           reduce using rule 89 (expr -> expr < expr .)
    MINUSEQ         reduce using rule 89 (expr -> expr < expr .)
    PLUSEQ          reduce using rule 89 (expr -> expr < expr .)
    MINUSMINUS      reduce using rule 89 (expr -> expr < expr .)
    PLUSPLUS        reduce using rule 89 (expr -> expr < expr .)
    AND             reduce using rule 89 (expr -> expr < expr .)
    OR              reduce using rule 89 (expr -> expr < expr .)
    >               reduce using rule 89 (expr -> expr < expr .)
    GE              reduce using rule 89 (expr -> expr < expr .)
    <               reduce using rule 89 (expr -> expr < expr .)
    LE              reduce using rule 89 (expr -> expr < expr .)
    NE              reduce using rule 89 (expr -> expr < expr .)
    EQ              reduce using rule 89 (expr -> expr < expr .)
    POINT           reduce using rule 89 (expr -> expr < expr .)
    )               reduce using rule 89 (expr -> expr < expr .)
    ,               reduce using rule 89 (expr -> expr < expr .)
    ]               reduce using rule 89 (expr -> expr < expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118


state 169

    (90) expr -> expr LE expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 90 (expr -> expr LE expr .)
    DIVEQ           reduce using rule 90 (expr -> expr LE expr .)
    MULEQ           reduce using rule 90 (expr -> expr LE expr .)
    MINUSEQ         reduce using rule 90 (expr -> expr LE expr .)
    PLUSEQ          reduce using rule 90 (expr -> expr LE expr .)
    MINUSMINUS      reduce using rule 90 (expr -> expr LE expr .)
    PLUSPLUS        reduce using rule 90 (expr -> expr LE expr .)
    AND             reduce using rule 90 (expr -> expr LE expr .)
    OR              reduce using rule 90 (expr -> expr LE expr .)
    >               reduce using rule 90 (expr -> expr LE expr .)
    GE              reduce using rule 90 (expr -> expr LE expr .)
    <               reduce using rule 90 (expr -> expr LE expr .)
    LE              reduce using rule 90 (expr -> expr LE expr .)
    NE              reduce using rule 90 (expr -> expr LE expr .)
    EQ              reduce using rule 90 (expr -> expr LE expr .)
    POINT           reduce using rule 90 (expr -> expr LE expr .)
    )               reduce using rule 90 (expr -> expr LE expr .)
    ,               reduce using rule 90 (expr -> expr LE expr .)
    ]               reduce using rule 90 (expr -> expr LE expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118


state 170

    (91) expr -> expr NE expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 91 (expr -> expr NE expr .)
    DIVEQ           reduce using rule 91 (expr -> expr NE expr .)
    MULEQ           reduce using rule 91 (expr -> expr NE expr .)
    MINUSEQ         reduce using rule 91 (expr -> expr NE expr .)
    PLUSEQ          reduce using rule 91 (expr -> expr NE expr .)
    MINUSMINUS      reduce using rule 91 (expr -> expr NE expr .)
    PLUSPLUS        reduce using rule 91 (expr -> expr NE expr .)
    AND             reduce using rule 91 (expr -> expr NE expr .)
    OR              reduce using rule 91 (expr -> expr NE expr .)
    NE              reduce using rule 91 (expr -> expr NE expr .)
    EQ              reduce using rule 91 (expr -> expr NE expr .)
    POINT           reduce using rule 91 (expr -> expr NE expr .)
    )               reduce using rule 91 (expr -> expr NE expr .)
    ,               reduce using rule 91 (expr -> expr NE expr .)
    ]               reduce using rule 91 (expr -> expr NE expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122


state 171

    (92) expr -> expr EQ expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 92 (expr -> expr EQ expr .)
    DIVEQ           reduce using rule 92 (expr -> expr EQ expr .)
    MULEQ           reduce using rule 92 (expr -> expr EQ expr .)
    MINUSEQ         reduce using rule 92 (expr -> expr EQ expr .)
    PLUSEQ          reduce using rule 92 (expr -> expr EQ expr .)
    MINUSMINUS      reduce using rule 92 (expr -> expr EQ expr .)
    PLUSPLUS        reduce using rule 92 (expr -> expr EQ expr .)
    AND             reduce using rule 92 (expr -> expr EQ expr .)
    OR              reduce using rule 92 (expr -> expr EQ expr .)
    NE              reduce using rule 92 (expr -> expr EQ expr .)
    EQ              reduce using rule 92 (expr -> expr EQ expr .)
    POINT           reduce using rule 92 (expr -> expr EQ expr .)
    )               reduce using rule 92 (expr -> expr EQ expr .)
    ,               reduce using rule 92 (expr -> expr EQ expr .)
    ]               reduce using rule 92 (expr -> expr EQ expr .)
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122


state 172

    (93) expr -> expr POINT IDENT . = expr ;
    (94) expr -> expr POINT IDENT . ;
    =               shift and go to state 194
    ;               shift and go to state 195


state 173

    (55) return_stmt -> RETURN expr ; .
    }               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 55 (return_stmt -> RETURN expr ; .)
    SCANF           reduce using rule 55 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 55 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 55 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 55 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 55 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 55 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 55 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 55 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    MINUSMINUS      reduce using rule 55 (return_stmt -> RETURN expr ; .)
    PLUSPLUS        reduce using rule 55 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 55 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 55 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 55 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 55 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 55 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 55 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 55 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 55 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 55 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 55 (return_stmt -> RETURN expr ; .)


state 174

    (51) while_stmt -> WHILE ( expr . ) stmt
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    )               shift and go to state 196
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 175

    (53) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (54) if_stmt -> IF ( expr . ) stmt
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    )               shift and go to state 197
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 176

    (63) expr -> MINUSMINUS expr ; .
    ;               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    DIVEQ           reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    MULEQ           reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    MINUSEQ         reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    PLUSEQ          reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    MINUSMINUS      reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    PLUSPLUS        reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    AND             reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    OR              reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    %               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    /               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    *               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    -               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    +               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    >               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    GE              reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    <               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    LE              reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    NE              reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    EQ              reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    POINT           reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    )               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    ,               reduce using rule 63 (expr -> MINUSMINUS expr ; .)
    ]               reduce using rule 63 (expr -> MINUSMINUS expr ; .)


state 177

    (64) expr -> PLUSPLUS expr ; .
    ;               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    DIVEQ           reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    MULEQ           reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    MINUSEQ         reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    PLUSEQ          reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    MINUSMINUS      reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    PLUSPLUS        reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    AND             reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    OR              reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    %               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    /               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    *               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    -               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    +               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    >               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    GE              reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    <               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    LE              reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    NE              reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    EQ              reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    POINT           reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    )               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    ,               reduce using rule 64 (expr -> PLUSPLUS expr ; .)
    ]               reduce using rule 64 (expr -> PLUSPLUS expr ; .)


state 178

    (67) expr -> NEW type_spec [ . expr ]
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 198

state 179

    (95) expr -> SUPER POINT IDENT . ;
    ;               shift and go to state 199


state 180

    (35) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 200


state 181

    (106) sprintf_stmt -> SPRINTF ( IDENT , . STRING , arg_list ) ;
    STRING          shift and go to state 201


state 182

    (72) expr -> IDENT . SIZE ; .
    ;               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    DIVEQ           reduce using rule 72 (expr -> IDENT . SIZE ; .)
    MULEQ           reduce using rule 72 (expr -> IDENT . SIZE ; .)
    MINUSEQ         reduce using rule 72 (expr -> IDENT . SIZE ; .)
    PLUSEQ          reduce using rule 72 (expr -> IDENT . SIZE ; .)
    MINUSMINUS      reduce using rule 72 (expr -> IDENT . SIZE ; .)
    PLUSPLUS        reduce using rule 72 (expr -> IDENT . SIZE ; .)
    AND             reduce using rule 72 (expr -> IDENT . SIZE ; .)
    OR              reduce using rule 72 (expr -> IDENT . SIZE ; .)
    %               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    /               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    *               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    -               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    +               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    >               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    GE              reduce using rule 72 (expr -> IDENT . SIZE ; .)
    <               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    LE              reduce using rule 72 (expr -> IDENT . SIZE ; .)
    NE              reduce using rule 72 (expr -> IDENT . SIZE ; .)
    EQ              reduce using rule 72 (expr -> IDENT . SIZE ; .)
    POINT           reduce using rule 72 (expr -> IDENT . SIZE ; .)
    )               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    ,               reduce using rule 72 (expr -> IDENT . SIZE ; .)
    ]               reduce using rule 72 (expr -> IDENT . SIZE ; .)


state 183

    (73) expr -> IDENT ( args ) .
    ;               reduce using rule 73 (expr -> IDENT ( args ) .)
    DIVEQ           reduce using rule 73 (expr -> IDENT ( args ) .)
    MULEQ           reduce using rule 73 (expr -> IDENT ( args ) .)
    MINUSEQ         reduce using rule 73 (expr -> IDENT ( args ) .)
    PLUSEQ          reduce using rule 73 (expr -> IDENT ( args ) .)
    MINUSMINUS      reduce using rule 73 (expr -> IDENT ( args ) .)
    PLUSPLUS        reduce using rule 73 (expr -> IDENT ( args ) .)
    AND             reduce using rule 73 (expr -> IDENT ( args ) .)
    OR              reduce using rule 73 (expr -> IDENT ( args ) .)
    %               reduce using rule 73 (expr -> IDENT ( args ) .)
    /               reduce using rule 73 (expr -> IDENT ( args ) .)
    *               reduce using rule 73 (expr -> IDENT ( args ) .)
    -               reduce using rule 73 (expr -> IDENT ( args ) .)
    +               reduce using rule 73 (expr -> IDENT ( args ) .)
    >               reduce using rule 73 (expr -> IDENT ( args ) .)
    GE              reduce using rule 73 (expr -> IDENT ( args ) .)
    <               reduce using rule 73 (expr -> IDENT ( args ) .)
    LE              reduce using rule 73 (expr -> IDENT ( args ) .)
    NE              reduce using rule 73 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 73 (expr -> IDENT ( args ) .)
    POINT           reduce using rule 73 (expr -> IDENT ( args ) .)
    )               reduce using rule 73 (expr -> IDENT ( args ) .)
    ,               reduce using rule 73 (expr -> IDENT ( args ) .)
    ]               reduce using rule 73 (expr -> IDENT ( args ) .)


state 184

    (102) arg_list -> arg_list , . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 202

state 185

    (74) expr -> IDENT [ expr ] .
    (97) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 74 (expr -> IDENT [ expr ] .)
    DIVEQ           reduce using rule 74 (expr -> IDENT [ expr ] .)
    MULEQ           reduce using rule 74 (expr -> IDENT [ expr ] .)
    MINUSEQ         reduce using rule 74 (expr -> IDENT [ expr ] .)
    PLUSEQ          reduce using rule 74 (expr -> IDENT [ expr ] .)
    MINUSMINUS      reduce using rule 74 (expr -> IDENT [ expr ] .)
    PLUSPLUS        reduce using rule 74 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 74 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 74 (expr -> IDENT [ expr ] .)
    %               reduce using rule 74 (expr -> IDENT [ expr ] .)
    /               reduce using rule 74 (expr -> IDENT [ expr ] .)
    *               reduce using rule 74 (expr -> IDENT [ expr ] .)
    -               reduce using rule 74 (expr -> IDENT [ expr ] .)
    +               reduce using rule 74 (expr -> IDENT [ expr ] .)
    >               reduce using rule 74 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 74 (expr -> IDENT [ expr ] .)
    <               reduce using rule 74 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 74 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 74 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 74 (expr -> IDENT [ expr ] .)
    POINT           reduce using rule 74 (expr -> IDENT [ expr ] .)
    )               reduce using rule 74 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 74 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 74 (expr -> IDENT [ expr ] .)
    =               shift and go to state 203


state 186

    (105) scanf_stmt -> SCANF ( STRING , . arg_list ) ;
    (101) arg_list -> . expr
    (102) arg_list -> . arg_list , expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    arg_list                       shift and go to state 204
    expr                           shift and go to state 147

state 187

    (103) printf_stmt -> PRINTF ( STRING , . arg_list ) ;
    (101) arg_list -> . expr
    (102) arg_list -> . arg_list , expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    arg_list                       shift and go to state 205
    expr                           shift and go to state 147

state 188

    (104) printf_stmt -> PRINTF ( STRING ) . ;
    ;               shift and go to state 206


state 189

    (52) for_stmt -> FOR ( expr ; . expr ; expr ) stmt
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 207

state 190

    (59) expr -> expr DIVEQ expr ; .
    ;               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    DIVEQ           reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    MULEQ           reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    MINUSEQ         reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    PLUSEQ          reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    MINUSMINUS      reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    PLUSPLUS        reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    AND             reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    OR              reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    %               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    /               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    *               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    -               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    +               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    >               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    GE              reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    <               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    LE              reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    NE              reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    EQ              reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    POINT           reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    )               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    ,               reduce using rule 59 (expr -> expr DIVEQ expr ; .)
    ]               reduce using rule 59 (expr -> expr DIVEQ expr ; .)


state 191

    (60) expr -> expr MULEQ expr ; .
    ;               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    DIVEQ           reduce using rule 60 (expr -> expr MULEQ expr ; .)
    MULEQ           reduce using rule 60 (expr -> expr MULEQ expr ; .)
    MINUSEQ         reduce using rule 60 (expr -> expr MULEQ expr ; .)
    PLUSEQ          reduce using rule 60 (expr -> expr MULEQ expr ; .)
    MINUSMINUS      reduce using rule 60 (expr -> expr MULEQ expr ; .)
    PLUSPLUS        reduce using rule 60 (expr -> expr MULEQ expr ; .)
    AND             reduce using rule 60 (expr -> expr MULEQ expr ; .)
    OR              reduce using rule 60 (expr -> expr MULEQ expr ; .)
    %               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    /               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    *               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    -               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    +               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    >               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    GE              reduce using rule 60 (expr -> expr MULEQ expr ; .)
    <               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    LE              reduce using rule 60 (expr -> expr MULEQ expr ; .)
    NE              reduce using rule 60 (expr -> expr MULEQ expr ; .)
    EQ              reduce using rule 60 (expr -> expr MULEQ expr ; .)
    POINT           reduce using rule 60 (expr -> expr MULEQ expr ; .)
    )               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    ,               reduce using rule 60 (expr -> expr MULEQ expr ; .)
    ]               reduce using rule 60 (expr -> expr MULEQ expr ; .)


state 192

    (61) expr -> expr MINUSEQ expr ; .
    ;               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    DIVEQ           reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    MULEQ           reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    MINUSEQ         reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    PLUSEQ          reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    MINUSMINUS      reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    PLUSPLUS        reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    AND             reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    OR              reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    %               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    /               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    *               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    -               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    +               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    >               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    GE              reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    <               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    LE              reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    NE              reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    EQ              reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    POINT           reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    )               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    ,               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)
    ]               reduce using rule 61 (expr -> expr MINUSEQ expr ; .)


state 193

    (62) expr -> expr PLUSEQ expr ; .
    ;               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    DIVEQ           reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    MULEQ           reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    MINUSEQ         reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    PLUSEQ          reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    MINUSMINUS      reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    PLUSPLUS        reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    AND             reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    OR              reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    %               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    /               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    *               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    -               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    +               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    >               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    GE              reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    <               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    LE              reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    NE              reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    EQ              reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    POINT           reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    )               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    ,               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)
    ]               reduce using rule 62 (expr -> expr PLUSEQ expr ; .)


state 194

    (93) expr -> expr POINT IDENT = . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 208

state 195

    (94) expr -> expr POINT IDENT ; .
    ;               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    DIVEQ           reduce using rule 94 (expr -> expr POINT IDENT ; .)
    MULEQ           reduce using rule 94 (expr -> expr POINT IDENT ; .)
    MINUSEQ         reduce using rule 94 (expr -> expr POINT IDENT ; .)
    PLUSEQ          reduce using rule 94 (expr -> expr POINT IDENT ; .)
    MINUSMINUS      reduce using rule 94 (expr -> expr POINT IDENT ; .)
    PLUSPLUS        reduce using rule 94 (expr -> expr POINT IDENT ; .)
    AND             reduce using rule 94 (expr -> expr POINT IDENT ; .)
    OR              reduce using rule 94 (expr -> expr POINT IDENT ; .)
    %               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    /               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    *               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    -               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    +               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    >               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    GE              reduce using rule 94 (expr -> expr POINT IDENT ; .)
    <               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    LE              reduce using rule 94 (expr -> expr POINT IDENT ; .)
    NE              reduce using rule 94 (expr -> expr POINT IDENT ; .)
    EQ              reduce using rule 94 (expr -> expr POINT IDENT ; .)
    POINT           reduce using rule 94 (expr -> expr POINT IDENT ; .)
    )               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    ,               reduce using rule 94 (expr -> expr POINT IDENT ; .)
    ]               reduce using rule 94 (expr -> expr POINT IDENT ; .)


state 196

    (51) while_stmt -> WHILE ( expr ) . stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 74
    stmt                           shift and go to state 209
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65

state 197

    (53) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (54) if_stmt -> IF ( expr ) . stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 74
    stmt                           shift and go to state 210
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65

state 198

    (67) expr -> NEW type_spec [ expr . ]
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ]               shift and go to state 211
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 199

    (95) expr -> SUPER POINT IDENT ; .
    ;               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    DIVEQ           reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    MULEQ           reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    MINUSEQ         reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    PLUSEQ          reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    MINUSMINUS      reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    PLUSPLUS        reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    AND             reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    OR              reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    %               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    /               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    *               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    -               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    +               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    >               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    GE              reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    <               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    LE              reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    NE              reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    EQ              reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    POINT           reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    )               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    ,               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)
    ]               reduce using rule 95 (expr -> SUPER POINT IDENT ; .)


state 200

    (35) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    SPRINTF         reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    SCANF           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    PRINTF          reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    MINUSMINUS      reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    PLUSPLUS        reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    SUPER           reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)
    THIS            reduce using rule 35 (local_decl -> type_spec IDENT [ ] ; .)


state 201

    (106) sprintf_stmt -> SPRINTF ( IDENT , STRING . , arg_list ) ;
    ,               shift and go to state 212


state 202

    (102) arg_list -> arg_list , expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ,               reduce using rule 102 (arg_list -> arg_list , expr .)
    )               reduce using rule 102 (arg_list -> arg_list , expr .)
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 203

    (97) expr -> IDENT [ expr ] = . expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 213

state 204

    (105) scanf_stmt -> SCANF ( STRING , arg_list . ) ;
    (102) arg_list -> arg_list . , expr
    )               shift and go to state 214
    ,               shift and go to state 184


state 205

    (103) printf_stmt -> PRINTF ( STRING , arg_list . ) ;
    (102) arg_list -> arg_list . , expr
    )               shift and go to state 215
    ,               shift and go to state 184


state 206

    (104) printf_stmt -> PRINTF ( STRING ) ; .
    }               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    SPRINTF         reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    SCANF           reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    PRINTF          reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    FOR             reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    CONTINUE        reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    BREAK           reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    RETURN          reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    WHILE           reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    IF              reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    {               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    ;               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    MINUSMINUS      reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    PLUSPLUS        reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    NEW             reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    STRING          reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    FLOAT_LIT       reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    INT_LIT         reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    BOOL_LIT        reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    IDENT           reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    (               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    +               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    -               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    !               reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    SUPER           reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    THIS            reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)
    ELSE            reduce using rule 104 (printf_stmt -> PRINTF ( STRING ) ; .)


state 207

    (52) for_stmt -> FOR ( expr ; expr . ; expr ) stmt
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 216
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 208

    (93) expr -> expr POINT IDENT = expr . ;
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               shift and go to state 217
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 209

    (51) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    SCANF           reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    MINUSMINUS      reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    PLUSPLUS        reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 51 (while_stmt -> WHILE ( expr ) stmt .)


state 210

    (53) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (54) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 218
    }               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    SCANF           reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    MINUSMINUS      reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    PLUSPLUS        reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 54 (if_stmt -> IF ( expr ) stmt .)


state 211

    (67) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    DIVEQ           reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    MULEQ           reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    MINUSEQ         reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    PLUSEQ          reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    MINUSMINUS      reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    PLUSPLUS        reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    POINT           reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 67 (expr -> NEW type_spec [ expr ] .)


state 212

    (106) sprintf_stmt -> SPRINTF ( IDENT , STRING , . arg_list ) ;
    (101) arg_list -> . expr
    (102) arg_list -> . arg_list , expr
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    arg_list                       shift and go to state 219
    expr                           shift and go to state 147

state 213

    (97) expr -> IDENT [ expr ] = expr .
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    ;               reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    DIVEQ           reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    MULEQ           reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    MINUSEQ         reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    PLUSEQ          reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    MINUSMINUS      reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    PLUSPLUS        reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    POINT           reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 97 (expr -> IDENT [ expr ] = expr .)
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124


state 214

    (105) scanf_stmt -> SCANF ( STRING , arg_list ) . ;
    ;               shift and go to state 220


state 215

    (103) printf_stmt -> PRINTF ( STRING , arg_list ) . ;
    ;               shift and go to state 221


state 216

    (52) for_stmt -> FOR ( expr ; expr ; . expr ) stmt
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 222

state 217

    (93) expr -> expr POINT IDENT = expr ; .
    ;               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    DIVEQ           reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    MULEQ           reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    MINUSEQ         reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    PLUSEQ          reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    MINUSMINUS      reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    PLUSPLUS        reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    AND             reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    OR              reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    %               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    /               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    *               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    -               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    +               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    >               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    GE              reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    <               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    LE              reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    NE              reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    EQ              reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    POINT           reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    )               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    ,               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)
    ]               reduce using rule 93 (expr -> expr POINT IDENT = expr ; .)


state 218

    (53) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 74
    stmt                           shift and go to state 223
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65

state 219

    (106) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list . ) ;
    (102) arg_list -> arg_list . , expr
    )               shift and go to state 224
    ,               shift and go to state 184


state 220

    (105) scanf_stmt -> SCANF ( STRING , arg_list ) ; .
    }               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IF              reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    {               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ;               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    (               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    +               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    -               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    !               reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 105 (scanf_stmt -> SCANF ( STRING , arg_list ) ; .)


state 221

    (103) printf_stmt -> PRINTF ( STRING , arg_list ) ; .
    }               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SCANF           reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PRINTF          reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FOR             reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BREAK           reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    RETURN          reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    WHILE           reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IF              reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    {               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ;               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    NEW             reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    STRING          reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    IDENT           reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    (               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    +               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    -               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    !               reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    SUPER           reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    THIS            reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)
    ELSE            reduce using rule 103 (printf_stmt -> PRINTF ( STRING , arg_list ) ; .)


state 222

    (52) for_stmt -> FOR ( expr ; expr ; expr . ) stmt
    (59) expr -> expr . DIVEQ expr ;
    (60) expr -> expr . MULEQ expr ;
    (61) expr -> expr . MINUSEQ expr ;
    (62) expr -> expr . PLUSEQ expr ;
    (65) expr -> expr . MINUSMINUS ;
    (66) expr -> expr . PLUSPLUS ;
    (80) expr -> expr . AND expr
    (81) expr -> expr . OR expr
    (82) expr -> expr . % expr
    (83) expr -> expr . / expr
    (84) expr -> expr . * expr
    (85) expr -> expr . - expr
    (86) expr -> expr . + expr
    (87) expr -> expr . > expr
    (88) expr -> expr . GE expr
    (89) expr -> expr . < expr
    (90) expr -> expr . LE expr
    (91) expr -> expr . NE expr
    (92) expr -> expr . EQ expr
    (93) expr -> expr . POINT IDENT = expr ;
    (94) expr -> expr . POINT IDENT ;
    )               shift and go to state 225
    DIVEQ           shift and go to state 106
    MULEQ           shift and go to state 107
    MINUSEQ         shift and go to state 108
    PLUSEQ          shift and go to state 109
    MINUSMINUS      shift and go to state 110
    PLUSPLUS        shift and go to state 111
    AND             shift and go to state 112
    OR              shift and go to state 113
    %               shift and go to state 114
    /               shift and go to state 115
    *               shift and go to state 116
    -               shift and go to state 117
    +               shift and go to state 118
    >               shift and go to state 119
    GE              shift and go to state 120
    <               shift and go to state 121
    LE              shift and go to state 122
    NE              shift and go to state 123
    EQ              shift and go to state 124
    POINT           shift and go to state 125


state 223

    (53) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SCANF           reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 53 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 224

    (106) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) . ;
    ;               shift and go to state 226


state 225

    (52) for_stmt -> FOR ( expr ; expr ; expr ) . stmt
    (39) stmt -> . sprintf_stmt
    (40) stmt -> . scanf_stmt
    (41) stmt -> . printf_stmt
    (42) stmt -> . for_stmt
    (43) stmt -> . break_stmt
    (44) stmt -> . return_stmt
    (45) stmt -> . while_stmt
    (46) stmt -> . if_stmt
    (47) stmt -> . compound_stmt
    (48) stmt -> . expr_stmt
    (106) sprintf_stmt -> . SPRINTF ( IDENT , STRING , arg_list ) ;
    (105) scanf_stmt -> . SCANF ( STRING , arg_list ) ;
    (103) printf_stmt -> . PRINTF ( STRING , arg_list ) ;
    (104) printf_stmt -> . PRINTF ( STRING ) ;
    (52) for_stmt -> . FOR ( expr ; expr ; expr ) stmt
    (57) break_stmt -> . CONTINUE ;
    (58) break_stmt -> . BREAK ;
    (55) return_stmt -> . RETURN expr ;
    (56) return_stmt -> . RETURN ;
    (51) while_stmt -> . WHILE ( expr ) stmt
    (53) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (54) if_stmt -> . IF ( expr ) stmt
    (30) compound_stmt -> . { local_decls stmt_list }
    (49) expr_stmt -> . ;
    (50) expr_stmt -> . expr ;
    (59) expr -> . expr DIVEQ expr ;
    (60) expr -> . expr MULEQ expr ;
    (61) expr -> . expr MINUSEQ expr ;
    (62) expr -> . expr PLUSEQ expr ;
    (63) expr -> . MINUSMINUS expr ;
    (64) expr -> . PLUSPLUS expr ;
    (65) expr -> . expr MINUSMINUS ;
    (66) expr -> . expr PLUSPLUS ;
    (67) expr -> . NEW type_spec [ expr ]
    (68) expr -> . STRING
    (69) expr -> . FLOAT_LIT
    (70) expr -> . INT_LIT
    (71) expr -> . BOOL_LIT
    (72) expr -> . IDENT . SIZE ;
    (73) expr -> . IDENT ( args )
    (74) expr -> . IDENT [ expr ]
    (75) expr -> . IDENT
    (76) expr -> . ( expr )
    (77) expr -> . + expr
    (78) expr -> . - expr
    (79) expr -> . ! expr
    (80) expr -> . expr AND expr
    (81) expr -> . expr OR expr
    (82) expr -> . expr % expr
    (83) expr -> . expr / expr
    (84) expr -> . expr * expr
    (85) expr -> . expr - expr
    (86) expr -> . expr + expr
    (87) expr -> . expr > expr
    (88) expr -> . expr GE expr
    (89) expr -> . expr < expr
    (90) expr -> . expr LE expr
    (91) expr -> . expr NE expr
    (92) expr -> . expr EQ expr
    (93) expr -> . expr POINT IDENT = expr ;
    (94) expr -> . expr POINT IDENT ;
    (95) expr -> . SUPER POINT IDENT ;
    (96) expr -> . THIS
    (97) expr -> . IDENT [ expr ] = expr
    (98) expr -> . IDENT = expr
    SPRINTF         shift and go to state 66
    SCANF           shift and go to state 71
    PRINTF          shift and go to state 72
    FOR             shift and go to state 73
    CONTINUE        shift and go to state 75
    BREAK           shift and go to state 76
    RETURN          shift and go to state 77
    WHILE           shift and go to state 78
    IF              shift and go to state 79
    {               shift and go to state 43
    ;               shift and go to state 70
    MINUSMINUS      shift and go to state 80
    PLUSPLUS        shift and go to state 81
    NEW             shift and go to state 82
    STRING          shift and go to state 69
    FLOAT_LIT       shift and go to state 83
    INT_LIT         shift and go to state 84
    BOOL_LIT        shift and go to state 85
    IDENT           shift and go to state 68
    (               shift and go to state 67
    +               shift and go to state 86
    -               shift and go to state 87
    !               shift and go to state 88
    SUPER           shift and go to state 89
    THIS            shift and go to state 90

    expr                           shift and go to state 74
    stmt                           shift and go to state 227
    sprintf_stmt                   shift and go to state 56
    scanf_stmt                     shift and go to state 57
    printf_stmt                    shift and go to state 58
    for_stmt                       shift and go to state 59
    break_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 61
    while_stmt                     shift and go to state 62
    if_stmt                        shift and go to state 63
    compound_stmt                  shift and go to state 64
    expr_stmt                      shift and go to state 65

state 226

    (106) sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .
    }               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SPRINTF         reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SCANF           reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PRINTF          reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FOR             reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    CONTINUE        reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BREAK           reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    RETURN          reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    WHILE           reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IF              reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    {               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ;               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    MINUSMINUS      reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    PLUSPLUS        reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    NEW             reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    STRING          reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    FLOAT_LIT       reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    INT_LIT         reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    BOOL_LIT        reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    IDENT           reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    (               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    +               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    -               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    !               reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    SUPER           reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    THIS            reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)
    ELSE            reduce using rule 106 (sprintf_stmt -> SPRINTF ( IDENT , STRING , arg_list ) ; .)


state 227

    (52) for_stmt -> FOR ( expr ; expr ; expr ) stmt .
    }               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SPRINTF         reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SCANF           reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PRINTF          reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FOR             reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    CONTINUE        reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BREAK           reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    RETURN          reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    WHILE           reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IF              reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    {               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ;               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    MINUSMINUS      reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    PLUSPLUS        reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    NEW             reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    STRING          reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    FLOAT_LIT       reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    INT_LIT         reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    BOOL_LIT        reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    IDENT           reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    (               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    +               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    -               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    !               reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    SUPER           reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    THIS            reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
    ELSE            reduce using rule 52 (for_stmt -> FOR ( expr ; expr ; expr ) stmt .)
